{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference","text":""},{"location":"#welcome-to-the-featureform-api-reference","title":"Welcome to the Featureform API Reference!","text":"<p>Featureform's Python API Reference provides a means to access hosted Featureform instances, as well as the ability to experiment in Localmode. </p> <p>Using this SDK, you can register providers, sources, transformations, features, labels, and training sets  both locally and in a hosted instance. You can also use the serving client functionality to retrieve training sets and  features for online serving.</p>"},{"location":"#additional-support","title":"Additional Support","text":"<p>If you've read the documentation and still have questions, checkout our main docs.</p> <p>You can also join our community on Slack and GitHub!</p>"},{"location":"autogenerated_variants/","title":"Autogenerated Variants","text":"<p>When creating a resource, variants can be explicitly defined in the <code>variant</code> field of Sources, Transformations,  Features, Labels, and Training Sets. If no variant is defined, a randomly generated variant is created and used.</p> <p>The same randomly generated variant is added to each resource until <code>import featureform</code> is called again or  <code>featureform.set_run()</code> is called. </p>"},{"location":"autogenerated_variants/#setting-a-run","title":"Setting A Run","text":"<p>Variants can be explicitly defined by calling <code>featureform.set_run(\"my_variant\")</code> with a string argument.  This string will be used as the variant from that point forward. Calling <code>featureform.set_run()</code> with no arguments will create a new auto-generated variant.</p> <p>Example 1: Using set_run() without arguments will generate a random run name. <pre><code>import featureform as ff\nff.set_run()\n\npostgres.register_table(\n    name=\"transactions\",\n    table=\"transactions_table\",\n)\n\n# Applying will register the source as name=transactions, variant=&lt;randomly-generated&gt;\n</code></pre></p> <p>Example 2: Using set_run() with arguments will set the variant to the provided name. <pre><code>import featureform as ff\nff.set_run(\"last_30_days\")\n\npostgres.register_table(\n    name=\"transactions\",\n    table=\"transactions_table\",\n)\n\n# Applying will register the source as name=transactions, variant=last_30_days\n</code></pre></p> <p>Example 3: Generated and set variant names can be used together <pre><code>import featureform as ff\nff.set_run()\n\nfile = spark.register_file(\n    name=\"transactions\",\n    path=\"my/transactions.parquet\",\n    variant=\"last_30_days\"\n)\n\n@spark.df_transformation(inputs=[file]):\ndef customer_count(transactions):\n    return transactions.groupBy(\"CustomerID\").count()\n\n\n# Applying without a variant for the dataframe transformation will result in\n# the transactions source having a variant of last_30_days and the transformation\n# having a randomly generated variant\n</code></pre></p> <p>Example 4: This also works within SQL Transformations <pre><code>import featureform as ff\nff.set_run(\"last_30_days\")\n\n@postgres.sql_transformation():\ndef my_transformation():\n    return \"SELECT CustomerID, Amount FROM {{ transactions }}\"\n\n# The variant will be autofilled so the SQL query is returned as:\n# \"SELECT CustomerID, Amount FROM {{ transactions.last_30_days }}\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>run</code> <code>str</code> <p>Name of a run to be set.</p> <code>''</code>"},{"location":"autogenerated_variants/#getting-a-run","title":"Getting A Run","text":"<p>The currently set run can be gotten by calling <code>featureform.get_run()</code>. This will return a string of the current run.</p> <p>This is useful when using serving functions from the notebook that resources are being applied in. </p> <p>Get the current run name.</p> <p>Examples: <pre><code>import featureform as ff\n\nclient = ff.Client()\nf = client.features((\"avg_transaction_amount\", ff.get_run()), {\"user\": \"123\"})\n</code></pre></p> <p>Returns:</p> Name Type Description <code>run</code> <code>str</code> <p>The name of the current run</p>"},{"location":"cli/","title":"CLI","text":"<p>The Featureform CLI allows you to describe, list, and monitor your resources.</p>"},{"location":"cli/#connecting-to-a-cluster","title":"Connecting to a cluster","text":"<p>To connect to a cluster through the CLI, you can either set environment variables or explicitly pass in the host and cert flags. The certificate is only required when using self-signed certificates.</p>"},{"location":"cli/#with-environment-variables","title":"With Environment Variables","text":"<p><pre><code>export FEATUREFORM_HOST=&lt;host&gt;\nexport FEATUREFORM_CERT=&lt;cert&gt;\n</code></pre> then run: <pre><code>featureform &lt;command&gt;\n</code></pre></p>"},{"location":"cli/#with-flags","title":"With Flags","text":"<pre><code>featureform &lt;command&gt; --host &lt;host&gt; --cert &lt;cert&gt;\n</code></pre>"},{"location":"cli/#apply","title":"Apply","text":"<p>The apply command submits resource definitions to the Featureform instance. </p> <p>The argument can either be a path to a local file or the url of a hosted file. Multiple files can be included at a time.</p> <pre><code>featureform apply &lt;definitions.py&gt;\n</code></pre> <p>Upon success, all definitions in the definitions.py (or whatever you choose to call it) file will be sent to the Featureform instance, logged in the metadata, and materialized with the registered providers.</p> <p>After applying new resource definitions, you can use the GET command to see the status of the resources you applied. A resource with the status READY is available for serving.</p>"},{"location":"cli/#get","title":"Get","text":"<p>The GET command displays status, variants, and other metadata on a resource.</p> <pre><code>featureform get RESOURCE_TYPE NAME [VARIANT] --host $FEATUREFORM_HOST --cert $FEATUREFORM_CERT\n</code></pre> <p>RESOURCE_TYPE (required) can be:</p> <ul> <li>feature - machine learning features</li> <li>label - machine learning labels</li> <li>training-set - set of features and one label for training ML models</li> <li>user - registered users in your instance</li> <li>entity - identifier for a source of features or labels (akin to a primary key)</li> <li>model - registered machine learning models which training sets and features are fed to</li> <li>provider - registered 3rd party providers which store your data</li> <li>source - files, tables, or transformations that features, labels and training sets source from</li> </ul> <p>NAME is the name of the resource type to be queried.</p> <p>VARIANT is optional, for when information on a specific variant is needed.</p>"},{"location":"cli/#example-getting-a-user","title":"Example: Getting a User","text":"<p>The commands are both valid ways to retrieve information on the user \"featureformer\".</p> <p>The first is with certification. The second without; the --insecure flag disables the need for the --cert flag</p> <pre><code>featureform get user featureformer --host $FEATUREFORM_HOST --cert $FEATUREFORM_CERT\nfeatureform get user featureformer --insecure --host $FEATUREFORM_HOST\n</code></pre> <p>Either command returns the following output. </p> <pre><code>USER NAME:  featureformer\n\nNAME                           VARIANT                             TYPE\navg_transactions               quickstart                          feature\nfraudulent                     quickstart                          label\nfraud_training                 quickstart                          training set\ntransactions                   kaggle                              source\naverage_user_transaction       quickstart                          source\n</code></pre> <p>Listed below the user are all the resources registered to that user.</p>"},{"location":"cli/#example-getting-a-resource","title":"Example: Getting a Resource","text":"<p>The following command shows how to retrieve information on a specific resource, a feature named \"avg_transactions\".</p> <pre><code>featureform get feature avg_transactions --host $FEATUREFORM_HOST --cert $FEATUREFORM_CERT\n\nNAME:  avg_transactions\nSTATUS:  NO_STATUS\nVARIANTS:\nquickstart           default\nv1\nv2\nprodThis would be the output:\n</code></pre>"},{"location":"cli/#example-getting-a-resource-variant","title":"Example: Getting a Resource Variant","text":"<p>The command below retrieves information on the specific variant of the feature \"avg_transactions\", \"quickstart\"</p> <pre><code>featureform get feature avg_transactions quickstart --host $FEATUREFORM_HOST --cert $FEATUREFORM_CERT\n\nNAME:                avg_transactions\nVARIANT:             quickstart     \nTYPE:                float32\nENTITY:              user\nOWNER:               featureformer\nDESCRIPTION:\nPROVIDER:            redis-quickstart\nSTATUS:              READY\n\nSOURCE:\nNAME                           VARIANT\naverage_user_transaction       quickstart\n\nTRAINING SETS:\nNAME                           VARIANT\nfraud_training                 quickstart\n</code></pre> <p>Listed below are the metadata on that variant, as well as its source and the training sets it belongs to.</p>"},{"location":"cli/#list","title":"List","text":"<p>The LIST command displays the name, variant and status of all the resources of that resource type.</p> <pre><code>featureform list RESOURCE_TYPE --host $FEATUREFORM_HOST \u2013cert $FEATUREFORM_CERT\n</code></pre> <p>RESOURCE_TYPE (required) can be:</p> <ul> <li>features - machine learning features</li> <li>labels - machine learning labels</li> <li>training-sets - set of features and one label for training ML models</li> <li>users - registered users in your instance</li> <li>entities - identifier for a source of features or labels (akin to a primary key)</li> <li>models - registered machine learning models which training sets and features are fed to</li> <li>providers - registered 3rd party providers which store your data</li> <li>sources - files, tables, or transformations that features, labels and training sets source from</li> </ul> <p>NOTE: The --cert $FEATUREFORM_CERT is only required for self-signed certs</p>"},{"location":"cli/#example-getting-the-list-of-users","title":"Example: Getting the list of users","text":"<pre><code>featureform list users --host $FEATUREFORM_HOST --cert $FEATUREFORM_CERT\nfeatureform list users --insecure --host $FEATUREFORM_HOST\n</code></pre> <p>The commands are both valid ways to retrieve a list of users. The first is when the user uses a self-signed cert.</p> <p>The above commands return the following list of users which have been registered:</p> <pre><code>NAME               STATUS\ndefault_user       ready\nfeatureformer      ready\n</code></pre>"},{"location":"cli/#example-getting-the-list-of-resources-of-a-given-type","title":"Example: Getting the list of resources of a given type","text":"<pre><code>featureform list features --host $FEATUREFORM_HOST --cert $FEATUREFORM_CERT\nfeatureform list features --insecure --host $FEATUREFORM_HOST\n</code></pre> <p>The given commands return the list of registered features and their variants</p> <pre><code>NAME               VARIANT                STATUS\navg_transactions   quickstart(default)    ready\n</code></pre>"},{"location":"client/","title":"Client","text":""},{"location":"client/#featureform.client.Client","title":"<code>Client</code>","text":"<p>               Bases: <code>ResourceClient</code>, <code>ServingClient</code></p> <p>Client for interacting with Featureform APIs (resources and serving)</p> <p>Using the Client: definitions.py<pre><code>import featureform as ff\nfrom featureform import Client\n\nclient = Client()\n\n# Example 1: Get a registered provider\nredis = client.get_provider(\"redis-quickstart\")\n\n# Example 2: Compute a dataframe from a registered source\ntransactions_df = client.dataframe(\"transactions\", \"quickstart\")\n</code></pre></p> Source code in <code>src/featureform/client.py</code> <pre><code>class Client(ResourceClient, ServingClient):\n    \"\"\"\n    Client for interacting with Featureform APIs (resources and serving)\n\n    **Using the Client:**\n    ```py title=\"definitions.py\"\n    import featureform as ff\n    from featureform import Client\n\n    client = Client()\n\n    # Example 1: Get a registered provider\n    redis = client.get_provider(\"redis-quickstart\")\n\n    # Example 2: Compute a dataframe from a registered source\n    transactions_df = client.dataframe(\"transactions\", \"quickstart\")\n    ```\n    \"\"\"\n\n    def __init__(\n        self, host=None, local=False, insecure=False, cert_path=None, dry_run=False\n    ):\n        if local:\n            raise Exception(\n                \"Local mode is not supported in this version. Use featureform &lt;= 1.12.0 for localmode\"\n            )\n\n        if host is not None:\n            self._validate_host(host)\n\n        ResourceClient.__init__(\n            self,\n            host=host,\n            local=local,\n            insecure=insecure,\n            cert_path=cert_path,\n            dry_run=dry_run,\n        )\n        # Given both ResourceClient and ServingClient are instantiated together, if dry_run is True, then\n        # the ServingClient cannot be instantiated due to a conflict the local and host arguments.\n        if not dry_run:\n            ServingClient.__init__(\n                self, host=host, local=local, insecure=insecure, cert_path=cert_path\n            )\n\n    def dataframe(\n        self,\n        source: Union[SourceRegistrar, SubscriptableTransformation, str],\n        variant: Optional[str] = None,\n        limit=NO_RECORD_LIMIT,\n        asynchronous=False,\n        verbose=False,\n    ):\n        \"\"\"\n        Return a dataframe from a registered source or transformation\n\n        **Example:**\n        ```py title=\"definitions.py\"\n        transactions_df = client.dataframe(\"transactions\", \"quickstart\")\n\n        avg_user_transaction_df = transactions_df.groupby(\"CustomerID\")[\"TransactionAmount\"].mean()\n        ```\n\n        Args:\n            source (Union[SourceRegistrar, SubscriptableTransformation, str]): The source or transformation to compute the dataframe from\n            variant (str): The source variant; can't be None if source is a string\n            limit (int): The maximum number of records to return; defaults to NO_RECORD_LIMIT\n            asynchronous (bool): Flag to determine whether the client should wait for resources to be in either a READY or FAILED state before returning. Defaults to False to ensure that newly registered resources are in a READY state prior to serving them as dataframes.\n\n        Returns:\n            df (pandas.DataFrame): The dataframe computed from the source or transformation\n\n        \"\"\"\n        self.apply(asynchronous=asynchronous, verbose=verbose)\n        if isinstance(source, (SourceRegistrar, SubscriptableTransformation)):\n            name, variant = source.name_variant()\n        elif isinstance(source, str):\n            name = source\n            if variant is None:\n                raise ValueError(\"variant must be specified if source is a string\")\n            if variant == \"\":\n                raise ValueError(\"variant cannot be an empty string\")\n        else:\n            raise ValueError(\n                f\"source must be of type SourceRegistrar, SubscriptableTransformation or str, not {type(source)}\\n\"\n                \"use client.dataframe(name, variant) or client.dataframe(source) or client.dataframe(transformation)\"\n            )\n        return self.impl._get_source_as_df(name, variant, limit)\n\n    def nearest(self, feature, vector, k):\n        \"\"\"\n        Query the K nearest neighbors of a provider vector in the index of a registered feature variant\n\n        **Example:**\n\n        ```py title=\"definitions.py\"\n        # Get the 5 nearest neighbors of the vector [0.1, 0.2, 0.3] in the index of the feature \"my_feature\" with variant \"my_variant\"\n        nearest_neighbors = client.nearest(\"my_feature\", \"my_variant\", [0.1, 0.2, 0.3], 5)\n        print(nearest_neighbors) # prints a list of entities (e.g. [\"entity1\", \"entity2\", \"entity3\", \"entity4\", \"entity5\"])\n        ```\n\n        Args:\n            feature (Union[FeatureColumnResource, tuple(str, str)]): Feature object or tuple of Feature name and variant\n            vector (List[float]): Query vector\n            k (int): Number of nearest neighbors to return\n\n        \"\"\"\n        if isinstance(feature, tuple):\n            name, variant = feature\n        elif isinstance(feature, FeatureColumnResource):\n            name = feature.name\n            variant = feature.variant\n        else:\n            raise Exception(\n                f\"the feature '{feature}' of type '{type(feature)}' is not support.\"\n                \"Feature must be a tuple of (name, variant) or a FeatureColumnResource\"\n            )\n\n        if k &lt; 1:\n            raise ValueError(\"k must be a positive integer\")\n        return self.impl.nearest(name, variant, vector, k)\n\n    def location(\n        self,\n        source: Union[SourceRegistrar, SubscriptableTransformation, str],\n        variant: Optional[str] = None,\n        resource_type: Optional[ResourceType] = None,\n    ):\n        \"\"\"\n        Returns the location of a registered resource. For SQL resources, it will return the table name\n        and for file resources, it will return the file path.\n\n        **Example:**\n        ```py title=\"definitions.py\"\n        transaction_location = client.location(\"transactions\", \"quickstart\", ff.SOURCE)\n        ```\n\n        Args:\n            source (Union[SourceRegistrar, SubscriptableTransformation, str]): The source or transformation to compute the dataframe from\n            variant (str): The source variant; can't be None if source is a string\n            resource_type (ResourceType): The type of resource; can be one of ff.SOURCE, ff.FEATURE, ff.LABEL, or ff.TRAINING_SET\n        \"\"\"\n        if isinstance(source, (SourceRegistrar, SubscriptableTransformation)):\n            name, variant = source.name_variant()\n            resource_type = ResourceType.SOURCE\n        elif isinstance(source, featureform.resources.TrainingSetVariant):\n            name = source.name\n            variant = source.variant\n            resource_type = ResourceType.TRAINING_SET\n        elif isinstance(source, str):\n            name = source\n            if variant is None:\n                raise ValueError(\"variant must be specified if source is a string\")\n            if variant == \"\":\n                raise ValueError(\"variant cannot be an empty string\")\n\n            if resource_type is None:\n                raise ValueError(\n                    \"resource_type must be specified if source is a string\"\n                )\n\n        else:\n            raise ValueError(\n                f\"source must be of type SourceRegistrar, SubscriptableTransformation or str, not {type(resource)}\\n\"\n                \"use client.dataframe(name, variant) or client.dataframe(source) or client.dataframe(transformation)\"\n            )\n\n        location = self.impl.location(name, variant, resource_type)\n        return location\n\n    def close(self):\n        \"\"\"\n        Closes the client, closes channel for hosted mode\n        \"\"\"\n        self.impl.close()\n\n    def columns(\n        self,\n        source: Union[SourceRegistrar, SubscriptableTransformation, str],\n        variant: Optional[str] = None,\n    ):\n        \"\"\"\n        Returns the columns of a registered source or transformation\n\n        **Example:**\n        ```py title=\"definitions.py\"\n        columns = client.columns(\"transactions\", \"quickstart\")\n        ```\n\n        Args:\n            source (Union[SourceRegistrar, SubscriptableTransformation, str]): The source or transformation to get the columns from\n            variant (str): The source variant; can't be None if source is a string\n\n        Returns:\n            columns (List[str]): The columns of the source or transformation\n        \"\"\"\n        if isinstance(source, (SourceRegistrar, SubscriptableTransformation)):\n            name, variant = source.name_variant()\n        elif isinstance(source, str):\n            name = source\n            if variant is None:\n                raise ValueError(\"variant must be specified if source is a string\")\n            if variant == \"\":\n                raise ValueError(\"variant cannot be an empty string\")\n        else:\n            raise ValueError(\n                f\"source must be of type SourceRegistrar, SubscriptableTransformation or str, not {type(source)}\\n\"\n                \"use client.columns(name, variant) or client.columns(source) or client.columns(transformation)\"\n            )\n        return self.impl._get_source_columns(name, variant)\n\n    @staticmethod\n    def _validate_host(host):\n        if host.startswith(\"http://\") or host.startswith(\"https://\"):\n            raise ValueError(\"Invalid Host: Host should not contain http or https.\")\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.close()\n</code></pre>"},{"location":"client/#featureform.client.Client.close","title":"<code>close()</code>","text":"<p>Closes the client, closes channel for hosted mode</p> Source code in <code>src/featureform/client.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the client, closes channel for hosted mode\n    \"\"\"\n    self.impl.close()\n</code></pre>"},{"location":"client/#featureform.client.Client.columns","title":"<code>columns(source, variant=None)</code>","text":"<p>Returns the columns of a registered source or transformation</p> <p>Example: definitions.py<pre><code>columns = client.columns(\"transactions\", \"quickstart\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[SourceRegistrar, SubscriptableTransformation, str]</code> <p>The source or transformation to get the columns from</p> required <code>variant</code> <code>str</code> <p>The source variant; can't be None if source is a string</p> <code>None</code> <p>Returns:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>The columns of the source or transformation</p> Source code in <code>src/featureform/client.py</code> <pre><code>def columns(\n    self,\n    source: Union[SourceRegistrar, SubscriptableTransformation, str],\n    variant: Optional[str] = None,\n):\n    \"\"\"\n    Returns the columns of a registered source or transformation\n\n    **Example:**\n    ```py title=\"definitions.py\"\n    columns = client.columns(\"transactions\", \"quickstart\")\n    ```\n\n    Args:\n        source (Union[SourceRegistrar, SubscriptableTransformation, str]): The source or transformation to get the columns from\n        variant (str): The source variant; can't be None if source is a string\n\n    Returns:\n        columns (List[str]): The columns of the source or transformation\n    \"\"\"\n    if isinstance(source, (SourceRegistrar, SubscriptableTransformation)):\n        name, variant = source.name_variant()\n    elif isinstance(source, str):\n        name = source\n        if variant is None:\n            raise ValueError(\"variant must be specified if source is a string\")\n        if variant == \"\":\n            raise ValueError(\"variant cannot be an empty string\")\n    else:\n        raise ValueError(\n            f\"source must be of type SourceRegistrar, SubscriptableTransformation or str, not {type(source)}\\n\"\n            \"use client.columns(name, variant) or client.columns(source) or client.columns(transformation)\"\n        )\n    return self.impl._get_source_columns(name, variant)\n</code></pre>"},{"location":"client/#featureform.client.Client.dataframe","title":"<code>dataframe(source, variant=None, limit=NO_RECORD_LIMIT, asynchronous=False, verbose=False)</code>","text":"<p>Return a dataframe from a registered source or transformation</p> <p>Example: definitions.py<pre><code>transactions_df = client.dataframe(\"transactions\", \"quickstart\")\n\navg_user_transaction_df = transactions_df.groupby(\"CustomerID\")[\"TransactionAmount\"].mean()\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[SourceRegistrar, SubscriptableTransformation, str]</code> <p>The source or transformation to compute the dataframe from</p> required <code>variant</code> <code>str</code> <p>The source variant; can't be None if source is a string</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of records to return; defaults to NO_RECORD_LIMIT</p> <code>NO_RECORD_LIMIT</code> <code>asynchronous</code> <code>bool</code> <p>Flag to determine whether the client should wait for resources to be in either a READY or FAILED state before returning. Defaults to False to ensure that newly registered resources are in a READY state prior to serving them as dataframes.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>The dataframe computed from the source or transformation</p> Source code in <code>src/featureform/client.py</code> <pre><code>def dataframe(\n    self,\n    source: Union[SourceRegistrar, SubscriptableTransformation, str],\n    variant: Optional[str] = None,\n    limit=NO_RECORD_LIMIT,\n    asynchronous=False,\n    verbose=False,\n):\n    \"\"\"\n    Return a dataframe from a registered source or transformation\n\n    **Example:**\n    ```py title=\"definitions.py\"\n    transactions_df = client.dataframe(\"transactions\", \"quickstart\")\n\n    avg_user_transaction_df = transactions_df.groupby(\"CustomerID\")[\"TransactionAmount\"].mean()\n    ```\n\n    Args:\n        source (Union[SourceRegistrar, SubscriptableTransformation, str]): The source or transformation to compute the dataframe from\n        variant (str): The source variant; can't be None if source is a string\n        limit (int): The maximum number of records to return; defaults to NO_RECORD_LIMIT\n        asynchronous (bool): Flag to determine whether the client should wait for resources to be in either a READY or FAILED state before returning. Defaults to False to ensure that newly registered resources are in a READY state prior to serving them as dataframes.\n\n    Returns:\n        df (pandas.DataFrame): The dataframe computed from the source or transformation\n\n    \"\"\"\n    self.apply(asynchronous=asynchronous, verbose=verbose)\n    if isinstance(source, (SourceRegistrar, SubscriptableTransformation)):\n        name, variant = source.name_variant()\n    elif isinstance(source, str):\n        name = source\n        if variant is None:\n            raise ValueError(\"variant must be specified if source is a string\")\n        if variant == \"\":\n            raise ValueError(\"variant cannot be an empty string\")\n    else:\n        raise ValueError(\n            f\"source must be of type SourceRegistrar, SubscriptableTransformation or str, not {type(source)}\\n\"\n            \"use client.dataframe(name, variant) or client.dataframe(source) or client.dataframe(transformation)\"\n        )\n    return self.impl._get_source_as_df(name, variant, limit)\n</code></pre>"},{"location":"client/#featureform.client.Client.location","title":"<code>location(source, variant=None, resource_type=None)</code>","text":"<p>Returns the location of a registered resource. For SQL resources, it will return the table name and for file resources, it will return the file path.</p> <p>Example: definitions.py<pre><code>transaction_location = client.location(\"transactions\", \"quickstart\", ff.SOURCE)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[SourceRegistrar, SubscriptableTransformation, str]</code> <p>The source or transformation to compute the dataframe from</p> required <code>variant</code> <code>str</code> <p>The source variant; can't be None if source is a string</p> <code>None</code> <code>resource_type</code> <code>ResourceType</code> <p>The type of resource; can be one of ff.SOURCE, ff.FEATURE, ff.LABEL, or ff.TRAINING_SET</p> <code>None</code> Source code in <code>src/featureform/client.py</code> <pre><code>def location(\n    self,\n    source: Union[SourceRegistrar, SubscriptableTransformation, str],\n    variant: Optional[str] = None,\n    resource_type: Optional[ResourceType] = None,\n):\n    \"\"\"\n    Returns the location of a registered resource. For SQL resources, it will return the table name\n    and for file resources, it will return the file path.\n\n    **Example:**\n    ```py title=\"definitions.py\"\n    transaction_location = client.location(\"transactions\", \"quickstart\", ff.SOURCE)\n    ```\n\n    Args:\n        source (Union[SourceRegistrar, SubscriptableTransformation, str]): The source or transformation to compute the dataframe from\n        variant (str): The source variant; can't be None if source is a string\n        resource_type (ResourceType): The type of resource; can be one of ff.SOURCE, ff.FEATURE, ff.LABEL, or ff.TRAINING_SET\n    \"\"\"\n    if isinstance(source, (SourceRegistrar, SubscriptableTransformation)):\n        name, variant = source.name_variant()\n        resource_type = ResourceType.SOURCE\n    elif isinstance(source, featureform.resources.TrainingSetVariant):\n        name = source.name\n        variant = source.variant\n        resource_type = ResourceType.TRAINING_SET\n    elif isinstance(source, str):\n        name = source\n        if variant is None:\n            raise ValueError(\"variant must be specified if source is a string\")\n        if variant == \"\":\n            raise ValueError(\"variant cannot be an empty string\")\n\n        if resource_type is None:\n            raise ValueError(\n                \"resource_type must be specified if source is a string\"\n            )\n\n    else:\n        raise ValueError(\n            f\"source must be of type SourceRegistrar, SubscriptableTransformation or str, not {type(resource)}\\n\"\n            \"use client.dataframe(name, variant) or client.dataframe(source) or client.dataframe(transformation)\"\n        )\n\n    location = self.impl.location(name, variant, resource_type)\n    return location\n</code></pre>"},{"location":"client/#featureform.client.Client.nearest","title":"<code>nearest(feature, vector, k)</code>","text":"<p>Query the K nearest neighbors of a provider vector in the index of a registered feature variant</p> <p>Example:</p> definitions.py<pre><code># Get the 5 nearest neighbors of the vector [0.1, 0.2, 0.3] in the index of the feature \"my_feature\" with variant \"my_variant\"\nnearest_neighbors = client.nearest(\"my_feature\", \"my_variant\", [0.1, 0.2, 0.3], 5)\nprint(nearest_neighbors) # prints a list of entities (e.g. [\"entity1\", \"entity2\", \"entity3\", \"entity4\", \"entity5\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>Union[FeatureColumnResource, tuple(str, str)]</code> <p>Feature object or tuple of Feature name and variant</p> required <code>vector</code> <code>List[float]</code> <p>Query vector</p> required <code>k</code> <code>int</code> <p>Number of nearest neighbors to return</p> required Source code in <code>src/featureform/client.py</code> <pre><code>def nearest(self, feature, vector, k):\n    \"\"\"\n    Query the K nearest neighbors of a provider vector in the index of a registered feature variant\n\n    **Example:**\n\n    ```py title=\"definitions.py\"\n    # Get the 5 nearest neighbors of the vector [0.1, 0.2, 0.3] in the index of the feature \"my_feature\" with variant \"my_variant\"\n    nearest_neighbors = client.nearest(\"my_feature\", \"my_variant\", [0.1, 0.2, 0.3], 5)\n    print(nearest_neighbors) # prints a list of entities (e.g. [\"entity1\", \"entity2\", \"entity3\", \"entity4\", \"entity5\"])\n    ```\n\n    Args:\n        feature (Union[FeatureColumnResource, tuple(str, str)]): Feature object or tuple of Feature name and variant\n        vector (List[float]): Query vector\n        k (int): Number of nearest neighbors to return\n\n    \"\"\"\n    if isinstance(feature, tuple):\n        name, variant = feature\n    elif isinstance(feature, FeatureColumnResource):\n        name = feature.name\n        variant = feature.variant\n    else:\n        raise Exception(\n            f\"the feature '{feature}' of type '{type(feature)}' is not support.\"\n            \"Feature must be a tuple of (name, variant) or a FeatureColumnResource\"\n        )\n\n    if k &lt; 1:\n        raise ValueError(\"k must be a positive integer\")\n    return self.impl.nearest(name, variant, vector, k)\n</code></pre>"},{"location":"client_apply/","title":"Client","text":"<p>Apply all definitions, creating and retrieving all specified resources.</p> <pre><code>import featureform as ff\nclient = ff.Client()\n\nff.register_postgres(\n    host=\"localhost\",\n    port=5432,\n)\n\nclient.apply()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>asynchronous</code> <code>bool</code> <p>If True, apply will return immediately and not wait for resources to be created. If False, apply will wait for resources to be created and print out the status of each resource.</p> <code>False</code>"},{"location":"compatibility/","title":"Deployment Feature Compatibility","text":""},{"location":"compatibility/#providers","title":"Providers","text":"Docker Cluster BigQuery \u2713 \u2713 Postgres \u2713 \u2713 Redshift \u2713 \u2713 Snowflake \u2713 \u2713 Generic Spark \u2713 Databricks \u2713 \u2713 EMR \u2713 \u2713 Kubernetes Runner \u2713 Cassandra \u2713 \u2713 DynamoDB \u2713 \u2713 Firestore \u2713 \u2713 MongoDB \u2713 \u2713 Redis \u2713 \u2713 S3 \u2713 \u2713 Azure Blob \u2713 \u2713 GCS \u2713 \u2713 Pinecone \u2713 \u2713 Redis Vector \u2713 \u2713 Weaviate \u2713 \u2713 Qdrant \u2713 \u2713"},{"location":"compatibility/#features","title":"Features","text":""},{"location":"compatibility/#features_1","title":"Features","text":"Docker Cluster Scheduling \u2713 Search \u2713 \u2713 Autogenerated Variants \u2713 \u2713 Backup and Restore \u2713 Properties and Tags \u2713 \u2713 Optional Inference Streaming Not in OSS \u2713 On demand functions \u2713 \u2713 Training Sets to dataframes \u2713 \u2713 Source to dataframe \u2713 \u2713 Provider Config Mutability \u2713 \u2713 Model Registration \u2713 \u2713 Synchronous Apply Toggle \u2713 \u2713"},{"location":"compatibility/#deployment","title":"Deployment","text":"Docker Cluster Distributed Workers \u2713 Persistent Storage \u2713"},{"location":"deploy/","title":"Deploy","text":""},{"location":"deployment_overview/","title":"Deployment Overview","text":"<p>Featureform has multiple deployment options to suit different use cases. For more information and specific capabilities, see the following Deployment Comparison page.</p>"},{"location":"deployment_overview/#docker","title":"Docker","text":"<p>Docker is a flexible deployment option. It supports most features included in the Kubernetes deployment, but does not have built in scaling. It can be run locally or hosted in a cloud. It is designed as an evaluation tool and  for small scale deployments until a full Kubernetes deployment is required.</p>"},{"location":"deployment_overview/#kubernetes","title":"Kubernetes","text":"<p>Kubernetes is the most fully featured deployment option. It supports all features and is designed to scale and distribute workloads natively. It is suggested when a production deployment is required and Kubernetes can be supported. </p>"},{"location":"enums/","title":"Enums","text":""},{"location":"enums/#featureform.enums.ResourceStatus","title":"<code>ResourceStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>ResourceStatus is an enumeration representing the possible states that a resource may occupy within an application.</p> <p>Each status is represented as a string, which provides a human-readable representation for each of the stages in the lifecycle of a resource.</p> <p>Attributes:</p> Name Type Description <code>NO_STATUS</code> <code>str</code> <p>The state of a resource that cannot have another status.</p> <code>CREATED</code> <code>str</code> <p>The state after a resource has been successfully created.</p> <code>PENDING</code> <code>str</code> <p>The state indicating that the resource is in the process of being prepared, but is not yet ready.</p> <code>READY</code> <code>str</code> <p>The state indicating that the resource has been successfully prepared and is now ready for use.</p> <code>FAILED</code> <code>str</code> <p>The state indicating that an error occurred during the creation or preparation of the resource.</p> Source code in <code>src/featureform/enums.py</code> <pre><code>class ResourceStatus(str, Enum):\n    \"\"\"\n    ResourceStatus is an enumeration representing the possible states that a\n    resource may occupy within an application.\n\n    Each status is represented as a string, which provides a human-readable\n    representation for each of the stages in the lifecycle of a resource.\n\n    Attributes:\n        NO_STATUS (str): The state of a resource that cannot have another status.\n        CREATED (str): The state after a resource has been successfully created.\n        PENDING (str): The state indicating that the resource is in the process of being prepared, but is not yet ready.\n        READY (str): The state indicating that the resource has been successfully prepared and is now ready for use.\n        FAILED (str): The state indicating that an error occurred during the creation or preparation of the resource.\n    \"\"\"\n\n    NO_STATUS = \"NO_STATUS\"\n    CREATED = \"CREATED\"\n    PENDING = \"PENDING\"\n    READY = \"READY\"\n    FAILED = \"FAILED\"\n\n    @staticmethod\n    def from_proto(proto):\n        return proto.Status._enum_type.values[proto.status].name\n</code></pre>"},{"location":"enums/#featureform.enums.ScalarType","title":"<code>ScalarType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>ScalarType is an enum of all the scalar types supported by Featureform.</p> <p>Attributes:</p> Name Type Description <code>NIL</code> <p>An empty string representing no specified type.</p> <code>INT</code> <p>A string representing an integer type.</p> <code>INT32</code> <p>A string representing a 32-bit integer type.</p> <code>INT64</code> <p>A string representing a 64-bit integer type.</p> <code>FLOAT32</code> <p>A string representing a 32-bit float type.</p> <code>FLOAT64</code> <p>A string representing a 64-bit float type.</p> <code>STRING</code> <p>A string representing a string type.</p> <code>BOOL</code> <p>A string representing a boolean type.</p> <code>DATETIME</code> <p>A string representing a datetime type.</p> Source code in <code>src/featureform/enums.py</code> <pre><code>class ScalarType(Enum):\n    \"\"\"\n    ScalarType is an enum of all the scalar types supported by Featureform.\n\n    Attributes:\n        NIL: An empty string representing no specified type.\n        INT: A string representing an integer type.\n        INT32: A string representing a 32-bit integer type.\n        INT64: A string representing a 64-bit integer type.\n        FLOAT32: A string representing a 32-bit float type.\n        FLOAT64: A string representing a 64-bit float type.\n        STRING: A string representing a string type.\n        BOOL: A string representing a boolean type.\n        DATETIME: A string representing a datetime type.\n    \"\"\"\n\n    NIL = \"\"\n    INT = \"int\"\n    INT32 = \"int32\"\n    INT64 = \"int64\"\n    FLOAT32 = \"float32\"\n    FLOAT64 = \"float64\"\n    STRING = \"string\"\n    BOOL = \"bool\"\n    DATETIME = \"datetime\"\n\n    @classmethod\n    def has_value(cls, value):\n        try:\n            cls(value)\n            return True\n        except ValueError:\n            return False\n\n    @classmethod\n    def get_values(cls):\n        return [e.value for e in cls]\n\n    def to_proto(self):\n        proto_enum = self.to_proto_enum()\n        return pb.ValueType(scalar=proto_enum)\n\n    def to_proto_enum(self):\n        mapping = {\n            ScalarType.NIL: pb.ScalarType.NULL,\n            ScalarType.INT: pb.ScalarType.INT,\n            ScalarType.INT32: pb.ScalarType.INT32,\n            ScalarType.INT64: pb.ScalarType.INT64,\n            ScalarType.FLOAT32: pb.ScalarType.FLOAT32,\n            ScalarType.FLOAT64: pb.ScalarType.FLOAT64,\n            ScalarType.STRING: pb.ScalarType.STRING,\n            ScalarType.BOOL: pb.ScalarType.BOOL,\n            ScalarType.DATETIME: pb.ScalarType.DATETIME,\n        }\n        return mapping[self]\n\n    @classmethod\n    def from_proto(cls, proto_val):\n        mapping = {\n            pb.ScalarType.NULL: ScalarType.NIL,\n            pb.ScalarType.INT: ScalarType.INT,\n            pb.ScalarType.INT32: ScalarType.INT32,\n            pb.ScalarType.INT64: ScalarType.INT64,\n            pb.ScalarType.FLOAT32: ScalarType.FLOAT32,\n            pb.ScalarType.FLOAT64: ScalarType.FLOAT64,\n            pb.ScalarType.STRING: ScalarType.STRING,\n            pb.ScalarType.BOOL: ScalarType.BOOL,\n            pb.ScalarType.DATETIME: ScalarType.DATETIME,\n        }\n        return mapping[proto_val]\n</code></pre>"},{"location":"feature_flag/","title":"Feature flag","text":""},{"location":"feature_flag/#featureform.feature_flag.is_enabled","title":"<code>is_enabled(feature_name, default=False)</code>","text":"<p>Returns True if the feature is enabled, currently using an environment variable. Interprets the environment variable as a boolean if it's a valid representation, else defaults to the specified default.</p> Source code in <code>src/featureform/feature_flag.py</code> <pre><code>def is_enabled(feature_name, default=False):\n    \"\"\"\n    Returns True if the feature is enabled, currently using an environment variable.\n    Interprets the environment variable as a boolean if it's a valid representation, else defaults to the specified default.\n    \"\"\"\n    value = os.getenv(feature_name)\n    if value is not None:\n        return value.lower() == \"true\"\n    return default\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#registering-an-entity","title":"Registering an Entity","text":"<p>Class decorator for registering entities and their associated features and labels.</p> <p>Examples <pre><code>@ff.entity\nclass User:\n    avg_transactions = ff.Feature()\n    fraudulent = ff.Label()\n</code></pre></p> <p>Returns:</p> Name Type Description <code>entity</code> <code>class</code> <p>Decorated class</p>"},{"location":"features/#feature","title":"Feature","text":"<p>Feature registration object.</p> <p>Example <pre><code>@ff.entity\nclass Customer:\n# Register a column from a transformation as a feature\n    transaction_amount = ff.Feature(\n        fare_per_family_member[[\"CustomerID\", \"Amount\", \"Transaction Time\"]],\n        variant=\"quickstart\",\n        type=ff.Float64,\n        inference_store=redis,\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>transformation_args</code> <code>tuple</code> <p>A transformation or source function and the columns name in the format: [[, , ]]. required <code>variant</code> <code>str</code> <p>An optional variant name for the feature.</p> <code>''</code> <code>type</code> <code>Union[ScalarType, str]</code> <p>The type of the value in for the feature.</p> required <code>inference_store</code> <code>Union[str, OnlineProvider, FileStoreProvider]</code> <p>Where to store for online serving.</p> <code>''</code>"},{"location":"features/#multifeature","title":"MultiFeature","text":"<p>Registering multiple features from the same table. The name of each feature is the name of the column in the table.</p> <p>Example <pre><code># Register a file or table from an offline provider as a dataset\n\nclient = ff.Client()\ndf = client.dataframe(dataset)\n\n@ff.entity\nclass Customer:\n# Register multiple columns from a dataset as features\n    transaction_features = ff.MultiFeature(\n        dataset,\n        df,\n        variant=\"quickstart\",\n        inference_store=redis,\n        entity_column=\"CustomerID\",\n        timestamp_column=\"Timestamp\",\n        exclude_columns=[\"TransactionID\", \"IsFraud\"],\n        inference_store=redis,\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>SourceVariant</code> <p>The dataset to register features from</p> required <code>df</code> <code>DataFrame</code> <p>The client.dataframe to register features from</p> required <code>include_columns</code> <code>List[str]</code> <p>List of columns to be registered as features</p> <code>None</code> <code>exclude_columns</code> <code>List[str]</code> <p>List of columns to be excluded from registration</p> <code>None</code> <code>entity_column</code> <code>Union[Entity, str]</code> <p>The name of the column in the source to be used as the entity</p> required <code>variant</code> <code>str</code> <p>An optional variant name for the feature.</p> <code>''</code> <code>inference_store</code> <code>Union[str, OnlineProvider, FileStoreProvider]</code> <p>Where to store for online serving.</p> <code>''</code>"},{"location":"features/#label","title":"Label","text":"<p>Label registration object.</p> <p>Example <pre><code>@ff.entity\nclass Customer:\n# Register a column from a transformation as a label\n    transaction_amount = ff.Label(\n        fare_per_family_member[[\"CustomerID\", \"Amount\", \"Transaction Time\"]],\n        variant=\"quickstart\",\n        type=ff.Float64\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>transformation_args</code> <code>tuple</code> <p>A transformation or source function and the columns name in the format: [[, , ]] required <code>variant</code> <code>str</code> <p>An optional variant name for the label.</p> <code>''</code> <code>type</code> <code>Union[ScalarType, str]</code> <p>The type of the value in for the label.</p> required"},{"location":"features/#embedding","title":"Embedding","text":"<p>Embedding Feature registration object.</p> <p>Example <pre><code>@ff.entity\nclass Speaker:\n# Register a column from a transformation as a label\n    transaction_amount = ff.Embedding(\n        vectorize_comments[[\"PK\", \"Vector\"]],\n        dims=384,\n        vector_db=pinecone,\n        description=\"Embeddings created from speakers' comments in episodes\",\n        variant=\"v1\"\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>transformation_args</code> <code>tuple</code> <p>A transformation or source function and the columns name in the format: [[, ]] required <code>dims</code> <code>int</code> <p>Dimensionality of the embedding.</p> required <code>vector_db</code> <code>Union[str, OnlineProvider]</code> <p>The name of the vector database to store the embeddings in.</p> required <code>variant</code> <code>str</code> <p>An optional variant name for the feature.</p> <code>''</code> <code>description</code> <code>str</code> <p>An optional description for the feature.</p> <code>''</code>"},{"location":"grpc_client/","title":"Grpc client","text":""},{"location":"grpc_client/#featureform.grpc_client.FFGrpcErrorDetails","title":"<code>FFGrpcErrorDetails</code>  <code>dataclass</code>","text":"<p>FFGrpcErrorDetails is a dataclass that represents the details of an error returned by the Featureform gRPC server.</p> Source code in <code>src/featureform/grpc_client.py</code> <pre><code>@dataclass\nclass FFGrpcErrorDetails:\n    \"\"\"\n    FFGrpcErrorDetails is a dataclass that represents the details of an error returned by the Featureform gRPC server.\n    \"\"\"\n\n    code: int\n    message: str\n    reason: str\n    metadata: Dict[str, str] = field(default_factory=dict)\n\n    @staticmethod\n    def from_grpc_error(e: grpc.RpcError) -&gt; Optional[\"FFGrpcErrorDetails\"]:\n        \"\"\"\n        from_grpc_error is a static method that creates a FFGrpcErrorDetails object from a gRPC error.\n        \"\"\"\n        status_proto = _extract_error_details(e)\n\n        for detail in status_proto.details:\n            # should only be one detail\n            if detail.Is(error_details_pb2.ErrorInfo.DESCRIPTOR):\n                error_info = error_details_pb2.ErrorInfo()\n                detail.Unpack(error_info)\n\n                return FFGrpcErrorDetails(\n                    code=status_proto.code,\n                    message=status_proto.message,\n                    reason=error_info.reason,\n                    metadata=dict(error_info.metadata),\n                )\n            else:\n                logging.debug(\"Unknown error detail type: %s\", detail)\n                return None\n</code></pre>"},{"location":"grpc_client/#featureform.grpc_client.FFGrpcErrorDetails.from_grpc_error","title":"<code>from_grpc_error(e)</code>  <code>staticmethod</code>","text":"<p>from_grpc_error is a static method that creates a FFGrpcErrorDetails object from a gRPC error.</p> Source code in <code>src/featureform/grpc_client.py</code> <pre><code>@staticmethod\ndef from_grpc_error(e: grpc.RpcError) -&gt; Optional[\"FFGrpcErrorDetails\"]:\n    \"\"\"\n    from_grpc_error is a static method that creates a FFGrpcErrorDetails object from a gRPC error.\n    \"\"\"\n    status_proto = _extract_error_details(e)\n\n    for detail in status_proto.details:\n        # should only be one detail\n        if detail.Is(error_details_pb2.ErrorInfo.DESCRIPTOR):\n            error_info = error_details_pb2.ErrorInfo()\n            detail.Unpack(error_info)\n\n            return FFGrpcErrorDetails(\n                code=status_proto.code,\n                message=status_proto.message,\n                reason=error_info.reason,\n                metadata=dict(error_info.metadata),\n            )\n        else:\n            logging.debug(\"Unknown error detail type: %s\", detail)\n            return None\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.7+</li> </ul>"},{"location":"installation/#python-package-installation","title":"Python Package Installation","text":""},{"location":"installation/#open-source","title":"Open Source","text":"<pre><code>pip install featureform\n</code></pre>"},{"location":"installation/#enterprise","title":"Enterprise","text":"<pre><code>pip install featureform-enterprise\n</code></pre>"},{"location":"model_registration/","title":"Model Registration","text":"<p>Although Featureform does not deploy models, it does allow you to tag features with their respective models, as well as lookup what features are associated with a given model. </p> <p>Associating a model with a feature can be done through the serving API during serving time.</p> <pre><code>feature = client.features(\n    [(\"avg_user_transactions\", \"quickstart\")],\n    {\"user_id\": \"1234\"}, \n    model=\"user_fraud_random_forest\"\n)\n</code></pre> <p>Visit the dashboard to see what features are associated with a given model.</p>"},{"location":"on_demand_functions/","title":"Ondemand Feature","text":"<p>An Ondemand Feature is a function that can be stored and called at serving time to run arbitrary code. </p>"},{"location":"on_demand_functions/#defining-an-ondemand-feature","title":"Defining An Ondemand Feature","text":"<p>Ondemand features have three arguments that can be used to pass in parameters, entities, or a serving client to call other serving functions within itself.</p> <p>Arguments:</p> <ul> <li><code>client</code>: The same client that is used to retrieve the ondemand feature with <code>client.features()</code>.</li> <li><code>params</code>: A list of parameters that are passed in at serving time. This can be any datatype or structure. </li> <li><code>entities</code>: A list of entities that are passed in at serving time. This is optional.</li> </ul> <p>On Demand Feature decorator.</p> <p>Examples <pre><code>import featureform as ff\n\n@ff.ondemand_feature()\ndef avg_user_transactions(client, params, entities):\n    pass\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of on demand feature</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>decorator</code> <code>OnDemandFeature</code> <p>decorator</p>"},{"location":"on_demand_functions/#examples","title":"Examples","text":""},{"location":"on_demand_functions/#simple-aggregations","title":"Simple Aggregations","text":"<p>Ondemand features can be used to run simple aggregations on values that are passed in as params. In this example, we will simply be adding two numbers together.</p> <pre><code>@ff.ondemand_feature(variant=\"quickstart\")\ndef avg_user_transactions(client, params, entities):\n    return params[0] + params[1]\n\n\nfeatures = client.features([(\"avg_user_transactions\", \"quickstart\")], params=[1, 2])\nprint(features)\n# [3]\n</code></pre>"},{"location":"on_demand_functions/#aggregating-features","title":"Aggregating Features","text":"<p>Suppose we have a feature that is the sum of two other features. We can use an ondemand feature to aggregate these internally and return the result. </p> <pre><code>@ff.ondemand_feature(variant=\"quickstart\")\ndef lot_area(client, params, entities):\n    \"\"\"Returns the area of a property in square feet.\"\"\"\n    dim = client.features([(\"lot_width\", \"rev_1\"), (\"lot_length\", \"rev_1\")], entities)\n    return dim[0] * dim[1]\n\n# Returns the area of a property of property 1432.\nfeatures = client.features([(\"lot_area\", \"sqft\")], {\"property_id\": 1432})\nprint(features)\n# [6098]\n</code></pre>"},{"location":"on_demand_functions/#nested-ondemand-features","title":"Nested Ondemand Features","text":"<p>We can call Ondemand Features from within other Ondemand Features. Using the previous example, we can create an Ondemand feature that converts the area from square feet to square meters.</p> <pre><code>@ff.ondemand_feature(variant=\"quickstart\")\ndef lot_area(client, params, entities):\n    area = client.features([(\"lot_area\", \"sqft\")], entities)\n    return area[0]/10.764\n\n# Returns the area of a property of property 1432 in square meters.\nfeatures = client.features([(\"lot_area\", \"m2\")], {\"property_id\": 1432})\nprint(features)\n# [566.5227]\n</code></pre>"},{"location":"primary_sources/","title":"Primary Sources","text":""},{"location":"primary_sources/#tables","title":"Tables","text":"<p>Tables can be registered off of any SQL database. Supported databases are: BigQuery, Postgres, Redshift, ClickHouse and Snowflake.</p> <p>Register a SQL table as a primary data source.</p> <p>Example</p> <pre><code>postgres = client.get_provider(\"my_postgres\")\ntable =  postgres.register_table(\n    name=\"transactions\",\n    variant=\"july_2023\",\n    table=\"transactions_table\",\n):\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of table to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>table</code> <code>str</code> <p>Name of SQL table</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of table to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>source</p>"},{"location":"primary_sources/#files","title":"Files","text":"<p>Files can be registered from the Local, Spark, and Kubernetes providers. Supported file types are: CSV and Parquet.</p>"},{"location":"primary_sources/#spark","title":"Spark","text":"<p>Sparkmode can register single files.</p> <p>Register a Spark data source as a primary data source.</p> <p>Examples</p> <pre><code>spark = client.get_provider(\"my_spark\")\ntransactions = spark.register_file(\n    name=\"transactions\",\n    variant=\"quickstart\",\n    description=\"A dataset of fraudulent transactions\",\n    file_path=\"s3://featureform-spark/featureform/transactions.parquet\"\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of table to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>file_path</code> <code>str</code> <p>The URI of the file. Must be the full path</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of table to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>source</p>"},{"location":"primary_sources/#kubernetes-pandas-runner","title":"Kubernetes Pandas Runner","text":"<p>Register a Kubernetes Runner data source as a primary data source.</p> <p>Examples</p> <pre><code>k8s = client.get_provider(\"my_k8s\")\ntransactions = k8s.register_file(\n    name=\"transactions\",\n    variant=\"quickstart\",\n    description=\"A dataset of fraudulent transactions\",\n    file_path=\"s3://featureform-spark/featureform/transactions.parquet\"\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of table to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>path</code> <code>str</code> <p>The path to blob store file</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of table to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>source</p>"},{"location":"properties_and_tags/","title":"Properties and Tags","text":"<p>Every resource in FeatureForm has a set of properties and tags that can be used to filter and search for resources.</p> <p>To add a tag to a resource, simply add a <code>tags</code> field to the resource definition. This field should be a list of strings.</p> <p>To add a property to a resource, simply add a <code>properties</code> field to the resource definition.  This field should be a dictionary of strings to strings.</p>"},{"location":"properties_and_tags/#example","title":"Example","text":"<pre><code>transactions = postgres.register_table(\n    name=\"transactions\",\n    table=\"transactions_table\",\n    tags=[\"finance\"],\n    properties={\"department\": \"fraud_detection\"},\n)\n</code></pre>"},{"location":"properties_and_tags/#behavior","title":"Behavior","text":"<ul> <li>Tags and properties are case-sensitive.</li> <li>Reapplying with new tags will append the new tags and ignore duplicates.</li> <li>Reapplying with new properties will append the new properties and overwrite existing properties with the same key.</li> <li>Deletion can be done in the dashboard.</li> </ul>"},{"location":"provider_reuse/","title":"Reusing Providers","text":"<p>Featureform's API allows you to reuse already applied definitions. You can easily get pre-applied providers and resources to continue building off of.</p> <p>To reuse a provider, simply use the associated <code>get</code> method for that provider. </p>"},{"location":"provider_reuse/#example","title":"Example","text":"<pre><code>from featureform as ff\npostgres = ff.get_postgres(\"prod-instance\")\n\npostgres.register_table(\n    name=\"transactions\",\n    variant=\"2022\",\n    table=\"2022_transactions\",\n)\n</code></pre>"},{"location":"provider_reuse/#available-providers","title":"Available Providers","text":""},{"location":"provider_reuse/#bigquery","title":"BigQuery","text":"<p>Get a BigQuery provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>bigquery = ff.get_bigquery(\"bigquery-quickstart\")\ntransactions = bigquery.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in BigQuery\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of BigQuery provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>bigquery</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#k8s-runner","title":"K8s Runner","text":"<p>Get a k8s provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>k8s = ff.get_kubernetes(\"k8s-azure-quickstart\")\ntransactions = k8s.register_file(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    path=\"path/to/blob\",\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of k8s provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>k8s</code> <code>OfflineK8sProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#mongodb","title":"MongoDB","text":"<p>Get a MongoDB provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>mongodb = ff.get_mongodb(\"mongodb-quickstart\")\n\naverage_user_transaction.register_resources(\n    entity=user,\n    entity_column=\"user_id\",\n    inference_store=mongodb,\n    features=[\n        {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of MongoDB provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>mongodb</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#postgres","title":"Postgres","text":"<p>Get a Postgres provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>postgres = ff.get_postgres(\"postgres-quickstart\")\ntransactions = postgres.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in Postgres\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Postgres provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>postgres</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#clickhouse","title":"ClickHouse","text":"<p>Get a ClickHouse provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>clickhouse = ff.get_clickhouse(\"clickhouse-quickstart\")\ntransactions = clickhouse.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in ClickHouse\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of ClickHouse provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>clickhouse</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#redis","title":"Redis","text":"<p>Get a Redis provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>redis = ff.get_redis(\"redis-quickstart\")\n\naverage_user_transaction.register_resources(\n    entity=user,\n    entity_column=\"user_id\",\n    inference_store=redis,\n    features=[\n        {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Redis provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>redis</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#redshift","title":"Redshift","text":"<p>Get a Redshift provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>redshift = ff.get_redshift(\"redshift-quickstart\")\ntransactions = redshift.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in Postgres\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Redshift provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>redshift</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#s3","title":"S3","text":"<p>Get a S3 provider. The returned object can be used with other providers such as Spark and Databricks.</p> <p>Examples:</p> <pre><code>s3 = ff.get_s3(\"s3-quickstart\")\nspark = ff.register_spark(\n    name=f\"spark-emr-s3\",\n    description=\"A Spark deployment we created for the Featureform quickstart\",\n    team=\"featureform-team\",\n    executor=emr,\n    filestore=s3,\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of S3 to be retrieved</p> required <p>Returns:</p> Name Type Description <code>s3</code> <code>FileStore</code> <p>Provider</p>"},{"location":"provider_reuse/#snowflake","title":"Snowflake","text":"<p>Get a Snowflake provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>snowflake = ff.get_snowflake(\"snowflake-quickstart\")\ntransactions = snowflake.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in Postgres\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Snowflake provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"provider_reuse/#spark","title":"Spark","text":"<p>Get a Spark provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>spark = ff.get_spark(\"spark-quickstart\")\ntransactions = spark.register_file(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    file_path=\"s3://bucket/path/to/file/transactions.parquet\",  # This is the path to file\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Spark provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>spark</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"provider_updating/","title":"Provider Updating","text":"<p>Configurations for providers can be updated by reapplying the definition of the same name-variant with the new configuration.</p> <p>This is useful for handling credential changes or other non-destructive changes to a provider.</p> <p>Fields that can typically be updated are:</p> <ul> <li>Descriptions</li> <li>Tags</li> <li>Properties</li> <li>Credentials</li> <li>Scaling Configurations</li> </ul> <p>Fields that cannot be updated are:</p> <ul> <li>Names</li> <li>Locations</li> <li>This may include database names, container names, hosts, etc.</li> </ul> <p>For specifics about individual providers, see the Description field in the provider documentation.</p>"},{"location":"providers/","title":"Providers","text":""},{"location":"providers/#credentials","title":"Credentials","text":"<p>Credentials are objects that can be reused in the same definitions file when registering providers in the same cloud.</p>"},{"location":"providers/#cloud-providers","title":"Cloud Providers","text":""},{"location":"providers/#aws","title":"AWS","text":"<p>Credentials for an AWS.</p> <p>Example <pre><code>aws_credentials = ff.AWSCredentials(\n    access_key=\"&lt;AWS_ACCESS_KEY&gt;\",\n    secret_key=\"&lt;AWS_SECRET_KEY&gt;\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>access_key</code> <code>str</code> <p>AWS Access Key.</p> required <code>secret_key</code> <code>str</code> <p>AWS Secret Key.</p> required"},{"location":"providers/#google-cloud","title":"Google Cloud","text":"<p>Credentials for an GCP.</p> <p>Example <pre><code>gcp_credentials = ff.GCPCredentials(\n    project_id=\"&lt;project_id&gt;\",\n    credentials_path=\"&lt;path_to_credentials&gt;\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The project id.</p> required <code>credentials_path</code> <code>str</code> <p>The path to the credentials file.</p> required"},{"location":"providers/#spark","title":"Spark","text":""},{"location":"providers/#generic","title":"Generic","text":"<p>Credentials for a Generic Spark Cluster</p> <p>Example <pre><code>spark_credentials = ff.SparkCredentials(\n    master=\"yarn\",\n    deploy_mode=\"cluster\",\n    python_version=\"3.7.12\",\n    core_site_path=\"core-site.xml\",\n    yarn_site_path=\"yarn-site.xml\"\n)\n\nspark = ff.register_spark(\n    name=\"spark\",\n    executor=spark_credentials,\n    ...\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>master</code> <code>str</code> <p>The hostname of the Spark cluster. (The same that would be passed to <code>spark-submit</code>).</p> required <code>deploy_mode</code> <code>str</code> <p>The deploy mode of the Spark cluster. (The same that would be passed to <code>spark-submit</code>).</p> required <code>python_version</code> <code>str</code> <p>The Python version running on the cluster. Supports 3.7-3.11</p> required <code>core_site_path</code> <code>str</code> <p>The path to the core-site.xml file. (For Yarn clusters only)</p> <code>''</code> <code>yarn_site_path</code> <code>str</code> <p>The path to the yarn-site.xml file. (For Yarn clusters only)</p> <code>''</code>"},{"location":"providers/#databricks","title":"Databricks","text":"<p>Credentials for a Databricks cluster.</p> <p>Example <pre><code>databricks = ff.DatabricksCredentials(\n    username=\"&lt;my_username&gt;\",\n    password=\"&lt;my_password&gt;\",\n    host=\"&lt;databricks_hostname&gt;\",\n    token=\"&lt;databricks_token&gt;\",\n    cluster_id=\"&lt;databricks_cluster&gt;\",\n)\n\nspark = ff.register_spark(\n    name=\"spark\",\n    executor=databricks,\n    ...\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username for a Databricks cluster.</p> required <code>password</code> <code>str</code> <p>Password for a Databricks cluster.</p> required <code>host</code> <code>str</code> <p>The hostname of a Databricks cluster.</p> required <code>token</code> <code>str</code> <p>The token for a Databricks cluster.</p> required <code>cluster_id</code> <code>str</code> <p>ID of an existing Databricks cluster.</p> required"},{"location":"providers/#emr","title":"EMR","text":"<p>Credentials for an EMR cluster.</p> <p>Example <pre><code>emr = ff.EMRCredentials(\n    emr_cluster_id=\"&lt;cluster_id&gt;\",\n    emr_cluster_region=\"&lt;cluster_region&gt;\",\n    credentials=\"&lt;AWS_Credentials&gt;\",\n)\n\nspark = ff.register_spark(\n    name=\"spark\",\n    executor=emr,\n    ...\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>emr_cluster_id</code> <code>str</code> <p>ID of an existing EMR cluster.</p> required <code>emr_cluster_region</code> <code>str</code> <p>Region of an existing EMR cluster.</p> required <code>credentials</code> <code>AWSCredentials</code> <p>Credentials for an AWS account with access to the cluster</p> required"},{"location":"providers/#provider-registration","title":"Provider Registration","text":"<p>This page provides reference and examples for how to register the various providers that Featureform supports.</p>"},{"location":"providers/#azure-blob-store","title":"Azure Blob Store","text":"<p>Register an Azure Blob Store provider.</p> <p>Azure Blob Storage can be used as the storage component for Spark or the Featureform Pandas Runner.</p> <p>Examples: <pre><code>blob = ff.register_blob_store(\n    name=\"azure-quickstart\",\n    container_name=\"my_company_container\"\n    root_path=\"custom/path/in/container\"\n    account_name=&lt;azure_account_name&gt;\n    account_key=&lt;azure_account_key&gt;\n    description=\"An azure blob store provider to store offline and inference data\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Azure blob store to be registered</p> required <code>container_name</code> <code>str</code> <p>(Immutable) Azure container name</p> required <code>root_path</code> <code>str</code> <p>(Immutable) A custom path in container to store data</p> required <code>account_name</code> <code>str</code> <p>(Immutable) Azure account name</p> required <code>account_key</code> <code>str</code> <p>(Mutable) Secret azure account key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Azure Blob provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <p>Returns:</p> Name Type Description <code>blob</code> <code>StorageProvider</code> <p>Provider has all the functionality of OnlineProvider</p>"},{"location":"providers/#bigquery","title":"BigQuery","text":"<p>Register a BigQuery provider.</p> <p>Examples: <pre><code>bigquery = ff.register_bigquery(\n    name=\"bigquery-quickstart\",\n    description=\"A BigQuery deployment we created for the Featureform quickstart\",\n    project_id=\"quickstart-project\",\n    dataset_id=\"quickstart-dataset\",\n    credentials=GCPCredentials(...)\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of BigQuery provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) The Project name in GCP</p> required <code>dataset_id</code> <code>str</code> <p>(Immutable) The Dataset name in GCP under the Project Id</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access BigQuery</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of BigQuery provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bigquery</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"providers/#cassandra","title":"Cassandra","text":"<p>Register a Cassandra provider.</p> <p>Examples: <pre><code>cassandra = ff.register_cassandra(\n        name = \"cassandra\",\n        description = \"Example inference store\",\n        team = \"Featureform\",\n        host = \"0.0.0.0\",\n        port = 9042,\n        username = \"cassandra\",\n        password = \"cassandra\",\n        consistency = \"THREE\",\n        replication = 3\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Cassandra provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) DNS name of Cassandra</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> required <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>consistency</code> <code>str</code> <p>(Mutable) Consistency</p> <code>'THREE'</code> <code>replication</code> <code>int</code> <p>(Mutable) Replication</p> <code>3</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Cassandra provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>cassandra</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"providers/#dynamodb","title":"DynamoDB","text":"<p>Register a DynamoDB provider.</p> <p>Examples: <pre><code>dynamodb = ff.register_dynamodb(\n    name=\"dynamodb-quickstart\",\n    description=\"A Dynamodb deployment we created for the Featureform quickstart\",\n    credentials=aws_creds,\n    region=\"us-east-1\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of DynamoDB provider to be registered</p> required <code>region</code> <code>str</code> <p>(Immutable) Region to create dynamo tables</p> required <code>credentials</code> <code>AWSCredentials</code> <p>(Mutable) AWS credentials with permissions to create DynamoDB tables</p> required <code>should_import_from_s3</code> <code>bool</code> <p>(Mutable) Determines whether feature materialization will occur via a direct import of data from S3 to new table (see docs for details)</p> <code>False</code> <code>description</code> <code>str</code> <p>(Mutable) Description of DynamoDB provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dynamodb</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"providers/#firestore","title":"Firestore","text":"<p>Register a Firestore provider.</p> <p>Examples: <pre><code>firestore = ff.register_firestore(\n    name=\"firestore-quickstart\",\n    description=\"A Firestore deployment we created for the Featureform quickstart\",\n    project_id=\"quickstart-project\",\n    collection=\"quickstart-collection\",\n    credentials=ff.GCPCredentials(...)\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Firestore provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) The Project name in GCP</p> required <code>collection</code> <code>str</code> <p>(Immutable) The Collection name in Firestore under the given project ID</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access Firestore</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Firestore provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>firestore</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"providers/#google-cloud-storage","title":"Google Cloud Storage","text":"<p>Register a GCS store provider.</p> <p>Examples: <pre><code>gcs = ff.register_gcs(\n    name=\"gcs-quickstart\",\n    credentials=ff.GCPCredentials(...),\n    bucket_name=\"bucket_name\",\n    root_path=\"featureform/path/\",\n    description=\"An gcs store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of GCS store to be registered</p> required <code>bucket_name</code> <code>str</code> <p>(Immutable) The bucket name</p> required <code>root_path</code> <code>str</code> <p>(Immutable) Custom path to be used by featureform</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access the bucket</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of GCS provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>gcs</code> <code>FileStoreProvider</code> <p>Provider has all the functionality of OfflineProvider</p>"},{"location":"providers/#hdfs","title":"HDFS","text":"<p>Register a HDFS store provider.</p> <p>This has the functionality of an offline store and can be used as a parameter to a k8s or spark provider</p> <p>Examples: <pre><code>hdfs = ff.register_hdfs(\n    name=\"hdfs-quickstart\",\n    host=\"&lt;host&gt;\",\n    port=\"&lt;port&gt;\",\n    path=\"&lt;path&gt;\",\n    username=\"&lt;username&gt;\",\n    description=\"An hdfs store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of HDFS store to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) The hostname for HDFS</p> required <code>path</code> <code>str</code> <p>(Immutable) A storage path within HDFS</p> <code>''</code> <code>port</code> <code>str</code> <p>(Mutable) The IPC port for the Namenode for HDFS. (Typically 8020 or 9000)</p> required <code>username</code> <code>str</code> <p>(Mutable) A Username for HDFS</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of HDFS provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering HDFS</p> <code>''</code> <p>Returns:</p> Name Type Description <code>hdfs</code> <code>FileStoreProvider</code> <p>Provider</p>"},{"location":"providers/#kubernetes-pandas-runner","title":"Kubernetes Pandas Runner","text":"<p>Register an offline store provider to run on Featureform's own k8s deployment. Examples: <pre><code>spark = ff.register_k8s(\n    name=\"k8s\",\n    store=AzureBlobStore(),\n    docker_image=\"my-repo/image:version\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of provider</p> required <code>store</code> <code>FileStoreProvider</code> <p>(Mutable) Reference to registered file store provider</p> required <code>docker_image</code> <code>str</code> <p>(Mutable) A custom docker image using the base image featureformcom/k8s_runner</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of primary data to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) A string parameter describing the team that owns the provider</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code>"},{"location":"providers/#mongodb","title":"MongoDB","text":"<p>Register a MongoDB provider.</p> <p>Examples: <pre><code>mongodb = ff.register_mongodb(\n    name=\"mongodb-quickstart\",\n    description=\"A MongoDB deployment\",\n    username=\"my_username\",\n    password=\"myPassword\",\n    database=\"featureform_database\"\n    host=\"my-mongodb.host.com\",\n    port=\"10225\",\n    throughput=10000\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of MongoDB provider to be registered</p> required <code>database</code> <code>str</code> <p>(Immutable) MongoDB database</p> required <code>host</code> <code>str</code> <p>(Immutable) MongoDB hostname</p> required <code>port</code> <code>str</code> <p>(Immutable) MongoDB port</p> required <code>username</code> <code>str</code> <p>(Mutable) MongoDB username</p> required <code>password</code> <code>str</code> <p>(Mutable) MongoDB password</p> required <code>throughput</code> <code>int</code> <p>(Mutable) The maximum RU limit for autoscaling in CosmosDB</p> <code>1000</code> <code>description</code> <code>str</code> <p>(Mutable) Description of MongoDB provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>mongodb</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"providers/#pinecone","title":"Pinecone","text":"<p>Register a Pinecone provider.</p> <p>Examples: <pre><code>pinecone = ff.register_pinecone(\n    name=\"pinecone-quickstart\",\n    project_id=\"2g13ek7\",\n    environment=\"us-west4-gcp-free\",\n    api_key=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Pinecone provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) Pinecone project id</p> required <code>environment</code> <code>str</code> <p>(Immutable) Pinecone environment</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Pinecone api key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Pinecone provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>pinecone</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"providers/#postgres","title":"Postgres","text":"<p>Register a Postgres provider.</p> <p>Examples: <pre><code>postgres = ff.register_postgres(\n    name=\"postgres-quickstart\",\n    description=\"A Postgres deployment we created for the Featureform quickstart\",\n    host=\"quickstart-postgres\",  # The internal dns name for postgres\n    port=\"5432\",\n    user=\"postgres\",\n    password=\"password\", #pragma: allowlist secret\n    database=\"postgres\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Postgres provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Postgres</p> required <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> <code>'5432'</code> <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>sslmode</code> <code>str</code> <p>(Mutable) SSL mode</p> <code>'disable'</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Postgres provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>postgres</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"providers/#qdrant","title":"Qdrant","text":"<p>Register a Qdrant provider.</p> <p>Examples: <pre><code>qdrant = ff.register_qdrant(\n    name=\"qdrant-quickstart\",\n    grpc_host=\"xyz-example.eu-central.aws.cloud.qdrant.io:6334\",\n    api_key=\"&lt;API KEY&gt;\",\n    use_tls=True,\n    description=\"A Qdrant project for using embeddings in Featureform\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Qdrant provider to be registered</p> required <code>url</code> <code>str</code> <p>(Immutable) gRPC host of the Qdrant cluster, either in the cloud or via local deployment.</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Qdrant API key.</p> <code>''</code> <code>use_tls</code> <code>bool</code> <p>(Immutable) Whether to use TLS for the connection.</p> <code>False</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Qdrant provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>qdrant</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"providers/#clickhouse","title":"ClickHouse","text":"<p>Register a ClickHouse provider.</p> <p>Examples: <pre><code>clickhouse = ff.register_clickhouse(\n    name=\"clickhouse-quickstart\",\n    description=\"A ClickHouse deployment we created for the Featureform quickstart\",\n    host=\"quickstart-clickhouse\",  # The internal dns name for clickhouse\n    port=9000,\n    user=\"default\",\n    password=\"\", #pragma: allowlist secret\n    database=\"default\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of ClickHouse provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for ClickHouse</p> required <code>database</code> <code>str</code> <p>(Immutable) ClickHouse database</p> required <code>port</code> <code>int</code> <p>(Mutable) Port</p> <code>9000</code> <code>ssl</code> <code>bool</code> <p>(Mutable) Enable SSL</p> <code>False</code> <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) ClickHouse password</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of ClickHouse provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>clickhouse</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"providers/#redis","title":"Redis","text":"<p>Register a Redis provider.</p> <p>Examples: <pre><code>redis = ff.register_redis(\n    name=\"redis-quickstart\",\n    host=\"quickstart-redis\",\n    port=6379,\n    password=\"password\",\n    description=\"A Redis deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Redis provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Redis</p> required <code>db</code> <code>str</code> <p>(Immutable) Redis database number</p> <code>0</code> <code>port</code> <code>int</code> <p>(Mutable) Redis port</p> <code>6379</code> <code>password</code> <code>str</code> <p>(Mutable) Redis password</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Redis provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>Optional[List[str]]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <code>properties</code> <code>Optional[dict]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <p>Returns:</p> Name Type Description <code>redis</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"providers/#redshift","title":"Redshift","text":"<p>Register a Redshift provider.</p> <p>Examples: <pre><code>redshift = ff.register_redshift(\n    name=\"redshift-quickstart\",\n    description=\"A Redshift deployment we created for the Featureform quickstart\",\n    host=\"quickstart-redshift\",  # The internal dns name for redshift\n    port=\"5432\",\n    user=\"redshift\",\n    password=\"password\", #pragma: allowlist secret\n    database=\"dev\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Redshift provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Redshift</p> required <code>database</code> <code>str</code> <p>(Immutable) Redshift database</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> required <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) Redshift password</p> required <code>sslmode</code> <code>str</code> <p>(Mutable) SSL mode</p> <code>'disable'</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Redshift provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>redshift</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"providers/#s3","title":"S3","text":"<p>Register a S3 store provider.</p> <p>This has the functionality of an offline store and can be used as a parameter to a k8s or spark provider</p> <p>Examples: <pre><code>s3 = ff.register_s3(\n    name=\"s3-quickstart\",\n    credentials=aws_creds,\n    bucket_name=\"bucket_name\",\n    bucket_region=&lt;bucket_region&gt;,\n    path=\"path/to/store/featureform_files/in/\",\n    description=\"An s3 store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of S3 store to be registered</p> required <code>bucket_name</code> <code>str</code> <p>(Immutable) AWS Bucket Name</p> required <code>bucket_region</code> <code>str</code> <p>(Immutable) AWS region the bucket is located in</p> required <code>path</code> <code>str</code> <p>(Immutable) The path used to store featureform files in</p> <code>''</code> <code>credentials</code> <code>AWSCredentials</code> <p>(Mutable) AWS credentials to access the bucket</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of S3 provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>s3</code> <code>FileStoreProvider</code> <p>Provider has all the functionality of OfflineProvider</p>"},{"location":"providers/#snowflake","title":"Snowflake","text":""},{"location":"providers/#current","title":"Current","text":"<p>Register a Snowflake provider.</p> <p>Examples: <pre><code>snowflake = ff.register_snowflake(\n    name=\"snowflake-quickstart\",\n    username=\"snowflake\",\n    password=\"password\", #pragma: allowlist secret\n    account=\"account\",\n    organization=\"organization\",\n    database=\"snowflake\",\n    schema=\"PUBLIC\",\n    description=\"A Snowflake deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Snowflake provider to be registered</p> required <code>account</code> <code>str</code> <p>(Immutable) Account</p> required <code>organization</code> <code>str</code> <p>(Immutable) Organization</p> required <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>schema</code> <code>str</code> <p>(Immutable) Schema</p> <code>'PUBLIC'</code> <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>warehouse</code> <code>str</code> <p>(Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.</p> <code>''</code> <code>role</code> <code>str</code> <p>(Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Snowflake provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"providers/#legacy","title":"Legacy","text":"<p>Register a Snowflake provider using legacy credentials.</p> <p>Examples: <pre><code>snowflake = ff.register_snowflake_legacy(\n    name=\"snowflake-quickstart\",\n    username=\"snowflake\",\n    password=\"password\",\n    account_locator=\"account-locator\",\n    database=\"snowflake\",\n    schema=\"PUBLIC\",\n    description=\"A Snowflake deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Snowflake provider to be registered</p> required <code>account_locator</code> <code>str</code> <p>(Immutable) Account Locator</p> required <code>schema</code> <code>str</code> <p>(Immutable) Schema</p> <code>'PUBLIC'</code> <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>warehouse</code> <code>str</code> <p>(Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.</p> <code>''</code> <code>role</code> <code>str</code> <p>(Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Snowflake provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p>"},{"location":"providers/#spark_1","title":"Spark","text":"<p>Register a Spark on Executor provider.</p> <p>Examples: <pre><code>spark = ff.register_spark(\n    name=\"spark-quickstart\",\n    description=\"A Spark deployment we created for the Featureform quickstart\",\n    team=\"featureform-team\",\n    executor=databricks,\n    filestore=azure_blob_store\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Spark provider to be registered</p> required <code>executor</code> <code>ExecutorCredentials</code> <p>(Mutable) An Executor Provider used for the compute power</p> required <code>filestore</code> <code>FileStoreProvider</code> <p>(Mutable) A FileStoreProvider used for storage of data</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Spark provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>spark</code> <code>OfflineSparkProvider</code> <p>Provider</p>"},{"location":"providers/#weaviate","title":"Weaviate","text":"<p>Register a Weaviate provider.</p> <p>Examples: <pre><code>weaviate = ff.register_weaviate(\n    name=\"weaviate-quickstart\",\n    url=\"https://&lt;CLUSTER NAME&gt;.weaviate.network\",\n    api_key=\"&lt;API KEY&gt;\"\n    description=\"A Weaviate project for using embeddings in Featureform\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Weaviate provider to be registered</p> required <code>url</code> <code>str</code> <p>(Immutable) Endpoint of Weaviate cluster, either in the cloud or via another deployment operation</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Weaviate api key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Weaviate provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>weaviate</code> <code>OnlineProvider</code> <p>Provider</p>"},{"location":"python_package/","title":"Installation","text":""},{"location":"python_package/#requirements","title":"Requirements","text":"<ul> <li>Python 3.7+</li> </ul>"},{"location":"python_package/#python-package-installation","title":"Python Package Installation","text":""},{"location":"python_package/#open-source","title":"Open Source","text":"<pre><code>pip install featureform\n</code></pre>"},{"location":"python_package/#enterprise","title":"Enterprise","text":"<pre><code>pip install featureform-enterprise\n</code></pre>"},{"location":"register/","title":"Registration","text":""},{"location":"register/#providers","title":"Providers","text":""},{"location":"register/#azure-blob-store","title":"Azure Blob Store","text":"<p>Register an Azure Blob Store provider.</p> <p>Azure Blob Storage can be used as the storage component for Spark or the Featureform Pandas Runner.</p> <p>Examples: <pre><code>blob = ff.register_blob_store(\n    name=\"azure-quickstart\",\n    container_name=\"my_company_container\"\n    root_path=\"custom/path/in/container\"\n    account_name=&lt;azure_account_name&gt;\n    account_key=&lt;azure_account_key&gt;\n    description=\"An azure blob store provider to store offline and inference data\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Azure blob store to be registered</p> required <code>container_name</code> <code>str</code> <p>(Immutable) Azure container name</p> required <code>root_path</code> <code>str</code> <p>(Immutable) A custom path in container to store data</p> required <code>account_name</code> <code>str</code> <p>(Immutable) Azure account name</p> required <code>account_key</code> <code>str</code> <p>(Mutable) Secret azure account key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Azure Blob provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <p>Returns:</p> Name Type Description <code>blob</code> <code>StorageProvider</code> <p>Provider has all the functionality of OnlineProvider</p>"},{"location":"register/#bigquery","title":"BigQuery","text":"<p>Register a BigQuery provider.</p> <p>Examples: <pre><code>bigquery = ff.register_bigquery(\n    name=\"bigquery-quickstart\",\n    description=\"A BigQuery deployment we created for the Featureform quickstart\",\n    project_id=\"quickstart-project\",\n    dataset_id=\"quickstart-dataset\",\n    credentials=GCPCredentials(...)\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of BigQuery provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) The Project name in GCP</p> required <code>dataset_id</code> <code>str</code> <p>(Immutable) The Dataset name in GCP under the Project Id</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access BigQuery</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of BigQuery provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bigquery</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_bigquery(\n    self,\n    name: str,\n    project_id: str,\n    dataset_id: str,\n    credentials: GCPCredentials,\n    credentials_path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a BigQuery provider.\n\n    **Examples**:\n    ```\n    bigquery = ff.register_bigquery(\n        name=\"bigquery-quickstart\",\n        description=\"A BigQuery deployment we created for the Featureform quickstart\",\n        project_id=\"quickstart-project\",\n        dataset_id=\"quickstart-dataset\",\n        credentials=GCPCredentials(...)\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of BigQuery provider to be registered\n        project_id (str): (Immutable) The Project name in GCP\n        dataset_id (str): (Immutable) The Dataset name in GCP under the Project Id\n        credentials (GCPCredentials): (Mutable) GCP credentials to access BigQuery\n        description (str): (Mutable) Description of BigQuery provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        bigquery (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n\n    config = BigQueryConfig(\n        project_id=project_id,\n        dataset_id=dataset_id,\n        credentials=credentials,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#cassandra","title":"Cassandra","text":"<p>Register a Cassandra provider.</p> <p>Examples: <pre><code>cassandra = ff.register_cassandra(\n        name = \"cassandra\",\n        description = \"Example inference store\",\n        team = \"Featureform\",\n        host = \"0.0.0.0\",\n        port = 9042,\n        username = \"cassandra\",\n        password = \"cassandra\",\n        consistency = \"THREE\",\n        replication = 3\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Cassandra provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) DNS name of Cassandra</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> required <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>consistency</code> <code>str</code> <p>(Mutable) Consistency</p> <code>'THREE'</code> <code>replication</code> <code>int</code> <p>(Mutable) Replication</p> <code>3</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Cassandra provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>cassandra</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_cassandra(\n    self,\n    name: str,\n    host: str,\n    port: int,\n    username: str,\n    password: str,\n    keyspace: str,\n    consistency: str = \"THREE\",\n    replication: int = 3,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Cassandra provider.\n\n    **Examples**:\n    ```\n    cassandra = ff.register_cassandra(\n            name = \"cassandra\",\n            description = \"Example inference store\",\n            team = \"Featureform\",\n            host = \"0.0.0.0\",\n            port = 9042,\n            username = \"cassandra\",\n            password = \"cassandra\",\n            consistency = \"THREE\",\n            replication = 3\n        )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Cassandra provider to be registered\n        host (str): (Immutable) DNS name of Cassandra\n        port (str): (Mutable) Port\n        username (str): (Mutable) Username\n        password (str): (Mutable) Password\n        consistency (str): (Mutable) Consistency\n        replication (int): (Mutable) Replication\n        description (str): (Mutable) Description of Cassandra provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        cassandra (OnlineProvider): Provider\n    \"\"\"\n    config = CassandraConfig(\n        host=host,\n        port=port,\n        username=username,\n        password=password,\n        keyspace=keyspace,\n        consistency=consistency,\n        replication=replication,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#dynamodb","title":"DynamoDB","text":"<p>Register a DynamoDB provider.</p> <p>Examples: <pre><code>dynamodb = ff.register_dynamodb(\n    name=\"dynamodb-quickstart\",\n    description=\"A Dynamodb deployment we created for the Featureform quickstart\",\n    credentials=aws_creds,\n    region=\"us-east-1\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of DynamoDB provider to be registered</p> required <code>region</code> <code>str</code> <p>(Immutable) Region to create dynamo tables</p> required <code>credentials</code> <code>AWSCredentials</code> <p>(Mutable) AWS credentials with permissions to create DynamoDB tables</p> required <code>should_import_from_s3</code> <code>bool</code> <p>(Mutable) Determines whether feature materialization will occur via a direct import of data from S3 to new table (see docs for details)</p> <code>False</code> <code>description</code> <code>str</code> <p>(Mutable) Description of DynamoDB provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dynamodb</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_dynamodb(\n    self,\n    name: str,\n    credentials: AWSCredentials,\n    region: str,\n    should_import_from_s3: bool = False,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a DynamoDB provider.\n\n    **Examples**:\n    ```\n    dynamodb = ff.register_dynamodb(\n        name=\"dynamodb-quickstart\",\n        description=\"A Dynamodb deployment we created for the Featureform quickstart\",\n        credentials=aws_creds,\n        region=\"us-east-1\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of DynamoDB provider to be registered\n        region (str): (Immutable) Region to create dynamo tables\n        credentials (AWSCredentials): (Mutable) AWS credentials with permissions to create DynamoDB tables\n        should_import_from_s3 (bool): (Mutable) Determines whether feature materialization will occur via a direct import of data from S3 to new table (see [docs](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/S3DataImport.HowItWorks.html) for details)\n        description (str): (Mutable) Description of DynamoDB provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        dynamodb (OnlineProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = DynamodbConfig(\n        access_key=credentials.access_key,\n        secret_key=credentials.secret_key,\n        region=region,\n        should_import_from_s3=should_import_from_s3,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#firestore","title":"Firestore","text":"<p>Register a Firestore provider.</p> <p>Examples: <pre><code>firestore = ff.register_firestore(\n    name=\"firestore-quickstart\",\n    description=\"A Firestore deployment we created for the Featureform quickstart\",\n    project_id=\"quickstart-project\",\n    collection=\"quickstart-collection\",\n    credentials=ff.GCPCredentials(...)\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Firestore provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) The Project name in GCP</p> required <code>collection</code> <code>str</code> <p>(Immutable) The Collection name in Firestore under the given project ID</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access Firestore</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Firestore provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>firestore</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_firestore(\n    self,\n    name: str,\n    collection: str,\n    project_id: str,\n    credentials: GCPCredentials,\n    credentials_path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Firestore provider.\n\n    **Examples**:\n    ```\n    firestore = ff.register_firestore(\n        name=\"firestore-quickstart\",\n        description=\"A Firestore deployment we created for the Featureform quickstart\",\n        project_id=\"quickstart-project\",\n        collection=\"quickstart-collection\",\n        credentials=ff.GCPCredentials(...)\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Firestore provider to be registered\n        project_id (str): (Immutable) The Project name in GCP\n        collection (str): (Immutable) The Collection name in Firestore under the given project ID\n        credentials (GCPCredentials): (Mutable) GCP credentials to access Firestore\n        description (str): (Mutable) Description of Firestore provider to be registered\n        team (str): (Mutable) The name of the team registering the filestore\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        firestore (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = FirestoreConfig(\n        collection=collection,\n        project_id=project_id,\n        credentials=credentials,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#google-cloud-storage","title":"Google Cloud Storage","text":"<p>Register a GCS store provider.</p> <p>Examples: <pre><code>gcs = ff.register_gcs(\n    name=\"gcs-quickstart\",\n    credentials=ff.GCPCredentials(...),\n    bucket_name=\"bucket_name\",\n    root_path=\"featureform/path/\",\n    description=\"An gcs store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of GCS store to be registered</p> required <code>bucket_name</code> <code>str</code> <p>(Immutable) The bucket name</p> required <code>root_path</code> <code>str</code> <p>(Immutable) Custom path to be used by featureform</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access the bucket</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of GCS provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>gcs</code> <code>FileStoreProvider</code> <p>Provider has all the functionality of OfflineProvider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_gcs(\n    self,\n    name: str,\n    bucket_name: str,\n    root_path: str,\n    credentials: GCPCredentials,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a GCS store provider.\n\n    **Examples**:\n    ```\n    gcs = ff.register_gcs(\n        name=\"gcs-quickstart\",\n        credentials=ff.GCPCredentials(...),\n        bucket_name=\"bucket_name\",\n        root_path=\"featureform/path/\",\n        description=\"An gcs store provider to store offline\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of GCS store to be registered\n        bucket_name (str): (Immutable) The bucket name\n        root_path (str): (Immutable) Custom path to be used by featureform\n        credentials (GCPCredentials): (Mutable) GCP credentials to access the bucket\n        description (str): (Mutable) Description of GCS provider to be registered\n        team (str): (Mutable) The name of the team registering the filestore\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        gcs (FileStoreProvider): Provider\n            has all the functionality of OfflineProvider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n\n    if bucket_name == \"\":\n        raise ValueError(\"bucket_name is required and cannot be empty string\")\n\n    bucket_name = bucket_name.replace(\"gs://\", \"\")\n    if \"/\" in bucket_name:\n        raise ValueError(\n            \"bucket_name cannot contain '/'. bucket_name should be the name of the GCS bucket only.\"\n        )\n\n    gcs_config = GCSFileStoreConfig(\n        bucket_name=bucket_name, bucket_path=root_path, credentials=credentials\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=gcs_config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return FileStoreProvider(self, provider, gcs_config, gcs_config.type())\n</code></pre>"},{"location":"register/#hdfs","title":"HDFS","text":"<p>Register a HDFS store provider.</p> <p>This has the functionality of an offline store and can be used as a parameter to a k8s or spark provider</p> <p>Examples: <pre><code>hdfs = ff.register_hdfs(\n    name=\"hdfs-quickstart\",\n    host=\"&lt;host&gt;\",\n    port=\"&lt;port&gt;\",\n    path=\"&lt;path&gt;\",\n    username=\"&lt;username&gt;\",\n    description=\"An hdfs store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of HDFS store to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) The hostname for HDFS</p> required <code>path</code> <code>str</code> <p>(Immutable) A storage path within HDFS</p> <code>''</code> <code>port</code> <code>str</code> <p>(Mutable) The IPC port for the Namenode for HDFS. (Typically 8020 or 9000)</p> required <code>username</code> <code>str</code> <p>(Mutable) A Username for HDFS</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of HDFS provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering HDFS</p> <code>''</code> <p>Returns:</p> Name Type Description <code>hdfs</code> <code>FileStoreProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_hdfs(\n    self,\n    name: str,\n    host: str,\n    port: str,\n    username: str = \"\",\n    path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a HDFS store provider.\n\n    This has the functionality of an offline store and can be used as a parameter\n    to a k8s or spark provider\n\n    **Examples**:\n    ```\n    hdfs = ff.register_hdfs(\n        name=\"hdfs-quickstart\",\n        host=\"&lt;host&gt;\",\n        port=\"&lt;port&gt;\",\n        path=\"&lt;path&gt;\",\n        username=\"&lt;username&gt;\",\n        description=\"An hdfs store provider to store offline\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of HDFS store to be registered\n        host (str): (Immutable) The hostname for HDFS\n        path (str): (Immutable) A storage path within HDFS\n        port (str): (Mutable) The IPC port for the Namenode for HDFS. (Typically 8020 or 9000)\n        username (str): (Mutable) A Username for HDFS\n        description (str): (Mutable) Description of HDFS provider to be registered\n        team (str): (Mutable) The name of the team registering HDFS\n\n    Returns:\n        hdfs (FileStoreProvider): Provider\n    \"\"\"\n\n    hdfs_config = HDFSConfig(host=host, port=port, path=path, username=username)\n\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=hdfs_config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return FileStoreProvider(self, provider, hdfs_config, hdfs_config.type())\n</code></pre>"},{"location":"register/#mongodb","title":"MongoDB","text":"<p>Register a MongoDB provider.</p> <p>Examples: <pre><code>mongodb = ff.register_mongodb(\n    name=\"mongodb-quickstart\",\n    description=\"A MongoDB deployment\",\n    username=\"my_username\",\n    password=\"myPassword\",\n    database=\"featureform_database\"\n    host=\"my-mongodb.host.com\",\n    port=\"10225\",\n    throughput=10000\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of MongoDB provider to be registered</p> required <code>database</code> <code>str</code> <p>(Immutable) MongoDB database</p> required <code>host</code> <code>str</code> <p>(Immutable) MongoDB hostname</p> required <code>port</code> <code>str</code> <p>(Immutable) MongoDB port</p> required <code>username</code> <code>str</code> <p>(Mutable) MongoDB username</p> required <code>password</code> <code>str</code> <p>(Mutable) MongoDB password</p> required <code>throughput</code> <code>int</code> <p>(Mutable) The maximum RU limit for autoscaling in CosmosDB</p> <code>1000</code> <code>description</code> <code>str</code> <p>(Mutable) Description of MongoDB provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>mongodb</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_mongodb(\n    self,\n    name: str,\n    username: str,\n    password: str,\n    database: str,\n    host: str,\n    port: str,\n    throughput: int = 1000,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a MongoDB provider.\n\n    **Examples**:\n    ```\n    mongodb = ff.register_mongodb(\n        name=\"mongodb-quickstart\",\n        description=\"A MongoDB deployment\",\n        username=\"my_username\",\n        password=\"myPassword\",\n        database=\"featureform_database\"\n        host=\"my-mongodb.host.com\",\n        port=\"10225\",\n        throughput=10000\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of MongoDB provider to be registered\n        database (str): (Immutable) MongoDB database\n        host (str): (Immutable) MongoDB hostname\n        port (str): (Immutable) MongoDB port\n        username (str): (Mutable) MongoDB username\n        password (str): (Mutable) MongoDB password\n        throughput (int): (Mutable) The maximum RU limit for autoscaling in CosmosDB\n        description (str): (Mutable) Description of MongoDB provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        mongodb (OnlineProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = MongoDBConfig(\n        username=username,\n        password=password,\n        host=host,\n        port=port,\n        database=database,\n        throughput=throughput,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#pinecone","title":"Pinecone","text":"<p>Register a Pinecone provider.</p> <p>Examples: <pre><code>pinecone = ff.register_pinecone(\n    name=\"pinecone-quickstart\",\n    project_id=\"2g13ek7\",\n    environment=\"us-west4-gcp-free\",\n    api_key=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Pinecone provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) Pinecone project id</p> required <code>environment</code> <code>str</code> <p>(Immutable) Pinecone environment</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Pinecone api key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Pinecone provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>pinecone</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_pinecone(\n    self,\n    name: str,\n    project_id: str,\n    environment: str,\n    api_key: str,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Pinecone provider.\n\n    **Examples**:\n    ```\n    pinecone = ff.register_pinecone(\n        name=\"pinecone-quickstart\",\n        project_id=\"2g13ek7\",\n        environment=\"us-west4-gcp-free\",\n        api_key=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Pinecone provider to be registered\n        project_id (str): (Immutable) Pinecone project id\n        environment (str): (Immutable) Pinecone environment\n        api_key (str): (Mutable) Pinecone api key\n        description (str): (Mutable) Description of Pinecone provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        pinecone (OnlineProvider): Provider\n    \"\"\"\n\n    tags, properties = set_tags_properties(tags, properties)\n    config = PineconeConfig(\n        project_id=project_id, environment=environment, api_key=api_key\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#postgres","title":"Postgres","text":"<p>Register a Postgres provider.</p> <p>Examples: <pre><code>postgres = ff.register_postgres(\n    name=\"postgres-quickstart\",\n    description=\"A Postgres deployment we created for the Featureform quickstart\",\n    host=\"quickstart-postgres\",  # The internal dns name for postgres\n    port=\"5432\",\n    user=\"postgres\",\n    password=\"password\", #pragma: allowlist secret\n    database=\"postgres\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Postgres provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Postgres</p> required <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> <code>'5432'</code> <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>sslmode</code> <code>str</code> <p>(Mutable) SSL mode</p> <code>'disable'</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Postgres provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>postgres</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_postgres(\n    self,\n    name: str,\n    host: str,\n    user: str,\n    password: str,\n    database: str,\n    port: str = \"5432\",\n    description: str = \"\",\n    team: str = \"\",\n    sslmode: str = \"disable\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Postgres provider.\n\n    **Examples**:\n    ```\n    postgres = ff.register_postgres(\n        name=\"postgres-quickstart\",\n        description=\"A Postgres deployment we created for the Featureform quickstart\",\n        host=\"quickstart-postgres\",  # The internal dns name for postgres\n        port=\"5432\",\n        user=\"postgres\",\n        password=\"password\", #pragma: allowlist secret\n        database=\"postgres\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Postgres provider to be registered\n        host (str): (Immutable) Hostname for Postgres\n        database (str): (Immutable) Database\n        port (str): (Mutable) Port\n        user (str): (Mutable) User\n        password (str): (Mutable) Password\n        sslmode (str): (Mutable) SSL mode\n        description (str): (Mutable) Description of Postgres provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        postgres (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = PostgresConfig(\n        host=host,\n        port=port,\n        database=database,\n        user=user,\n        password=password,\n        sslmode=sslmode,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags or [],\n        properties=properties or {},\n    )\n\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#redis","title":"Redis","text":"<p>Register a Redis provider.</p> <p>Examples: <pre><code>redis = ff.register_redis(\n    name=\"redis-quickstart\",\n    host=\"quickstart-redis\",\n    port=6379,\n    password=\"password\",\n    description=\"A Redis deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Redis provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Redis</p> required <code>db</code> <code>str</code> <p>(Immutable) Redis database number</p> <code>0</code> <code>port</code> <code>int</code> <p>(Mutable) Redis port</p> <code>6379</code> <code>password</code> <code>str</code> <p>(Mutable) Redis password</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Redis provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>Optional[List[str]]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <code>properties</code> <code>Optional[dict]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <p>Returns:</p> Name Type Description <code>redis</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_redis(\n    self,\n    name: str,\n    host: str,\n    port: int = 6379,\n    db: int = 0,\n    password: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: Optional[List[str]] = None,\n    properties: Optional[dict] = None,\n):\n    \"\"\"Register a Redis provider.\n\n    **Examples**:\n    ```\n    redis = ff.register_redis(\n        name=\"redis-quickstart\",\n        host=\"quickstart-redis\",\n        port=6379,\n        password=\"password\",\n        description=\"A Redis deployment we created for the Featureform quickstart\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Redis provider to be registered\n        host (str): (Immutable) Hostname for Redis\n        db (str): (Immutable) Redis database number\n        port (int): (Mutable) Redis port\n        password (str): (Mutable) Redis password\n        description (str): (Mutable) Description of Redis provider to be registered\n        team (str): (Mutable) Name of team\n        tags (Optional[List[str]]): (Mutable) Optional grouping mechanism for resources\n        properties (Optional[dict]): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        redis (OnlineProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = RedisConfig(host=host, port=port, password=password, db=db)\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#redshift","title":"Redshift","text":"<p>Register a Redshift provider.</p> <p>Examples: <pre><code>redshift = ff.register_redshift(\n    name=\"redshift-quickstart\",\n    description=\"A Redshift deployment we created for the Featureform quickstart\",\n    host=\"quickstart-redshift\",  # The internal dns name for redshift\n    port=\"5432\",\n    user=\"redshift\",\n    password=\"password\", #pragma: allowlist secret\n    database=\"dev\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Redshift provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Redshift</p> required <code>database</code> <code>str</code> <p>(Immutable) Redshift database</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> required <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) Redshift password</p> required <code>sslmode</code> <code>str</code> <p>(Mutable) SSL mode</p> <code>'disable'</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Redshift provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>redshift</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_redshift(\n    self,\n    name: str,\n    host: str,\n    port: str,\n    user: str,\n    password: str,\n    database: str,\n    description: str = \"\",\n    team: str = \"\",\n    sslmode: str = \"disable\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Redshift provider.\n\n    **Examples**:\n    ```\n    redshift = ff.register_redshift(\n        name=\"redshift-quickstart\",\n        description=\"A Redshift deployment we created for the Featureform quickstart\",\n        host=\"quickstart-redshift\",  # The internal dns name for redshift\n        port=\"5432\",\n        user=\"redshift\",\n        password=\"password\", #pragma: allowlist secret\n        database=\"dev\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Redshift provider to be registered\n        host (str): (Immutable) Hostname for Redshift\n        database (str): (Immutable) Redshift database\n        port (str): (Mutable) Port\n        user (str): (Mutable) User\n        password (str): (Mutable) Redshift password\n        sslmode (str): (Mutable) SSL mode\n        description (str): (Mutable) Description of Redshift provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        redshift (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = RedshiftConfig(\n        host=host,\n        port=port,\n        database=database,\n        user=user,\n        password=password,\n        sslmode=sslmode,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#clickhouse","title":"ClickHouse","text":"<p>Register a ClickHouse provider.</p> <p>Examples: <pre><code>clickhouse = ff.register_clickhouse(\n    name=\"clickhouse-quickstart\",\n    description=\"A ClickHouse deployment we created for the Featureform quickstart\",\n    host=\"quickstart-clickhouse\",  # The internal dns name for clickhouse\n    port=9000,\n    user=\"default\",\n    password=\"\", #pragma: allowlist secret\n    database=\"default\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of ClickHouse provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for ClickHouse</p> required <code>database</code> <code>str</code> <p>(Immutable) ClickHouse database</p> required <code>port</code> <code>int</code> <p>(Mutable) Port</p> <code>9000</code> <code>ssl</code> <code>bool</code> <p>(Mutable) Enable SSL</p> <code>False</code> <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) ClickHouse password</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of ClickHouse provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>clickhouse</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_clickhouse(\n    self,\n    name: str,\n    host: str,\n    user: str,\n    password: str,\n    database: str,\n    port: int = 9000,\n    description: str = \"\",\n    team: str = \"\",\n    ssl: bool = False,\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a ClickHouse provider.\n\n    **Examples**:\n    ```\n    clickhouse = ff.register_clickhouse(\n        name=\"clickhouse-quickstart\",\n        description=\"A ClickHouse deployment we created for the Featureform quickstart\",\n        host=\"quickstart-clickhouse\",  # The internal dns name for clickhouse\n        port=9000,\n        user=\"default\",\n        password=\"\", #pragma: allowlist secret\n        database=\"default\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of ClickHouse provider to be registered\n        host (str): (Immutable) Hostname for ClickHouse\n        database (str): (Immutable) ClickHouse database\n        port (int): (Mutable) Port\n        ssl (bool): (Mutable) Enable SSL\n        user (str): (Mutable) User\n        password (str): (Mutable) ClickHouse password\n        description (str): (Mutable) Description of ClickHouse provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        clickhouse (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = ClickHouseConfig(\n        host=host,\n        port=port,\n        database=database,\n        user=user,\n        password=password,\n        ssl=ssl,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#s3","title":"S3","text":"<p>Register a S3 store provider.</p> <p>This has the functionality of an offline store and can be used as a parameter to a k8s or spark provider</p> <p>Examples: <pre><code>s3 = ff.register_s3(\n    name=\"s3-quickstart\",\n    credentials=aws_creds,\n    bucket_name=\"bucket_name\",\n    bucket_region=&lt;bucket_region&gt;,\n    path=\"path/to/store/featureform_files/in/\",\n    description=\"An s3 store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of S3 store to be registered</p> required <code>bucket_name</code> <code>str</code> <p>(Immutable) AWS Bucket Name</p> required <code>bucket_region</code> <code>str</code> <p>(Immutable) AWS region the bucket is located in</p> required <code>path</code> <code>str</code> <p>(Immutable) The path used to store featureform files in</p> <code>''</code> <code>credentials</code> <code>AWSCredentials</code> <p>(Mutable) AWS credentials to access the bucket</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of S3 provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>s3</code> <code>FileStoreProvider</code> <p>Provider has all the functionality of OfflineProvider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_s3(\n    self,\n    name: str,\n    credentials: AWSCredentials,\n    bucket_region: str,\n    bucket_name: str,\n    path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a S3 store provider.\n\n    This has the functionality of an offline store and can be used as a parameter\n    to a k8s or spark provider\n\n    **Examples**:\n    ```\n    s3 = ff.register_s3(\n        name=\"s3-quickstart\",\n        credentials=aws_creds,\n        bucket_name=\"bucket_name\",\n        bucket_region=&lt;bucket_region&gt;,\n        path=\"path/to/store/featureform_files/in/\",\n        description=\"An s3 store provider to store offline\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of S3 store to be registered\n        bucket_name (str): (Immutable) AWS Bucket Name\n        bucket_region (str): (Immutable) AWS region the bucket is located in\n        path (str): (Immutable) The path used to store featureform files in\n        credentials (AWSCredentials): (Mutable) AWS credentials to access the bucket\n        description (str): (Mutable) Description of S3 provider to be registered\n        team (str): (Mutable) The name of the team registering the filestore\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        s3 (FileStoreProvider): Provider\n            has all the functionality of OfflineProvider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n\n    if bucket_name == \"\":\n        raise ValueError(\"bucket_name is required and cannot be empty string\")\n\n    # TODO: add verification into S3StoreConfig\n    bucket_name = bucket_name.replace(\"s3://\", \"\").replace(\"s3a://\", \"\")\n\n    if \"/\" in bucket_name:\n        raise ValueError(\n            \"bucket_name cannot contain '/'. bucket_name should be the name of the AWS S3 bucket only.\"\n        )\n\n    s3_config = S3StoreConfig(\n        bucket_path=bucket_name,\n        bucket_region=bucket_region,\n        credentials=credentials,\n        path=path,\n    )\n\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=s3_config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return FileStoreProvider(self, provider, s3_config, s3_config.type())\n</code></pre>"},{"location":"register/#snowflake","title":"Snowflake","text":""},{"location":"register/#current","title":"Current","text":"<p>Register a Snowflake provider.</p> <p>Examples: <pre><code>snowflake = ff.register_snowflake(\n    name=\"snowflake-quickstart\",\n    username=\"snowflake\",\n    password=\"password\", #pragma: allowlist secret\n    account=\"account\",\n    organization=\"organization\",\n    database=\"snowflake\",\n    schema=\"PUBLIC\",\n    description=\"A Snowflake deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Snowflake provider to be registered</p> required <code>account</code> <code>str</code> <p>(Immutable) Account</p> required <code>organization</code> <code>str</code> <p>(Immutable) Organization</p> required <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>schema</code> <code>str</code> <p>(Immutable) Schema</p> <code>'PUBLIC'</code> <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>warehouse</code> <code>str</code> <p>(Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.</p> <code>''</code> <code>role</code> <code>str</code> <p>(Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Snowflake provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_snowflake(\n    self,\n    name: str,\n    username: str,\n    password: str,\n    account: str,\n    organization: str,\n    database: str,\n    schema: str = \"PUBLIC\",\n    description: str = \"\",\n    team: str = \"\",\n    warehouse: str = \"\",\n    role: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Snowflake provider.\n\n    **Examples**:\n    ```\n    snowflake = ff.register_snowflake(\n        name=\"snowflake-quickstart\",\n        username=\"snowflake\",\n        password=\"password\", #pragma: allowlist secret\n        account=\"account\",\n        organization=\"organization\",\n        database=\"snowflake\",\n        schema=\"PUBLIC\",\n        description=\"A Snowflake deployment we created for the Featureform quickstart\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Snowflake provider to be registered\n        account (str): (Immutable) Account\n        organization (str): (Immutable) Organization\n        database (str): (Immutable) Database\n        schema (str): (Immutable) Schema\n        username (str): (Mutable) Username\n        password (str): (Mutable) Password\n        warehouse (str): (Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.\n        role (str): (Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session\n        description (str): (Mutable) Description of Snowflake provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        snowflake (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = SnowflakeConfig(\n        account=account,\n        database=database,\n        organization=organization,\n        username=username,\n        password=password,\n        schema=schema,\n        warehouse=warehouse,\n        role=role,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#legacy","title":"Legacy","text":"<p>Register a Snowflake provider using legacy credentials.</p> <p>Examples: <pre><code>snowflake = ff.register_snowflake_legacy(\n    name=\"snowflake-quickstart\",\n    username=\"snowflake\",\n    password=\"password\",\n    account_locator=\"account-locator\",\n    database=\"snowflake\",\n    schema=\"PUBLIC\",\n    description=\"A Snowflake deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Snowflake provider to be registered</p> required <code>account_locator</code> <code>str</code> <p>(Immutable) Account Locator</p> required <code>schema</code> <code>str</code> <p>(Immutable) Schema</p> <code>'PUBLIC'</code> <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>warehouse</code> <code>str</code> <p>(Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.</p> <code>''</code> <code>role</code> <code>str</code> <p>(Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Snowflake provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_snowflake_legacy(\n    self,\n    name: str,\n    username: str,\n    password: str,\n    account_locator: str,\n    database: str,\n    schema: str = \"PUBLIC\",\n    description: str = \"\",\n    team: str = \"\",\n    warehouse: str = \"\",\n    role: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Snowflake provider using legacy credentials.\n\n    **Examples**:\n    ```\n    snowflake = ff.register_snowflake_legacy(\n        name=\"snowflake-quickstart\",\n        username=\"snowflake\",\n        password=\"password\",\n        account_locator=\"account-locator\",\n        database=\"snowflake\",\n        schema=\"PUBLIC\",\n        description=\"A Snowflake deployment we created for the Featureform quickstart\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Snowflake provider to be registered\n        account_locator (str): (Immutable) Account Locator\n        schema (str): (Immutable) Schema\n        database (str): (Immutable) Database\n        username (str): (Mutable) Username\n        password (str): (Mutable) Password\n        warehouse (str): (Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.\n        role (str): (Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session\n        description (str): (Mutable) Description of Snowflake provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        snowflake (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = SnowflakeConfig(\n        account_locator=account_locator,\n        database=database,\n        username=username,\n        password=password,\n        schema=schema,\n        warehouse=warehouse,\n        role=role,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#weaviate","title":"Weaviate","text":"<p>Register a Weaviate provider.</p> <p>Examples: <pre><code>weaviate = ff.register_weaviate(\n    name=\"weaviate-quickstart\",\n    url=\"https://&lt;CLUSTER NAME&gt;.weaviate.network\",\n    api_key=\"&lt;API KEY&gt;\"\n    description=\"A Weaviate project for using embeddings in Featureform\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Weaviate provider to be registered</p> required <code>url</code> <code>str</code> <p>(Immutable) Endpoint of Weaviate cluster, either in the cloud or via another deployment operation</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Weaviate api key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Weaviate provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>weaviate</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_weaviate(\n    self,\n    name: str,\n    url: str,\n    api_key: str,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Weaviate provider.\n\n    **Examples**:\n    ```\n    weaviate = ff.register_weaviate(\n        name=\"weaviate-quickstart\",\n        url=\"https://&lt;CLUSTER NAME&gt;.weaviate.network\",\n        api_key=\"&lt;API KEY&gt;\"\n        description=\"A Weaviate project for using embeddings in Featureform\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Weaviate provider to be registered\n        url (str): (Immutable) Endpoint of Weaviate cluster, either in the cloud or via another deployment operation\n        api_key (str): (Mutable) Weaviate api key\n        description (str): (Mutable) Description of Weaviate provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        weaviate (OnlineProvider): Provider\n    \"\"\"\n    config = WeaviateConfig(url=url, api_key=api_key)\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#primary-sources","title":"Primary Sources","text":"<p>Register a SQL table as a primary data source.</p> <p>Example</p> <pre><code>postgres = client.get_provider(\"my_postgres\")\ntable =  postgres.register_table(\n    name=\"transactions\",\n    variant=\"july_2023\",\n    table=\"transactions_table\",\n):\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of table to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>table</code> <code>str</code> <p>Name of SQL table</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of table to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>source</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_table(\n    self,\n    name: str,\n    table: str,\n    variant: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a SQL table as a primary data source.\n\n    **Example**\n\n    ```\n    postgres = client.get_provider(\"my_postgres\")\n    table =  postgres.register_table(\n        name=\"transactions\",\n        variant=\"july_2023\",\n        table=\"transactions_table\",\n    ):\n    ```\n\n    Args:\n        name (str): Name of table to be registered\n        variant (str): Name of variant to be registered\n        table (str): Name of SQL table\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of table to be registered\n\n    Returns:\n        source (ColumnSourceRegistrar): source\n    \"\"\"\n    return self.__registrar.register_primary_data(\n        name=name,\n        variant=variant,\n        location=SQLTable(table),\n        owner=owner,\n        provider=self.name(),\n        description=description,\n        tags=tags,\n        properties=properties,\n    )\n</code></pre>"},{"location":"register/#transformations","title":"Transformations","text":""},{"location":"register/#featureform.register.ResourceClient","title":"<code>featureform.register.ResourceClient</code>","text":"<p>The resource client is used to retrieve information on specific resources (entities, providers, features, labels, training sets, models, users).</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The hostname of the Featureform instance.</p> <code>None</code> <code>insecure</code> <code>bool</code> <p>True if connecting to an insecure Featureform endpoint. False if using a self-signed or public TLS certificate</p> <code>False</code> <code>cert_path</code> <code>str</code> <p>The path to a public certificate if using a self-signed certificate.</p> <code>None</code> <p>Using the Resource Client: definitions.py<pre><code>import featureform as ff\nfrom featureform import ResourceClient\n\nrc = ResourceClient(\"localhost:8000\")\n\n# example query:\nredis = client.get_provider(\"redis-quickstart\")\n</code></pre></p> Source code in <code>src/featureform/register.py</code> <pre><code>class ResourceClient:\n    \"\"\"\n    The resource client is used to retrieve information on specific resources\n    (entities, providers, features, labels, training sets, models, users).\n\n    Args:\n        host (str): The hostname of the Featureform instance.\n        insecure (bool): True if connecting to an insecure Featureform endpoint. False if using a self-signed or public TLS certificate\n        cert_path (str): The path to a public certificate if using a self-signed certificate.\n\n    **Using the Resource Client:**\n    ``` py title=\"definitions.py\"\n    import featureform as ff\n    from featureform import ResourceClient\n\n    rc = ResourceClient(\"localhost:8000\")\n\n    # example query:\n    redis = client.get_provider(\"redis-quickstart\")\n    ```\n    \"\"\"\n\n    def __init__(\n        self, host=None, local=False, insecure=False, cert_path=None, dry_run=False\n    ):\n        if local:\n            raise Exception(\n                \"Local mode is not supported in this version. Use featureform &lt;= 1.12.0 for localmode\"\n            )\n\n        # This line ensures that the warning is only raised if ResourceClient is instantiated directly\n        # TODO: Remove this check once ServingClient is deprecated\n        is_instantiated_directed = inspect.stack()[1].function != \"__init__\"\n        if is_instantiated_directed:\n            warnings.warn(\n                \"ResourceClient is deprecated and will be removed in future versions; use Client instead.\",\n                PendingDeprecationWarning,\n            )\n        self._dry_run = dry_run\n        self._stub = None\n        self.local = local\n\n        if dry_run:\n            return\n\n        host = host or os.getenv(\"FEATUREFORM_HOST\")\n        if host is None:\n            raise RuntimeError(\n                \"If not in local mode then `host` must be passed or the environment\"\n                \" variable FEATUREFORM_HOST must be set.\"\n            )\n        if insecure:\n            channel = insecure_channel(host)\n        else:\n            channel = secure_channel(host, cert_path)\n        self._stub = GrpcClient(ff_grpc.ApiStub(channel))\n        self._host = host\n\n    def apply(self, asynchronous=False, verbose=False):\n        \"\"\"\n        Apply all definitions, creating and retrieving all specified resources.\n\n        ```python\n        import featureform as ff\n        client = ff.Client()\n\n        ff.register_postgres(\n            host=\"localhost\",\n            port=5432,\n        )\n\n        client.apply()\n        ```\n\n        Args:\n            asynchronous (bool): If True, apply will return immediately and not wait for resources to be created. If False, apply will wait for resources to be created and print out the status of each resource.\n\n        \"\"\"\n\n        try:\n            resource_state = state()\n            if resource_state.is_empty():\n                print(\"No resources to apply\")\n                return\n\n            print(f\"Applying Run: {get_run()}\")\n\n            if self._dry_run:\n                print(resource_state.sorted_list())\n                return\n\n            resource_state.create_all(\n                self._stub, global_registrar.get_client_objects_for_resource()\n            )\n\n            if not asynchronous and self._stub:\n                resources = resource_state.sorted_list()\n                display_statuses(self._stub, resources, verbose=verbose)\n        finally:\n            if feature_flag.is_enabled(\"FF_GET_EQUIVALENT_VARIANTS\", True):\n                set_run(\"\")\n            clear_state()\n\n    def get_user(self, name, local=False):\n        \"\"\"Get a user. Prints out name of user, and all resources associated with the user.\n\n        **Examples:**\n\n        ``` py title=\"Input\"\n        featureformer = rc.get_user(\"featureformer\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_user prints out formatted information on user\n        USER NAME:                     featureformer\n        -----------------------------------------------\n\n        NAME                           VARIANT                        TYPE\n        avg_transactions               quickstart                     feature\n        fraudulent                     quickstart                     label\n        fraud_training                 quickstart                     training set\n        transactions                   kaggle                         source\n        average_user_transaction       quickstart                     source\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(featureformer)\n        ```\n\n        ``` json title=\"Output\"\n        // get_user returns the User object\n\n        name: \"featureformer\"\n        features {\n        name: \"avg_transactions\"\n        variant: \"quickstart\"\n        }\n        labels {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        }\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        sources {\n        name: \"transactions\"\n        variant: \"kaggle\"\n        }\n        sources {\n        name: \"average_user_transaction\"\n        variant: \"quickstart\"\n        }\n        ```\n\n        Args:\n            name (str): Name of user to be retrieved\n\n        Returns:\n            user (User): User\n        \"\"\"\n        return get_user_info(self._stub, name)\n\n    def get_entity(self, name, local=False):\n        \"\"\"Get an entity. Prints out information on entity, and all resources associated with the entity.\n\n        **Examples:**\n\n        ``` py title=\"Input\"\n        entity = rc.get_entity(\"user\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_entity prints out formatted information on entity\n\n        ENTITY NAME:                   user\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n\n        NAME                           VARIANT                        TYPE\n        avg_transactions               quickstart                     feature\n        fraudulent                     quickstart                     label\n        fraud_training                 quickstart                     training set\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(postgres)\n        ```\n\n        ``` json title=\"Output\"\n        // get_entity returns the Entity object\n\n        name: \"user\"\n        features {\n            name: \"avg_transactions\"\n            variant: \"quickstart\"\n        }\n        labels {\n            name: \"fraudulent\"\n            variant: \"quickstart\"\n        }\n        trainingsets {\n            name: \"fraud_training\"\n            variant: \"quickstart\"\n        }\n        ```\n        \"\"\"\n        return get_entity_info(self._stub, name)\n\n    def get_model(self, name, local=False) -&gt; Model:\n        \"\"\"Get a model. Prints out information on model, and all resources associated with the model.\n\n        Args:\n            name (str): Name of model to be retrieved\n\n        Returns:\n            model (Model): Model\n        \"\"\"\n        model = None\n        model_proto = get_resource_info(self._stub, \"model\", name)\n        if model_proto is not None:\n            model = Model(model_proto.name, description=\"\", tags=[], properties={})\n\n        return model\n\n    def get_provider(self, name, local=False):\n        \"\"\"Get a provider. Prints out information on provider, and all resources associated with the provider.\n\n        **Examples:**\n\n        ``` py title=\"Input\"\n        postgres = client.get_provider(\"postgres-quickstart\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_provider prints out formatted information on provider\n\n        NAME:                          postgres-quickstart\n        DESCRIPTION:                   A Postgres deployment we created for the Featureform quickstart\n        TYPE:                          POSTGRES_OFFLINE\n        SOFTWARE:                      postgres\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        SOURCES:\n        NAME                           VARIANT\n        transactions                   kaggle\n        average_user_transaction       quickstart\n        -----------------------------------------------\n        FEATURES:\n        NAME                           VARIANT\n        -----------------------------------------------\n        LABELS:\n        NAME                           VARIANT\n        fraudulent                     quickstart\n        -----------------------------------------------\n        TRAINING SETS:\n        NAME                           VARIANT\n        fraud_training                 quickstart\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(postgres)\n        ```\n\n        ``` json title=\"Output\"\n        // get_provider returns the Provider object\n\n        name: \"postgres-quickstart\"\n        description: \"A Postgres deployment we created for the Featureform quickstart\"\n        type: \"POSTGRES_OFFLINE\"\n        software: \"postgres\"\n        serialized_config: \"{\\\"Host\\\": \\\"quickstart-postgres\\\",\n                            \\\"Port\\\": \\\"5432\\\",\n                            \\\"Username\\\": \\\"postgres\\\",\n                            \\\"Password\\\": \\\"password\\\",\n                            \\\"Database\\\": \\\"postgres\\\"}\"\n        sources {\n        name: \"transactions\"\n        variant: \"kaggle\"\n        }\n        sources {\n        name: \"average_user_transaction\"\n        variant: \"quickstart\"\n        }\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        labels {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        }\n        ```\n\n        Args:\n            name (str): Name of provider to be retrieved\n\n        Returns:\n            provider (Provider): Provider\n        \"\"\"\n        return get_provider_info(self._stub, name)\n\n    def get_feature(self, name, variant):\n        name_variant = metadata_pb2.NameVariant(name=name, variant=variant)\n        feature = None\n        for x in self._stub.GetFeatureVariants(iter([name_variant])):\n            feature = x\n            break\n\n        return FeatureVariant(\n            created=None,\n            name=feature.name,\n            variant=feature.variant,\n            source=(feature.source.name, feature.source.variant),\n            value_type=feature.type,\n            entity=feature.entity,\n            owner=feature.owner,\n            provider=feature.provider,\n            location=ResourceColumnMapping(\"\", \"\", \"\"),\n            description=feature.description,\n            status=feature.status.Status._enum_type.values[feature.status.status].name,\n        )\n\n    def print_feature(self, name, variant=None, local=False):\n        \"\"\"Get a feature. Prints out information on feature, and all variants associated with the feature. If variant is included, print information on that specific variant and all resources associated with it.\n\n        **Examples:**\n\n        ``` py title=\"Input\"\n        avg_transactions = rc.get_feature(\"avg_transactions\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_feature prints out formatted information on feature\n\n        NAME:                          avg_transactions\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        VARIANTS:\n        quickstart                     default\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(avg_transactions)\n        ```\n\n        ``` json title=\"Output\"\n        // get_feature returns the Feature object\n\n        name: \"avg_transactions\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        ```\n\n        ``` py title=\"Input\"\n        avg_transactions_variant = ff.get_feature(\"avg_transactions\", \"quickstart\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_feature with variant provided prints out formatted information on feature variant\n\n        NAME:                          avg_transactions\n        VARIANT:                       quickstart\n        TYPE:                          float32\n        ENTITY:                        user\n        OWNER:                         featureformer\n        PROVIDER:                      redis-quickstart\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        SOURCE:\n        NAME                           VARIANT\n        average_user_transaction       quickstart\n        -----------------------------------------------\n        TRAINING SETS:\n        NAME                           VARIANT\n        fraud_training                 quickstart\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(avg_transactions_variant)\n        ```\n\n        ``` json title=\"Output\"\n        // get_feature returns the FeatureVariant object\n\n        name: \"avg_transactions\"\n        variant: \"quickstart\"\n        source {\n        name: \"average_user_transaction\"\n        variant: \"quickstart\"\n        }\n        type: \"float32\"\n        entity: \"user\"\n        created {\n        seconds: 1658168552\n        nanos: 142461900\n        }\n        owner: \"featureformer\"\n        provider: \"redis-quickstart\"\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        columns {\n        entity: \"user_id\"\n        value: \"avg_transaction_amt\"\n        }\n        ```\n\n        Args:\n            name (str): Name of feature to be retrieved\n            variant (str): Name of variant of feature\n\n        Returns:\n            feature (Union[Feature, FeatureVariant]): Feature or FeatureVariant\n        \"\"\"\n        if not variant:\n            return get_resource_info(self._stub, \"feature\", name)\n        return get_feature_variant_info(self._stub, name, variant)\n\n    def get_label(self, name, variant):\n        name_variant = metadata_pb2.NameVariant(name=name, variant=variant)\n        label = None\n        for x in self._stub.GetLabelVariants(iter([name_variant])):\n            label = x\n            break\n\n        return LabelVariant(\n            name=label.name,\n            variant=label.variant,\n            source=(label.source.name, label.source.variant),\n            value_type=label.type,\n            entity=label.entity,\n            owner=label.owner,\n            provider=label.provider,\n            location=ResourceColumnMapping(\"\", \"\", \"\"),\n            description=label.description,\n            status=label.status.Status._enum_type.values[label.status.status].name,\n        )\n\n    def print_label(self, name, variant=None, local=False):\n        \"\"\"Get a label. Prints out information on label, and all variants associated with the label. If variant is included, print information on that specific variant and all resources associated with it.\n\n        **Examples:**\n\n        ``` py title=\"Input\"\n        fraudulent = rc.get_label(\"fraudulent\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_label prints out formatted information on label\n\n        NAME:                          fraudulent\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        VARIANTS:\n        quickstart                     default\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(fraudulent)\n        ```\n\n        ``` json title=\"Output\"\n        // get_label returns the Label object\n\n        name: \"fraudulent\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        ```\n\n        ``` py title=\"Input\"\n        fraudulent_variant = ff.get_label(\"fraudulent\", \"quickstart\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_label with variant provided prints out formatted information on label variant\n\n        NAME:                          fraudulent\n        VARIANT:                       quickstart\n        TYPE:                          bool\n        ENTITY:                        user\n        OWNER:                         featureformer\n        PROVIDER:                      postgres-quickstart\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        SOURCE:\n        NAME                           VARIANT\n        transactions                   kaggle\n        -----------------------------------------------\n        TRAINING SETS:\n        NAME                           VARIANT\n        fraud_training                 quickstart\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(fraudulent_variant)\n        ```\n\n        ``` json title=\"Output\"\n        // get_label returns the LabelVariant object\n\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        type: \"bool\"\n        source {\n        name: \"transactions\"\n        variant: \"kaggle\"\n        }\n        entity: \"user\"\n        created {\n        seconds: 1658168552\n        nanos: 154924300\n        }\n        owner: \"featureformer\"\n        provider: \"postgres-quickstart\"\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        columns {\n        entity: \"customerid\"\n        value: \"isfraud\"\n        }\n        ```\n\n        Args:\n            name (str): Name of label to be retrieved\n            variant (str): Name of variant of label\n\n        Returns:\n            label (Union[label, LabelVariant]): Label or LabelVariant\n        \"\"\"\n        if not variant:\n            return get_resource_info(self._stub, \"label\", name)\n        return get_label_variant_info(self._stub, name, variant)\n\n    def get_training_set(self, name, variant):\n        name_variant = metadata_pb2.NameVariant(name=name, variant=variant)\n        ts = None\n        for x in self._stub.GetTrainingSetVariants(iter([name_variant])):\n            ts = x\n            break\n\n        return TrainingSetVariant(\n            created=None,\n            name=ts.name,\n            variant=ts.variant,\n            owner=ts.owner,\n            description=ts.description,\n            status=ts.status.Status._enum_type.values[ts.status.status].name,\n            label=(ts.label.name, ts.label.variant),\n            features=[(f.name, f.variant) for f in ts.features],\n            feature_lags=[],\n            provider=ts.provider,\n            # TODO: apply values from proto\n            tags=[],\n            properties={},\n        )\n\n    def print_training_set(self, name, variant=None, local=False):\n        \"\"\"Get a training set. Prints out information on training set, and all variants associated with the training set. If variant is included, print information on that specific variant and all resources associated with it.\n\n        **Examples:**\n\n        ``` py title=\"Input\"\n        fraud_training = rc.get_training_set(\"fraud_training\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_training_set prints out formatted information on training set\n\n        NAME:                          fraud_training\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        VARIANTS:\n        quickstart                     default\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(fraud_training)\n        ```\n\n        ``` json title=\"Output\"\n        // get_training_set returns the TrainingSet object\n\n        name: \"fraud_training\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        ```\n\n        ``` py title=\"Input\"\n        fraudulent_variant = ff.get_training set(\"fraudulent\", \"quickstart\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_training_set with variant provided prints out formatted information on training set variant\n\n        NAME:                          fraud_training\n        VARIANT:                       quickstart\n        OWNER:                         featureformer\n        PROVIDER:                      postgres-quickstart\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        LABEL:\n        NAME                           VARIANT\n        fraudulent                     quickstart\n        -----------------------------------------------\n        FEATURES:\n        NAME                           VARIANT\n        avg_transactions               quickstart\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(fraudulent_variant)\n        ```\n\n        ``` json title=\"Output\"\n        // get_training_set returns the TrainingSetVariant object\n\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        owner: \"featureformer\"\n        created {\n        seconds: 1658168552\n        nanos: 157934800\n        }\n        provider: \"postgres-quickstart\"\n        features {\n        name: \"avg_transactions\"\n        variant: \"quickstart\"\n        }\n        label {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        }\n        ```\n\n        Args:\n            name (str): Name of training set to be retrieved\n            variant (str): Name of variant of training set\n\n        Returns:\n            training_set (Union[TrainingSet, TrainingSetVariant]): TrainingSet or TrainingSetVariant\n        \"\"\"\n        if not variant:\n            return get_resource_info(self._stub, \"training-set\", name)\n        return get_training_set_variant_info(self._stub, name, variant)\n\n    def get_source(self, name, variant):\n        name_variant = metadata_pb2.NameVariantRequest(\n            name_variant=metadata_pb2.NameVariant(name=name, variant=variant)\n        )\n        source = None\n        for x in self._stub.GetSourceVariants(iter([name_variant])):\n            source = x\n            break\n\n        definition = self._get_source_definition(source)\n\n        source_variant = SourceVariant(\n            created=None,\n            name=source.name,\n            definition=definition,\n            owner=source.owner,\n            provider=source.provider,\n            description=source.description,\n            variant=source.variant,\n            status=source.status.Status._enum_type.values[source.status.status].name,\n            tags=[],\n            properties={},\n            source_text=(\n                definition.source_text if type(definition) == DFTransformation else \"\"\n            ),\n        )\n        return ColumnSourceRegistrar(self, source_variant)\n\n    def _get_source_definition(self, source):\n        if source.primaryData.table.name:\n            return PrimaryData(SQLTable(source.primaryData.table.name))\n        elif source.transformation:\n            return self._get_transformation_definition(source)\n        else:\n            raise Exception(f\"Invalid source type {source}\")\n\n    def _get_transformation_definition(self, source):\n        if source.transformation.DFTransformation.query != bytes():\n            transformation = source.transformation.DFTransformation\n            return DFTransformation(\n                query=transformation.query,\n                inputs=[(input.name, input.variant) for input in transformation.inputs],\n                source_text=transformation.source_text,\n            )\n        elif source.transformation.SQLTransformation.query != \"\":\n            return SQLTransformation(source.transformation.SQLTransformation.query)\n        else:\n            raise Exception(f\"Invalid transformation type {source}\")\n\n    def print_source(self, name, variant=None, local=False):\n        \"\"\"Get a source. Prints out information on source, and all variants associated with the source. If variant is included, print information on that specific variant and all resources associated with it.\n\n        **Examples:**\n\n        ``` py title=\"Input\"\n        transactions = rc.get_transactions(\"transactions\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_source prints out formatted information on source\n\n        NAME:                          transactions\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        VARIANTS:\n        kaggle                         default\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(transactions)\n        ```\n\n        ``` json title=\"Output\"\n        // get_source returns the Source object\n\n        name: \"transactions\"\n        default_variant: \"kaggle\"\n        variants: \"kaggle\"\n        ```\n\n        ``` py title=\"Input\"\n        transactions_variant = rc.get_source(\"transactions\", \"kaggle\")\n        ```\n\n        ``` json title=\"Output\"\n        // get_source with variant provided prints out formatted information on source variant\n\n        NAME:                          transactions\n        VARIANT:                       kaggle\n        OWNER:                         featureformer\n        DESCRIPTION:                   Fraud Dataset From Kaggle\n        PROVIDER:                      postgres-quickstart\n        STATUS:                        NO_STATUS\n        -----------------------------------------------\n        DEFINITION:\n        TRANSFORMATION\n\n        -----------------------------------------------\n        SOURCES\n        NAME                           VARIANT\n        -----------------------------------------------\n        PRIMARY DATA\n        Transactions\n        FEATURES:\n        NAME                           VARIANT\n        -----------------------------------------------\n        LABELS:\n        NAME                           VARIANT\n        fraudulent                     quickstart\n        -----------------------------------------------\n        TRAINING SETS:\n        NAME                           VARIANT\n        fraud_training                 quickstart\n        -----------------------------------------------\n        ```\n\n        ``` py title=\"Input\"\n        print(transactions_variant)\n        ```\n\n        ``` json title=\"Output\"\n        // get_source returns the SourceVariant object\n\n        name: \"transactions\"\n        variant: \"kaggle\"\n        owner: \"featureformer\"\n        description: \"Fraud Dataset From Kaggle\"\n        provider: \"postgres-quickstart\"\n        created {\n        seconds: 1658168552\n        nanos: 128768000\n        }\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        labels {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        }\n        primaryData {\n        table {\n            name: \"Transactions\"\n        }\n        }\n        ```\n\n        Args:\n            name (str): Name of source to be retrieved\n            variant (str): Name of variant of source\n\n        Returns:\n            source (Union[Source, SourceVariant]): Source or SourceVariant\n        \"\"\"\n        if not variant:\n            return get_resource_info(self._stub, \"source\", name)\n        return get_source_variant_info(self._stub, name, variant)\n\n    def list_features(self, local=False):\n        \"\"\"List all features.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        features_list = rc.list_features()\n        ```\n\n        ``` json title=\"Output\"\n        // list_features prints out formatted information on all features\n\n        NAME                           VARIANT                        STATUS\n        user_age                       quickstart (default)           READY\n        avg_transactions               quickstart (default)           READY\n        avg_transactions               production                     CREATED\n        ```\n\n        ``` py title=\"Input\"\n        print(features_list)\n        ```\n\n        ``` json title=\"Output\"\n        // list_features returns a list of Feature objects\n\n        [name: \"user_age\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        , name: \"avg_transactions\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        variants: \"production\"\n        ]\n        ```\n\n        Returns:\n            features (List[Feature]): List of Feature Objects\n        \"\"\"\n        return list_name_variant_status(self._stub, \"feature\")\n\n    def list_labels(self, local=False):\n        \"\"\"List all labels.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        features_list = rc.list_labels()\n        ```\n\n        ``` json title=\"Output\"\n        // list_labels prints out formatted information on all labels\n\n        NAME                           VARIANT                        STATUS\n        user_age                       quickstart (default)           READY\n        avg_transactions               quickstart (default)           READY\n        avg_transactions               production                     CREATED\n        ```\n\n        ``` py title=\"Input\"\n        print(label_list)\n        ```\n\n        ``` json title=\"Output\"\n        // list_features returns a list of Feature objects\n\n        [name: \"user_age\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        , name: \"avg_transactions\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        variants: \"production\"\n        ]\n        ```\n\n        Returns:\n            labels (List[Label]): List of Label Objects\n        \"\"\"\n        return list_name_variant_status(self._stub, \"label\")\n\n    def list_users(self, local=False):\n        \"\"\"List all users. Prints a list of all users.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        users_list = rc.list_users()\n        ```\n\n        ``` json title=\"Output\"\n        // list_users prints out formatted information on all users\n\n        NAME                           STATUS\n        featureformer                  NO_STATUS\n        featureformers_friend          CREATED\n        ```\n\n        ``` py title=\"Input\"\n        print(features_list)\n        ```\n\n        ``` json title=\"Output\"\n        // list_features returns a list of Feature objects\n\n        [name: \"featureformer\"\n        features {\n        name: \"avg_transactions\"\n        variant: \"quickstart\"\n        }\n        labels {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        }\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        sources {\n        name: \"transactions\"\n        variant: \"kaggle\"\n        }\n        sources {\n        name: \"average_user_transaction\"\n        variant: \"quickstart\"\n        },\n        name: \"featureformers_friend\"\n        features {\n        name: \"user_age\"\n        variant: \"production\"\n        }\n        sources {\n        name: \"user_profiles\"\n        variant: \"production\"\n        }\n        ]\n        ```\n\n        Returns:\n            users (List[User]): List of User Objects\n        \"\"\"\n        return list_name_status(self._stub, \"user\")\n\n    def list_entities(self, local=False):\n        \"\"\"List all entities. Prints a list of all entities.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        entities = rc.list_entities()\n        ```\n\n        ``` json title=\"Output\"\n        // list_entities prints out formatted information on all entities\n\n        NAME                           STATUS\n        user                           CREATED\n        transaction                    CREATED\n        ```\n\n        ``` py title=\"Input\"\n        print(features_list)\n        ```\n\n        ``` json title=\"Output\"\n        // list_entities returns a list of Entity objects\n\n        [name: \"user\"\n        features {\n        name: \"avg_transactions\"\n        variant: \"quickstart\"\n        }\n        features {\n        name: \"avg_transactions\"\n        variant: \"production\"\n        }\n        features {\n        name: \"user_age\"\n        variant: \"quickstart\"\n        }\n        labels {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        }\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        ,\n        name: \"transaction\"\n        features {\n        name: \"amount_spent\"\n        variant: \"production\"\n        }\n        ]\n        ```\n\n        Returns:\n            entities (List[Entity]): List of Entity Objects\n        \"\"\"\n        return list_name_status(self._stub, \"entity\")\n\n    def list_sources(self, local=False):\n        \"\"\"List all sources. Prints a list of all sources.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        sources_list = rc.list_sources()\n        ```\n\n        ``` json title=\"Output\"\n        // list_sources prints out formatted information on all sources\n\n        NAME                           VARIANT                        STATUS                         DESCRIPTION\n        average_user_transaction       quickstart (default)           NO_STATUS                      the average transaction amount for a user\n        transactions                   kaggle (default)               NO_STATUS                      Fraud Dataset From Kaggle\n        ```\n\n        ``` py title=\"Input\"\n        print(sources_list)\n        ```\n\n        ``` json title=\"Output\"\n        // list_sources returns a list of Source objects\n\n        [name: \"average_user_transaction\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\"\n        , name: \"transactions\"\n        default_variant: \"kaggle\"\n        variants: \"kaggle\"\n        ]\n        ```\n\n        Returns:\n            sources (List[Source]): List of Source Objects\n        \"\"\"\n        return list_name_variant_status_desc(self._stub, \"source\")\n\n    def list_training_sets(self, local=False):\n        \"\"\"List all training sets. Prints a list of all training sets.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        training_sets_list = rc.list_training_sets()\n        ```\n\n        ``` json title=\"Output\"\n        // list_training_sets prints out formatted information on all training sets\n\n        NAME                           VARIANT                        STATUS                         DESCRIPTION\n        fraud_training                 quickstart (default)           READY                          Training set for fraud detection.\n        fraud_training                 v2                             CREATED                        Improved training set for fraud detection.\n        recommender                    v1 (default)                   CREATED                        Training set for recommender system.\n        ```\n\n        ``` py title=\"Input\"\n        print(training_sets_list)\n        ```\n\n        ``` json title=\"Output\"\n        // list_training_sets returns a list of TrainingSet objects\n\n        [name: \"fraud_training\"\n        default_variant: \"quickstart\"\n        variants: \"quickstart\", \"v2\",\n        name: \"recommender\"\n        default_variant: \"v1\"\n        variants: \"v1\"\n        ]\n        ```\n\n        Returns:\n            training_sets (List[TrainingSet]): List of TrainingSet Objects\n        \"\"\"\n        return list_name_variant_status_desc(self._stub, \"training-set\")\n\n    def list_models(self, local=False) -&gt; List[Model]:\n        \"\"\"List all models. Prints a list of all models.\n\n        Returns:\n            models (List[Model]): List of Model Objects\n        \"\"\"\n        model_protos = list_name(self._stub, \"model\")\n        # TODO: apply values from proto\n        models = [Model(proto.name, tags=[], properties={}) for proto in model_protos]\n\n        return models\n\n    def list_providers(self, local=False):\n        \"\"\"List all providers. Prints a list of all providers.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        providers_list = rc.list_providers()\n        ```\n\n        ``` json title=\"Output\"\n        // list_providers prints out formatted information on all providers\n\n        NAME                           STATUS                         DESCRIPTION\n        redis-quickstart               CREATED                      A Redis deployment we created for the Featureform quickstart\n        postgres-quickstart            CREATED                      A Postgres deployment we created for the Featureform quickst\n        ```\n\n        ``` py title=\"Input\"\n        print(providers_list)\n        ```\n\n        ``` json title=\"Output\"\n        // list_providers returns a list of Providers objects\n\n        [name: \"redis-quickstart\"\n        description: \"A Redis deployment we created for the Featureform quickstart\"\n        type: \"REDIS_ONLINE\"\n        software: \"redis\"\n        serialized_config: \"{\\\"Addr\\\": \\\"quickstart-redis:6379\\\", \\\"Password\\\": \\\"\\\", \\\"DB\\\": 0}\"\n        features {\n        name: \"avg_transactions\"\n        variant: \"quickstart\"\n        }\n        features {\n        name: \"avg_transactions\"\n        variant: \"production\"\n        }\n        features {\n        name: \"user_age\"\n        variant: \"quickstart\"\n        }\n        , name: \"postgres-quickstart\"\n        description: \"A Postgres deployment we created for the Featureform quickstart\"\n        type: \"POSTGRES_OFFLINE\"\n        software: \"postgres\"\n        serialized_config: \"{\\\"Host\\\": \\\"quickstart-postgres\\\", \\\"Port\\\": \\\"5432\\\", \\\"Username\\\": \\\"postgres\\\", \\\"Password\\\": \\\"password\\\", \\\"Database\\\": \\\"postgres\\\"}\"\n        sources {\n        name: \"transactions\"\n        variant: \"kaggle\"\n        }\n        sources {\n        name: \"average_user_transaction\"\n        variant: \"quickstart\"\n        }\n        trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n        }\n        labels {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n        }\n        ]\n        ```\n\n        Returns:\n            providers (List[Provider]): List of Provider Objects\n        \"\"\"\n        return list_name_status_desc(self._stub, \"provider\")\n\n    def search(self, raw_query, local=False):\n        \"\"\"Search for registered resources. Prints a list of results.\n\n        **Examples:**\n        ``` py title=\"Input\"\n        providers_list = rc.search(\"transact\")\n        ```\n\n        ``` json title=\"Output\"\n        // search prints out formatted information on all matches\n\n        NAME                           VARIANT            TYPE\n        avg_transactions               default            Source\n        ```\n        \"\"\"\n        if type(raw_query) != str or len(raw_query) == 0:\n            raise Exception(\"query must be string and cannot be empty\")\n        processed_query = raw_query.translate({ord(i): None for i in \".,-@!*#\"})\n        return search(processed_query, self._host)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.apply","title":"<code>apply(asynchronous=False, verbose=False)</code>","text":"<p>Apply all definitions, creating and retrieving all specified resources.</p> <pre><code>import featureform as ff\nclient = ff.Client()\n\nff.register_postgres(\n    host=\"localhost\",\n    port=5432,\n)\n\nclient.apply()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>asynchronous</code> <code>bool</code> <p>If True, apply will return immediately and not wait for resources to be created. If False, apply will wait for resources to be created and print out the status of each resource.</p> <code>False</code> Source code in <code>src/featureform/register.py</code> <pre><code>def apply(self, asynchronous=False, verbose=False):\n    \"\"\"\n    Apply all definitions, creating and retrieving all specified resources.\n\n    ```python\n    import featureform as ff\n    client = ff.Client()\n\n    ff.register_postgres(\n        host=\"localhost\",\n        port=5432,\n    )\n\n    client.apply()\n    ```\n\n    Args:\n        asynchronous (bool): If True, apply will return immediately and not wait for resources to be created. If False, apply will wait for resources to be created and print out the status of each resource.\n\n    \"\"\"\n\n    try:\n        resource_state = state()\n        if resource_state.is_empty():\n            print(\"No resources to apply\")\n            return\n\n        print(f\"Applying Run: {get_run()}\")\n\n        if self._dry_run:\n            print(resource_state.sorted_list())\n            return\n\n        resource_state.create_all(\n            self._stub, global_registrar.get_client_objects_for_resource()\n        )\n\n        if not asynchronous and self._stub:\n            resources = resource_state.sorted_list()\n            display_statuses(self._stub, resources, verbose=verbose)\n    finally:\n        if feature_flag.is_enabled(\"FF_GET_EQUIVALENT_VARIANTS\", True):\n            set_run(\"\")\n        clear_state()\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.get_entity","title":"<code>get_entity(name, local=False)</code>","text":"<p>Get an entity. Prints out information on entity, and all resources associated with the entity.</p> <p>Examples:</p> Input<pre><code>entity = rc.get_entity(\"user\")\n</code></pre> Output<pre><code>// get_entity prints out formatted information on entity\n\nENTITY NAME:                   user\nSTATUS:                        NO_STATUS\n-----------------------------------------------\n\nNAME                           VARIANT                        TYPE\navg_transactions               quickstart                     feature\nfraudulent                     quickstart                     label\nfraud_training                 quickstart                     training set\n-----------------------------------------------\n</code></pre> Input<pre><code>print(postgres)\n</code></pre> Output<pre><code>// get_entity returns the Entity object\n\nname: \"user\"\nfeatures {\n    name: \"avg_transactions\"\n    variant: \"quickstart\"\n}\nlabels {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n}\ntrainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n}\n</code></pre> Source code in <code>src/featureform/register.py</code> <pre><code>def get_entity(self, name, local=False):\n    \"\"\"Get an entity. Prints out information on entity, and all resources associated with the entity.\n\n    **Examples:**\n\n    ``` py title=\"Input\"\n    entity = rc.get_entity(\"user\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_entity prints out formatted information on entity\n\n    ENTITY NAME:                   user\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n\n    NAME                           VARIANT                        TYPE\n    avg_transactions               quickstart                     feature\n    fraudulent                     quickstart                     label\n    fraud_training                 quickstart                     training set\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(postgres)\n    ```\n\n    ``` json title=\"Output\"\n    // get_entity returns the Entity object\n\n    name: \"user\"\n    features {\n        name: \"avg_transactions\"\n        variant: \"quickstart\"\n    }\n    labels {\n        name: \"fraudulent\"\n        variant: \"quickstart\"\n    }\n    trainingsets {\n        name: \"fraud_training\"\n        variant: \"quickstart\"\n    }\n    ```\n    \"\"\"\n    return get_entity_info(self._stub, name)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.get_model","title":"<code>get_model(name, local=False)</code>","text":"<p>Get a model. Prints out information on model, and all resources associated with the model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of model to be retrieved</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Model</code> <p>Model</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_model(self, name, local=False) -&gt; Model:\n    \"\"\"Get a model. Prints out information on model, and all resources associated with the model.\n\n    Args:\n        name (str): Name of model to be retrieved\n\n    Returns:\n        model (Model): Model\n    \"\"\"\n    model = None\n    model_proto = get_resource_info(self._stub, \"model\", name)\n    if model_proto is not None:\n        model = Model(model_proto.name, description=\"\", tags=[], properties={})\n\n    return model\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.get_provider","title":"<code>get_provider(name, local=False)</code>","text":"<p>Get a provider. Prints out information on provider, and all resources associated with the provider.</p> <p>Examples:</p> Input<pre><code>postgres = client.get_provider(\"postgres-quickstart\")\n</code></pre> Output<pre><code>// get_provider prints out formatted information on provider\n\nNAME:                          postgres-quickstart\nDESCRIPTION:                   A Postgres deployment we created for the Featureform quickstart\nTYPE:                          POSTGRES_OFFLINE\nSOFTWARE:                      postgres\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nSOURCES:\nNAME                           VARIANT\ntransactions                   kaggle\naverage_user_transaction       quickstart\n-----------------------------------------------\nFEATURES:\nNAME                           VARIANT\n-----------------------------------------------\nLABELS:\nNAME                           VARIANT\nfraudulent                     quickstart\n-----------------------------------------------\nTRAINING SETS:\nNAME                           VARIANT\nfraud_training                 quickstart\n-----------------------------------------------\n</code></pre> Input<pre><code>print(postgres)\n</code></pre> Output<pre><code>// get_provider returns the Provider object\n\nname: \"postgres-quickstart\"\ndescription: \"A Postgres deployment we created for the Featureform quickstart\"\ntype: \"POSTGRES_OFFLINE\"\nsoftware: \"postgres\"\nserialized_config: \"{\"Host\": \"quickstart-postgres\",\n                    \"Port\": \"5432\",\n                    \"Username\": \"postgres\",\n                    \"Password\": \"password\",\n                    \"Database\": \"postgres\"}\"\nsources {\nname: \"transactions\"\nvariant: \"kaggle\"\n}\nsources {\nname: \"average_user_transaction\"\nvariant: \"quickstart\"\n}\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\nlabels {\nname: \"fraudulent\"\nvariant: \"quickstart\"\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>provider</code> <code>Provider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_provider(self, name, local=False):\n    \"\"\"Get a provider. Prints out information on provider, and all resources associated with the provider.\n\n    **Examples:**\n\n    ``` py title=\"Input\"\n    postgres = client.get_provider(\"postgres-quickstart\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_provider prints out formatted information on provider\n\n    NAME:                          postgres-quickstart\n    DESCRIPTION:                   A Postgres deployment we created for the Featureform quickstart\n    TYPE:                          POSTGRES_OFFLINE\n    SOFTWARE:                      postgres\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    SOURCES:\n    NAME                           VARIANT\n    transactions                   kaggle\n    average_user_transaction       quickstart\n    -----------------------------------------------\n    FEATURES:\n    NAME                           VARIANT\n    -----------------------------------------------\n    LABELS:\n    NAME                           VARIANT\n    fraudulent                     quickstart\n    -----------------------------------------------\n    TRAINING SETS:\n    NAME                           VARIANT\n    fraud_training                 quickstart\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(postgres)\n    ```\n\n    ``` json title=\"Output\"\n    // get_provider returns the Provider object\n\n    name: \"postgres-quickstart\"\n    description: \"A Postgres deployment we created for the Featureform quickstart\"\n    type: \"POSTGRES_OFFLINE\"\n    software: \"postgres\"\n    serialized_config: \"{\\\"Host\\\": \\\"quickstart-postgres\\\",\n                        \\\"Port\\\": \\\"5432\\\",\n                        \\\"Username\\\": \\\"postgres\\\",\n                        \\\"Password\\\": \\\"password\\\",\n                        \\\"Database\\\": \\\"postgres\\\"}\"\n    sources {\n    name: \"transactions\"\n    variant: \"kaggle\"\n    }\n    sources {\n    name: \"average_user_transaction\"\n    variant: \"quickstart\"\n    }\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    labels {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    }\n    ```\n\n    Args:\n        name (str): Name of provider to be retrieved\n\n    Returns:\n        provider (Provider): Provider\n    \"\"\"\n    return get_provider_info(self._stub, name)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.get_user","title":"<code>get_user(name, local=False)</code>","text":"<p>Get a user. Prints out name of user, and all resources associated with the user.</p> <p>Examples:</p> Input<pre><code>featureformer = rc.get_user(\"featureformer\")\n</code></pre> Output<pre><code>// get_user prints out formatted information on user\nUSER NAME:                     featureformer\n-----------------------------------------------\n\nNAME                           VARIANT                        TYPE\navg_transactions               quickstart                     feature\nfraudulent                     quickstart                     label\nfraud_training                 quickstart                     training set\ntransactions                   kaggle                         source\naverage_user_transaction       quickstart                     source\n-----------------------------------------------\n</code></pre> Input<pre><code>print(featureformer)\n</code></pre> Output<pre><code>// get_user returns the User object\n\nname: \"featureformer\"\nfeatures {\nname: \"avg_transactions\"\nvariant: \"quickstart\"\n}\nlabels {\nname: \"fraudulent\"\nvariant: \"quickstart\"\n}\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\nsources {\nname: \"transactions\"\nvariant: \"kaggle\"\n}\nsources {\nname: \"average_user_transaction\"\nvariant: \"quickstart\"\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of user to be retrieved</p> required <p>Returns:</p> Name Type Description <code>user</code> <code>User</code> <p>User</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_user(self, name, local=False):\n    \"\"\"Get a user. Prints out name of user, and all resources associated with the user.\n\n    **Examples:**\n\n    ``` py title=\"Input\"\n    featureformer = rc.get_user(\"featureformer\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_user prints out formatted information on user\n    USER NAME:                     featureformer\n    -----------------------------------------------\n\n    NAME                           VARIANT                        TYPE\n    avg_transactions               quickstart                     feature\n    fraudulent                     quickstart                     label\n    fraud_training                 quickstart                     training set\n    transactions                   kaggle                         source\n    average_user_transaction       quickstart                     source\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(featureformer)\n    ```\n\n    ``` json title=\"Output\"\n    // get_user returns the User object\n\n    name: \"featureformer\"\n    features {\n    name: \"avg_transactions\"\n    variant: \"quickstart\"\n    }\n    labels {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    }\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    sources {\n    name: \"transactions\"\n    variant: \"kaggle\"\n    }\n    sources {\n    name: \"average_user_transaction\"\n    variant: \"quickstart\"\n    }\n    ```\n\n    Args:\n        name (str): Name of user to be retrieved\n\n    Returns:\n        user (User): User\n    \"\"\"\n    return get_user_info(self._stub, name)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_entities","title":"<code>list_entities(local=False)</code>","text":"<p>List all entities. Prints a list of all entities.</p> <p>Examples: Input<pre><code>entities = rc.list_entities()\n</code></pre></p> Output<pre><code>// list_entities prints out formatted information on all entities\n\nNAME                           STATUS\nuser                           CREATED\ntransaction                    CREATED\n</code></pre> Input<pre><code>print(features_list)\n</code></pre> Output<pre><code>// list_entities returns a list of Entity objects\n\n[name: \"user\"\nfeatures {\nname: \"avg_transactions\"\nvariant: \"quickstart\"\n}\nfeatures {\nname: \"avg_transactions\"\nvariant: \"production\"\n}\nfeatures {\nname: \"user_age\"\nvariant: \"quickstart\"\n}\nlabels {\nname: \"fraudulent\"\nvariant: \"quickstart\"\n}\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\n,\nname: \"transaction\"\nfeatures {\nname: \"amount_spent\"\nvariant: \"production\"\n}\n]\n</code></pre> <p>Returns:</p> Name Type Description <code>entities</code> <code>List[Entity]</code> <p>List of Entity Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_entities(self, local=False):\n    \"\"\"List all entities. Prints a list of all entities.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    entities = rc.list_entities()\n    ```\n\n    ``` json title=\"Output\"\n    // list_entities prints out formatted information on all entities\n\n    NAME                           STATUS\n    user                           CREATED\n    transaction                    CREATED\n    ```\n\n    ``` py title=\"Input\"\n    print(features_list)\n    ```\n\n    ``` json title=\"Output\"\n    // list_entities returns a list of Entity objects\n\n    [name: \"user\"\n    features {\n    name: \"avg_transactions\"\n    variant: \"quickstart\"\n    }\n    features {\n    name: \"avg_transactions\"\n    variant: \"production\"\n    }\n    features {\n    name: \"user_age\"\n    variant: \"quickstart\"\n    }\n    labels {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    }\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    ,\n    name: \"transaction\"\n    features {\n    name: \"amount_spent\"\n    variant: \"production\"\n    }\n    ]\n    ```\n\n    Returns:\n        entities (List[Entity]): List of Entity Objects\n    \"\"\"\n    return list_name_status(self._stub, \"entity\")\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_features","title":"<code>list_features(local=False)</code>","text":"<p>List all features.</p> <p>Examples: Input<pre><code>features_list = rc.list_features()\n</code></pre></p> Output<pre><code>// list_features prints out formatted information on all features\n\nNAME                           VARIANT                        STATUS\nuser_age                       quickstart (default)           READY\navg_transactions               quickstart (default)           READY\navg_transactions               production                     CREATED\n</code></pre> Input<pre><code>print(features_list)\n</code></pre> Output<pre><code>// list_features returns a list of Feature objects\n\n[name: \"user_age\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\n, name: \"avg_transactions\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\nvariants: \"production\"\n]\n</code></pre> <p>Returns:</p> Name Type Description <code>features</code> <code>List[Feature]</code> <p>List of Feature Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_features(self, local=False):\n    \"\"\"List all features.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    features_list = rc.list_features()\n    ```\n\n    ``` json title=\"Output\"\n    // list_features prints out formatted information on all features\n\n    NAME                           VARIANT                        STATUS\n    user_age                       quickstart (default)           READY\n    avg_transactions               quickstart (default)           READY\n    avg_transactions               production                     CREATED\n    ```\n\n    ``` py title=\"Input\"\n    print(features_list)\n    ```\n\n    ``` json title=\"Output\"\n    // list_features returns a list of Feature objects\n\n    [name: \"user_age\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    , name: \"avg_transactions\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    variants: \"production\"\n    ]\n    ```\n\n    Returns:\n        features (List[Feature]): List of Feature Objects\n    \"\"\"\n    return list_name_variant_status(self._stub, \"feature\")\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_labels","title":"<code>list_labels(local=False)</code>","text":"<p>List all labels.</p> <p>Examples: Input<pre><code>features_list = rc.list_labels()\n</code></pre></p> Output<pre><code>// list_labels prints out formatted information on all labels\n\nNAME                           VARIANT                        STATUS\nuser_age                       quickstart (default)           READY\navg_transactions               quickstart (default)           READY\navg_transactions               production                     CREATED\n</code></pre> Input<pre><code>print(label_list)\n</code></pre> Output<pre><code>// list_features returns a list of Feature objects\n\n[name: \"user_age\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\n, name: \"avg_transactions\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\nvariants: \"production\"\n]\n</code></pre> <p>Returns:</p> Name Type Description <code>labels</code> <code>List[Label]</code> <p>List of Label Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_labels(self, local=False):\n    \"\"\"List all labels.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    features_list = rc.list_labels()\n    ```\n\n    ``` json title=\"Output\"\n    // list_labels prints out formatted information on all labels\n\n    NAME                           VARIANT                        STATUS\n    user_age                       quickstart (default)           READY\n    avg_transactions               quickstart (default)           READY\n    avg_transactions               production                     CREATED\n    ```\n\n    ``` py title=\"Input\"\n    print(label_list)\n    ```\n\n    ``` json title=\"Output\"\n    // list_features returns a list of Feature objects\n\n    [name: \"user_age\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    , name: \"avg_transactions\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    variants: \"production\"\n    ]\n    ```\n\n    Returns:\n        labels (List[Label]): List of Label Objects\n    \"\"\"\n    return list_name_variant_status(self._stub, \"label\")\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_models","title":"<code>list_models(local=False)</code>","text":"<p>List all models. Prints a list of all models.</p> <p>Returns:</p> Name Type Description <code>models</code> <code>List[Model]</code> <p>List of Model Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_models(self, local=False) -&gt; List[Model]:\n    \"\"\"List all models. Prints a list of all models.\n\n    Returns:\n        models (List[Model]): List of Model Objects\n    \"\"\"\n    model_protos = list_name(self._stub, \"model\")\n    # TODO: apply values from proto\n    models = [Model(proto.name, tags=[], properties={}) for proto in model_protos]\n\n    return models\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_providers","title":"<code>list_providers(local=False)</code>","text":"<p>List all providers. Prints a list of all providers.</p> <p>Examples: Input<pre><code>providers_list = rc.list_providers()\n</code></pre></p> Output<pre><code>// list_providers prints out formatted information on all providers\n\nNAME                           STATUS                         DESCRIPTION\nredis-quickstart               CREATED                      A Redis deployment we created for the Featureform quickstart\npostgres-quickstart            CREATED                      A Postgres deployment we created for the Featureform quickst\n</code></pre> Input<pre><code>print(providers_list)\n</code></pre> Output<pre><code>// list_providers returns a list of Providers objects\n\n[name: \"redis-quickstart\"\ndescription: \"A Redis deployment we created for the Featureform quickstart\"\ntype: \"REDIS_ONLINE\"\nsoftware: \"redis\"\nserialized_config: \"{\"Addr\": \"quickstart-redis:6379\", \"Password\": \"\", \"DB\": 0}\"\nfeatures {\nname: \"avg_transactions\"\nvariant: \"quickstart\"\n}\nfeatures {\nname: \"avg_transactions\"\nvariant: \"production\"\n}\nfeatures {\nname: \"user_age\"\nvariant: \"quickstart\"\n}\n, name: \"postgres-quickstart\"\ndescription: \"A Postgres deployment we created for the Featureform quickstart\"\ntype: \"POSTGRES_OFFLINE\"\nsoftware: \"postgres\"\nserialized_config: \"{\"Host\": \"quickstart-postgres\", \"Port\": \"5432\", \"Username\": \"postgres\", \"Password\": \"password\", \"Database\": \"postgres\"}\"\nsources {\nname: \"transactions\"\nvariant: \"kaggle\"\n}\nsources {\nname: \"average_user_transaction\"\nvariant: \"quickstart\"\n}\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\nlabels {\nname: \"fraudulent\"\nvariant: \"quickstart\"\n}\n]\n</code></pre> <p>Returns:</p> Name Type Description <code>providers</code> <code>List[Provider]</code> <p>List of Provider Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_providers(self, local=False):\n    \"\"\"List all providers. Prints a list of all providers.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    providers_list = rc.list_providers()\n    ```\n\n    ``` json title=\"Output\"\n    // list_providers prints out formatted information on all providers\n\n    NAME                           STATUS                         DESCRIPTION\n    redis-quickstart               CREATED                      A Redis deployment we created for the Featureform quickstart\n    postgres-quickstart            CREATED                      A Postgres deployment we created for the Featureform quickst\n    ```\n\n    ``` py title=\"Input\"\n    print(providers_list)\n    ```\n\n    ``` json title=\"Output\"\n    // list_providers returns a list of Providers objects\n\n    [name: \"redis-quickstart\"\n    description: \"A Redis deployment we created for the Featureform quickstart\"\n    type: \"REDIS_ONLINE\"\n    software: \"redis\"\n    serialized_config: \"{\\\"Addr\\\": \\\"quickstart-redis:6379\\\", \\\"Password\\\": \\\"\\\", \\\"DB\\\": 0}\"\n    features {\n    name: \"avg_transactions\"\n    variant: \"quickstart\"\n    }\n    features {\n    name: \"avg_transactions\"\n    variant: \"production\"\n    }\n    features {\n    name: \"user_age\"\n    variant: \"quickstart\"\n    }\n    , name: \"postgres-quickstart\"\n    description: \"A Postgres deployment we created for the Featureform quickstart\"\n    type: \"POSTGRES_OFFLINE\"\n    software: \"postgres\"\n    serialized_config: \"{\\\"Host\\\": \\\"quickstart-postgres\\\", \\\"Port\\\": \\\"5432\\\", \\\"Username\\\": \\\"postgres\\\", \\\"Password\\\": \\\"password\\\", \\\"Database\\\": \\\"postgres\\\"}\"\n    sources {\n    name: \"transactions\"\n    variant: \"kaggle\"\n    }\n    sources {\n    name: \"average_user_transaction\"\n    variant: \"quickstart\"\n    }\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    labels {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    }\n    ]\n    ```\n\n    Returns:\n        providers (List[Provider]): List of Provider Objects\n    \"\"\"\n    return list_name_status_desc(self._stub, \"provider\")\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_sources","title":"<code>list_sources(local=False)</code>","text":"<p>List all sources. Prints a list of all sources.</p> <p>Examples: Input<pre><code>sources_list = rc.list_sources()\n</code></pre></p> Output<pre><code>// list_sources prints out formatted information on all sources\n\nNAME                           VARIANT                        STATUS                         DESCRIPTION\naverage_user_transaction       quickstart (default)           NO_STATUS                      the average transaction amount for a user\ntransactions                   kaggle (default)               NO_STATUS                      Fraud Dataset From Kaggle\n</code></pre> Input<pre><code>print(sources_list)\n</code></pre> Output<pre><code>// list_sources returns a list of Source objects\n\n[name: \"average_user_transaction\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\n, name: \"transactions\"\ndefault_variant: \"kaggle\"\nvariants: \"kaggle\"\n]\n</code></pre> <p>Returns:</p> Name Type Description <code>sources</code> <code>List[Source]</code> <p>List of Source Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_sources(self, local=False):\n    \"\"\"List all sources. Prints a list of all sources.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    sources_list = rc.list_sources()\n    ```\n\n    ``` json title=\"Output\"\n    // list_sources prints out formatted information on all sources\n\n    NAME                           VARIANT                        STATUS                         DESCRIPTION\n    average_user_transaction       quickstart (default)           NO_STATUS                      the average transaction amount for a user\n    transactions                   kaggle (default)               NO_STATUS                      Fraud Dataset From Kaggle\n    ```\n\n    ``` py title=\"Input\"\n    print(sources_list)\n    ```\n\n    ``` json title=\"Output\"\n    // list_sources returns a list of Source objects\n\n    [name: \"average_user_transaction\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    , name: \"transactions\"\n    default_variant: \"kaggle\"\n    variants: \"kaggle\"\n    ]\n    ```\n\n    Returns:\n        sources (List[Source]): List of Source Objects\n    \"\"\"\n    return list_name_variant_status_desc(self._stub, \"source\")\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_training_sets","title":"<code>list_training_sets(local=False)</code>","text":"<p>List all training sets. Prints a list of all training sets.</p> <p>Examples: Input<pre><code>training_sets_list = rc.list_training_sets()\n</code></pre></p> Output<pre><code>// list_training_sets prints out formatted information on all training sets\n\nNAME                           VARIANT                        STATUS                         DESCRIPTION\nfraud_training                 quickstart (default)           READY                          Training set for fraud detection.\nfraud_training                 v2                             CREATED                        Improved training set for fraud detection.\nrecommender                    v1 (default)                   CREATED                        Training set for recommender system.\n</code></pre> Input<pre><code>print(training_sets_list)\n</code></pre> Output<pre><code>// list_training_sets returns a list of TrainingSet objects\n\n[name: \"fraud_training\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\", \"v2\",\nname: \"recommender\"\ndefault_variant: \"v1\"\nvariants: \"v1\"\n]\n</code></pre> <p>Returns:</p> Name Type Description <code>training_sets</code> <code>List[TrainingSet]</code> <p>List of TrainingSet Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_training_sets(self, local=False):\n    \"\"\"List all training sets. Prints a list of all training sets.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    training_sets_list = rc.list_training_sets()\n    ```\n\n    ``` json title=\"Output\"\n    // list_training_sets prints out formatted information on all training sets\n\n    NAME                           VARIANT                        STATUS                         DESCRIPTION\n    fraud_training                 quickstart (default)           READY                          Training set for fraud detection.\n    fraud_training                 v2                             CREATED                        Improved training set for fraud detection.\n    recommender                    v1 (default)                   CREATED                        Training set for recommender system.\n    ```\n\n    ``` py title=\"Input\"\n    print(training_sets_list)\n    ```\n\n    ``` json title=\"Output\"\n    // list_training_sets returns a list of TrainingSet objects\n\n    [name: \"fraud_training\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\", \"v2\",\n    name: \"recommender\"\n    default_variant: \"v1\"\n    variants: \"v1\"\n    ]\n    ```\n\n    Returns:\n        training_sets (List[TrainingSet]): List of TrainingSet Objects\n    \"\"\"\n    return list_name_variant_status_desc(self._stub, \"training-set\")\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.list_users","title":"<code>list_users(local=False)</code>","text":"<p>List all users. Prints a list of all users.</p> <p>Examples: Input<pre><code>users_list = rc.list_users()\n</code></pre></p> Output<pre><code>// list_users prints out formatted information on all users\n\nNAME                           STATUS\nfeatureformer                  NO_STATUS\nfeatureformers_friend          CREATED\n</code></pre> Input<pre><code>print(features_list)\n</code></pre> Output<pre><code>// list_features returns a list of Feature objects\n\n[name: \"featureformer\"\nfeatures {\nname: \"avg_transactions\"\nvariant: \"quickstart\"\n}\nlabels {\nname: \"fraudulent\"\nvariant: \"quickstart\"\n}\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\nsources {\nname: \"transactions\"\nvariant: \"kaggle\"\n}\nsources {\nname: \"average_user_transaction\"\nvariant: \"quickstart\"\n},\nname: \"featureformers_friend\"\nfeatures {\nname: \"user_age\"\nvariant: \"production\"\n}\nsources {\nname: \"user_profiles\"\nvariant: \"production\"\n}\n]\n</code></pre> <p>Returns:</p> Name Type Description <code>users</code> <code>List[User]</code> <p>List of User Objects</p> Source code in <code>src/featureform/register.py</code> <pre><code>def list_users(self, local=False):\n    \"\"\"List all users. Prints a list of all users.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    users_list = rc.list_users()\n    ```\n\n    ``` json title=\"Output\"\n    // list_users prints out formatted information on all users\n\n    NAME                           STATUS\n    featureformer                  NO_STATUS\n    featureformers_friend          CREATED\n    ```\n\n    ``` py title=\"Input\"\n    print(features_list)\n    ```\n\n    ``` json title=\"Output\"\n    // list_features returns a list of Feature objects\n\n    [name: \"featureformer\"\n    features {\n    name: \"avg_transactions\"\n    variant: \"quickstart\"\n    }\n    labels {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    }\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    sources {\n    name: \"transactions\"\n    variant: \"kaggle\"\n    }\n    sources {\n    name: \"average_user_transaction\"\n    variant: \"quickstart\"\n    },\n    name: \"featureformers_friend\"\n    features {\n    name: \"user_age\"\n    variant: \"production\"\n    }\n    sources {\n    name: \"user_profiles\"\n    variant: \"production\"\n    }\n    ]\n    ```\n\n    Returns:\n        users (List[User]): List of User Objects\n    \"\"\"\n    return list_name_status(self._stub, \"user\")\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.print_feature","title":"<code>print_feature(name, variant=None, local=False)</code>","text":"<p>Get a feature. Prints out information on feature, and all variants associated with the feature. If variant is included, print information on that specific variant and all resources associated with it.</p> <p>Examples:</p> Input<pre><code>avg_transactions = rc.get_feature(\"avg_transactions\")\n</code></pre> Output<pre><code>// get_feature prints out formatted information on feature\n\nNAME:                          avg_transactions\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nVARIANTS:\nquickstart                     default\n-----------------------------------------------\n</code></pre> Input<pre><code>print(avg_transactions)\n</code></pre> Output<pre><code>// get_feature returns the Feature object\n\nname: \"avg_transactions\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\n</code></pre> Input<pre><code>avg_transactions_variant = ff.get_feature(\"avg_transactions\", \"quickstart\")\n</code></pre> Output<pre><code>// get_feature with variant provided prints out formatted information on feature variant\n\nNAME:                          avg_transactions\nVARIANT:                       quickstart\nTYPE:                          float32\nENTITY:                        user\nOWNER:                         featureformer\nPROVIDER:                      redis-quickstart\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nSOURCE:\nNAME                           VARIANT\naverage_user_transaction       quickstart\n-----------------------------------------------\nTRAINING SETS:\nNAME                           VARIANT\nfraud_training                 quickstart\n-----------------------------------------------\n</code></pre> Input<pre><code>print(avg_transactions_variant)\n</code></pre> Output<pre><code>// get_feature returns the FeatureVariant object\n\nname: \"avg_transactions\"\nvariant: \"quickstart\"\nsource {\nname: \"average_user_transaction\"\nvariant: \"quickstart\"\n}\ntype: \"float32\"\nentity: \"user\"\ncreated {\nseconds: 1658168552\nnanos: 142461900\n}\nowner: \"featureformer\"\nprovider: \"redis-quickstart\"\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\ncolumns {\nentity: \"user_id\"\nvalue: \"avg_transaction_amt\"\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of feature to be retrieved</p> required <code>variant</code> <code>str</code> <p>Name of variant of feature</p> <code>None</code> <p>Returns:</p> Name Type Description <code>feature</code> <code>Union[Feature, FeatureVariant]</code> <p>Feature or FeatureVariant</p> Source code in <code>src/featureform/register.py</code> <pre><code>def print_feature(self, name, variant=None, local=False):\n    \"\"\"Get a feature. Prints out information on feature, and all variants associated with the feature. If variant is included, print information on that specific variant and all resources associated with it.\n\n    **Examples:**\n\n    ``` py title=\"Input\"\n    avg_transactions = rc.get_feature(\"avg_transactions\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_feature prints out formatted information on feature\n\n    NAME:                          avg_transactions\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    VARIANTS:\n    quickstart                     default\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(avg_transactions)\n    ```\n\n    ``` json title=\"Output\"\n    // get_feature returns the Feature object\n\n    name: \"avg_transactions\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    ```\n\n    ``` py title=\"Input\"\n    avg_transactions_variant = ff.get_feature(\"avg_transactions\", \"quickstart\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_feature with variant provided prints out formatted information on feature variant\n\n    NAME:                          avg_transactions\n    VARIANT:                       quickstart\n    TYPE:                          float32\n    ENTITY:                        user\n    OWNER:                         featureformer\n    PROVIDER:                      redis-quickstart\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    SOURCE:\n    NAME                           VARIANT\n    average_user_transaction       quickstart\n    -----------------------------------------------\n    TRAINING SETS:\n    NAME                           VARIANT\n    fraud_training                 quickstart\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(avg_transactions_variant)\n    ```\n\n    ``` json title=\"Output\"\n    // get_feature returns the FeatureVariant object\n\n    name: \"avg_transactions\"\n    variant: \"quickstart\"\n    source {\n    name: \"average_user_transaction\"\n    variant: \"quickstart\"\n    }\n    type: \"float32\"\n    entity: \"user\"\n    created {\n    seconds: 1658168552\n    nanos: 142461900\n    }\n    owner: \"featureformer\"\n    provider: \"redis-quickstart\"\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    columns {\n    entity: \"user_id\"\n    value: \"avg_transaction_amt\"\n    }\n    ```\n\n    Args:\n        name (str): Name of feature to be retrieved\n        variant (str): Name of variant of feature\n\n    Returns:\n        feature (Union[Feature, FeatureVariant]): Feature or FeatureVariant\n    \"\"\"\n    if not variant:\n        return get_resource_info(self._stub, \"feature\", name)\n    return get_feature_variant_info(self._stub, name, variant)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.print_label","title":"<code>print_label(name, variant=None, local=False)</code>","text":"<p>Get a label. Prints out information on label, and all variants associated with the label. If variant is included, print information on that specific variant and all resources associated with it.</p> <p>Examples:</p> Input<pre><code>fraudulent = rc.get_label(\"fraudulent\")\n</code></pre> Output<pre><code>// get_label prints out formatted information on label\n\nNAME:                          fraudulent\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nVARIANTS:\nquickstart                     default\n-----------------------------------------------\n</code></pre> Input<pre><code>print(fraudulent)\n</code></pre> Output<pre><code>// get_label returns the Label object\n\nname: \"fraudulent\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\n</code></pre> Input<pre><code>fraudulent_variant = ff.get_label(\"fraudulent\", \"quickstart\")\n</code></pre> Output<pre><code>// get_label with variant provided prints out formatted information on label variant\n\nNAME:                          fraudulent\nVARIANT:                       quickstart\nTYPE:                          bool\nENTITY:                        user\nOWNER:                         featureformer\nPROVIDER:                      postgres-quickstart\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nSOURCE:\nNAME                           VARIANT\ntransactions                   kaggle\n-----------------------------------------------\nTRAINING SETS:\nNAME                           VARIANT\nfraud_training                 quickstart\n-----------------------------------------------\n</code></pre> Input<pre><code>print(fraudulent_variant)\n</code></pre> Output<pre><code>// get_label returns the LabelVariant object\n\nname: \"fraudulent\"\nvariant: \"quickstart\"\ntype: \"bool\"\nsource {\nname: \"transactions\"\nvariant: \"kaggle\"\n}\nentity: \"user\"\ncreated {\nseconds: 1658168552\nnanos: 154924300\n}\nowner: \"featureformer\"\nprovider: \"postgres-quickstart\"\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\ncolumns {\nentity: \"customerid\"\nvalue: \"isfraud\"\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of label to be retrieved</p> required <code>variant</code> <code>str</code> <p>Name of variant of label</p> <code>None</code> <p>Returns:</p> Name Type Description <code>label</code> <code>Union[label, LabelVariant]</code> <p>Label or LabelVariant</p> Source code in <code>src/featureform/register.py</code> <pre><code>def print_label(self, name, variant=None, local=False):\n    \"\"\"Get a label. Prints out information on label, and all variants associated with the label. If variant is included, print information on that specific variant and all resources associated with it.\n\n    **Examples:**\n\n    ``` py title=\"Input\"\n    fraudulent = rc.get_label(\"fraudulent\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_label prints out formatted information on label\n\n    NAME:                          fraudulent\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    VARIANTS:\n    quickstart                     default\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(fraudulent)\n    ```\n\n    ``` json title=\"Output\"\n    // get_label returns the Label object\n\n    name: \"fraudulent\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    ```\n\n    ``` py title=\"Input\"\n    fraudulent_variant = ff.get_label(\"fraudulent\", \"quickstart\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_label with variant provided prints out formatted information on label variant\n\n    NAME:                          fraudulent\n    VARIANT:                       quickstart\n    TYPE:                          bool\n    ENTITY:                        user\n    OWNER:                         featureformer\n    PROVIDER:                      postgres-quickstart\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    SOURCE:\n    NAME                           VARIANT\n    transactions                   kaggle\n    -----------------------------------------------\n    TRAINING SETS:\n    NAME                           VARIANT\n    fraud_training                 quickstart\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(fraudulent_variant)\n    ```\n\n    ``` json title=\"Output\"\n    // get_label returns the LabelVariant object\n\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    type: \"bool\"\n    source {\n    name: \"transactions\"\n    variant: \"kaggle\"\n    }\n    entity: \"user\"\n    created {\n    seconds: 1658168552\n    nanos: 154924300\n    }\n    owner: \"featureformer\"\n    provider: \"postgres-quickstart\"\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    columns {\n    entity: \"customerid\"\n    value: \"isfraud\"\n    }\n    ```\n\n    Args:\n        name (str): Name of label to be retrieved\n        variant (str): Name of variant of label\n\n    Returns:\n        label (Union[label, LabelVariant]): Label or LabelVariant\n    \"\"\"\n    if not variant:\n        return get_resource_info(self._stub, \"label\", name)\n    return get_label_variant_info(self._stub, name, variant)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.print_source","title":"<code>print_source(name, variant=None, local=False)</code>","text":"<p>Get a source. Prints out information on source, and all variants associated with the source. If variant is included, print information on that specific variant and all resources associated with it.</p> <p>Examples:</p> Input<pre><code>transactions = rc.get_transactions(\"transactions\")\n</code></pre> Output<pre><code>// get_source prints out formatted information on source\n\nNAME:                          transactions\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nVARIANTS:\nkaggle                         default\n-----------------------------------------------\n</code></pre> Input<pre><code>print(transactions)\n</code></pre> Output<pre><code>// get_source returns the Source object\n\nname: \"transactions\"\ndefault_variant: \"kaggle\"\nvariants: \"kaggle\"\n</code></pre> Input<pre><code>transactions_variant = rc.get_source(\"transactions\", \"kaggle\")\n</code></pre> Output<pre><code>// get_source with variant provided prints out formatted information on source variant\n\nNAME:                          transactions\nVARIANT:                       kaggle\nOWNER:                         featureformer\nDESCRIPTION:                   Fraud Dataset From Kaggle\nPROVIDER:                      postgres-quickstart\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nDEFINITION:\nTRANSFORMATION\n\n-----------------------------------------------\nSOURCES\nNAME                           VARIANT\n-----------------------------------------------\nPRIMARY DATA\nTransactions\nFEATURES:\nNAME                           VARIANT\n-----------------------------------------------\nLABELS:\nNAME                           VARIANT\nfraudulent                     quickstart\n-----------------------------------------------\nTRAINING SETS:\nNAME                           VARIANT\nfraud_training                 quickstart\n-----------------------------------------------\n</code></pre> Input<pre><code>print(transactions_variant)\n</code></pre> Output<pre><code>// get_source returns the SourceVariant object\n\nname: \"transactions\"\nvariant: \"kaggle\"\nowner: \"featureformer\"\ndescription: \"Fraud Dataset From Kaggle\"\nprovider: \"postgres-quickstart\"\ncreated {\nseconds: 1658168552\nnanos: 128768000\n}\ntrainingsets {\nname: \"fraud_training\"\nvariant: \"quickstart\"\n}\nlabels {\nname: \"fraudulent\"\nvariant: \"quickstart\"\n}\nprimaryData {\ntable {\n    name: \"Transactions\"\n}\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source to be retrieved</p> required <code>variant</code> <code>str</code> <p>Name of variant of source</p> <code>None</code> <p>Returns:</p> Name Type Description <code>source</code> <code>Union[Source, SourceVariant]</code> <p>Source or SourceVariant</p> Source code in <code>src/featureform/register.py</code> <pre><code>def print_source(self, name, variant=None, local=False):\n    \"\"\"Get a source. Prints out information on source, and all variants associated with the source. If variant is included, print information on that specific variant and all resources associated with it.\n\n    **Examples:**\n\n    ``` py title=\"Input\"\n    transactions = rc.get_transactions(\"transactions\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_source prints out formatted information on source\n\n    NAME:                          transactions\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    VARIANTS:\n    kaggle                         default\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(transactions)\n    ```\n\n    ``` json title=\"Output\"\n    // get_source returns the Source object\n\n    name: \"transactions\"\n    default_variant: \"kaggle\"\n    variants: \"kaggle\"\n    ```\n\n    ``` py title=\"Input\"\n    transactions_variant = rc.get_source(\"transactions\", \"kaggle\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_source with variant provided prints out formatted information on source variant\n\n    NAME:                          transactions\n    VARIANT:                       kaggle\n    OWNER:                         featureformer\n    DESCRIPTION:                   Fraud Dataset From Kaggle\n    PROVIDER:                      postgres-quickstart\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    DEFINITION:\n    TRANSFORMATION\n\n    -----------------------------------------------\n    SOURCES\n    NAME                           VARIANT\n    -----------------------------------------------\n    PRIMARY DATA\n    Transactions\n    FEATURES:\n    NAME                           VARIANT\n    -----------------------------------------------\n    LABELS:\n    NAME                           VARIANT\n    fraudulent                     quickstart\n    -----------------------------------------------\n    TRAINING SETS:\n    NAME                           VARIANT\n    fraud_training                 quickstart\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(transactions_variant)\n    ```\n\n    ``` json title=\"Output\"\n    // get_source returns the SourceVariant object\n\n    name: \"transactions\"\n    variant: \"kaggle\"\n    owner: \"featureformer\"\n    description: \"Fraud Dataset From Kaggle\"\n    provider: \"postgres-quickstart\"\n    created {\n    seconds: 1658168552\n    nanos: 128768000\n    }\n    trainingsets {\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    }\n    labels {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    }\n    primaryData {\n    table {\n        name: \"Transactions\"\n    }\n    }\n    ```\n\n    Args:\n        name (str): Name of source to be retrieved\n        variant (str): Name of variant of source\n\n    Returns:\n        source (Union[Source, SourceVariant]): Source or SourceVariant\n    \"\"\"\n    if not variant:\n        return get_resource_info(self._stub, \"source\", name)\n    return get_source_variant_info(self._stub, name, variant)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.print_training_set","title":"<code>print_training_set(name, variant=None, local=False)</code>","text":"<p>Get a training set. Prints out information on training set, and all variants associated with the training set. If variant is included, print information on that specific variant and all resources associated with it.</p> <p>Examples:</p> Input<pre><code>fraud_training = rc.get_training_set(\"fraud_training\")\n</code></pre> Output<pre><code>// get_training_set prints out formatted information on training set\n\nNAME:                          fraud_training\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nVARIANTS:\nquickstart                     default\n-----------------------------------------------\n</code></pre> Input<pre><code>print(fraud_training)\n</code></pre> Output<pre><code>// get_training_set returns the TrainingSet object\n\nname: \"fraud_training\"\ndefault_variant: \"quickstart\"\nvariants: \"quickstart\"\n</code></pre> Input<pre><code>fraudulent_variant = ff.get_training set(\"fraudulent\", \"quickstart\")\n</code></pre> Output<pre><code>// get_training_set with variant provided prints out formatted information on training set variant\n\nNAME:                          fraud_training\nVARIANT:                       quickstart\nOWNER:                         featureformer\nPROVIDER:                      postgres-quickstart\nSTATUS:                        NO_STATUS\n-----------------------------------------------\nLABEL:\nNAME                           VARIANT\nfraudulent                     quickstart\n-----------------------------------------------\nFEATURES:\nNAME                           VARIANT\navg_transactions               quickstart\n-----------------------------------------------\n</code></pre> Input<pre><code>print(fraudulent_variant)\n</code></pre> Output<pre><code>// get_training_set returns the TrainingSetVariant object\n\nname: \"fraud_training\"\nvariant: \"quickstart\"\nowner: \"featureformer\"\ncreated {\nseconds: 1658168552\nnanos: 157934800\n}\nprovider: \"postgres-quickstart\"\nfeatures {\nname: \"avg_transactions\"\nvariant: \"quickstart\"\n}\nlabel {\nname: \"fraudulent\"\nvariant: \"quickstart\"\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of training set to be retrieved</p> required <code>variant</code> <code>str</code> <p>Name of variant of training set</p> <code>None</code> <p>Returns:</p> Name Type Description <code>training_set</code> <code>Union[TrainingSet, TrainingSetVariant]</code> <p>TrainingSet or TrainingSetVariant</p> Source code in <code>src/featureform/register.py</code> <pre><code>def print_training_set(self, name, variant=None, local=False):\n    \"\"\"Get a training set. Prints out information on training set, and all variants associated with the training set. If variant is included, print information on that specific variant and all resources associated with it.\n\n    **Examples:**\n\n    ``` py title=\"Input\"\n    fraud_training = rc.get_training_set(\"fraud_training\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_training_set prints out formatted information on training set\n\n    NAME:                          fraud_training\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    VARIANTS:\n    quickstart                     default\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(fraud_training)\n    ```\n\n    ``` json title=\"Output\"\n    // get_training_set returns the TrainingSet object\n\n    name: \"fraud_training\"\n    default_variant: \"quickstart\"\n    variants: \"quickstart\"\n    ```\n\n    ``` py title=\"Input\"\n    fraudulent_variant = ff.get_training set(\"fraudulent\", \"quickstart\")\n    ```\n\n    ``` json title=\"Output\"\n    // get_training_set with variant provided prints out formatted information on training set variant\n\n    NAME:                          fraud_training\n    VARIANT:                       quickstart\n    OWNER:                         featureformer\n    PROVIDER:                      postgres-quickstart\n    STATUS:                        NO_STATUS\n    -----------------------------------------------\n    LABEL:\n    NAME                           VARIANT\n    fraudulent                     quickstart\n    -----------------------------------------------\n    FEATURES:\n    NAME                           VARIANT\n    avg_transactions               quickstart\n    -----------------------------------------------\n    ```\n\n    ``` py title=\"Input\"\n    print(fraudulent_variant)\n    ```\n\n    ``` json title=\"Output\"\n    // get_training_set returns the TrainingSetVariant object\n\n    name: \"fraud_training\"\n    variant: \"quickstart\"\n    owner: \"featureformer\"\n    created {\n    seconds: 1658168552\n    nanos: 157934800\n    }\n    provider: \"postgres-quickstart\"\n    features {\n    name: \"avg_transactions\"\n    variant: \"quickstart\"\n    }\n    label {\n    name: \"fraudulent\"\n    variant: \"quickstart\"\n    }\n    ```\n\n    Args:\n        name (str): Name of training set to be retrieved\n        variant (str): Name of variant of training set\n\n    Returns:\n        training_set (Union[TrainingSet, TrainingSetVariant]): TrainingSet or TrainingSetVariant\n    \"\"\"\n    if not variant:\n        return get_resource_info(self._stub, \"training-set\", name)\n    return get_training_set_variant_info(self._stub, name, variant)\n</code></pre>"},{"location":"register/#featureform.register.ResourceClient.search","title":"<code>search(raw_query, local=False)</code>","text":"<p>Search for registered resources. Prints a list of results.</p> <p>Examples: Input<pre><code>providers_list = rc.search(\"transact\")\n</code></pre></p> Output<pre><code>// search prints out formatted information on all matches\n\nNAME                           VARIANT            TYPE\navg_transactions               default            Source\n</code></pre> Source code in <code>src/featureform/register.py</code> <pre><code>def search(self, raw_query, local=False):\n    \"\"\"Search for registered resources. Prints a list of results.\n\n    **Examples:**\n    ``` py title=\"Input\"\n    providers_list = rc.search(\"transact\")\n    ```\n\n    ``` json title=\"Output\"\n    // search prints out formatted information on all matches\n\n    NAME                           VARIANT            TYPE\n    avg_transactions               default            Source\n    ```\n    \"\"\"\n    if type(raw_query) != str or len(raw_query) == 0:\n        raise Exception(\"query must be string and cannot be empty\")\n    processed_query = raw_query.translate({ord(i): None for i in \".,-@!*#\"})\n    return search(processed_query, self._host)\n</code></pre>"},{"location":"register/#featureform.register.Registrar","title":"<code>featureform.register.Registrar</code>","text":"<p>These functions are used to register new resources and retrieving existing resources. Retrieved resources can be used to register additional resources.</p> definitions.py<pre><code>import featureform as ff\n\n# e.g. registering a new provider\nredis = ff.register_redis(\n    name=\"redis-quickstart\",\n    host=\"quickstart-redis\",  # The internal dns name for redis\n    port=6379,\n    description=\"A Redis deployment we created for the Featureform quickstart\"\n)\n</code></pre> Source code in <code>src/featureform/register.py</code> <pre><code>class Registrar:\n    \"\"\"These functions are used to register new resources and retrieving existing resources.\n    Retrieved resources can be used to register additional resources.\n\n    ``` py title=\"definitions.py\"\n    import featureform as ff\n\n    # e.g. registering a new provider\n    redis = ff.register_redis(\n        name=\"redis-quickstart\",\n        host=\"quickstart-redis\",  # The internal dns name for redis\n        port=6379,\n        description=\"A Redis deployment we created for the Featureform quickstart\"\n    )\n    ```\n    \"\"\"\n\n    def __init__(self):\n        self.__state = ResourceState()\n        self.__resources = []\n        self.__default_owner = \"\"\n        self.__variant_prefix = \"\"\n        if feature_flag.is_enabled(\"FF_GET_EQUIVALENT_VARIANTS\", True):\n            self.__run = get_current_timestamp_variant(self.__variant_prefix)\n        else:\n            self.__run = get_random_name()\n\n        \"\"\"\n        maps client objects (feature object, label object, source decorators) to their resource in the event we want \n        to update the client object after the resource was created\n\n        Introduced for timestamp variants where updates during a resource create ensures that the client object\n        has the correct variant when being used as a dependency other resources\n        \"\"\"\n        self.__client_obj_to_resource_map = {}\n\n    def add_resource(self, resource):\n        self.__resources.append(resource)\n\n    def map_client_object_to_resource(\n        self, client_obj, resource_variant: ResourceVariant\n    ):\n        self.__client_obj_to_resource_map[resource_variant.to_key()] = client_obj\n\n    def get_client_objects_for_resource(self):\n        return self.__client_obj_to_resource_map\n\n    def get_resources(self):\n        return self.__resources\n\n    def register_user(\n        self, name: str, tags: List[str] = [], properties: dict = {}\n    ) -&gt; UserRegistrar:\n        \"\"\"Register a user.\n\n        Args:\n            name (str): User to be registered.\n\n        Returns:\n            UserRegistrar: User\n        \"\"\"\n        user = User(name=name, tags=tags, properties=properties)\n        self.__resources.append(user)\n        return UserRegistrar(self, user)\n\n    def set_default_owner(self, user: str):\n        \"\"\"Set default owner.\n\n        Args:\n            user (str): User to be set as default owner of resources.\n        \"\"\"\n        self.__default_owner = user\n\n    def default_owner(self) -&gt; str:\n        return self.__default_owner\n\n    def must_get_default_owner(self) -&gt; str:\n        owner = self.default_owner()\n        if owner == \"\":\n            raise ValueError(\"Owner must be set or a default owner must be specified.\")\n        return owner\n\n    def set_variant_prefix(self, variant_prefix: str = \"\"):\n        \"\"\"Set variant prefix.\n\n        Args:\n            variant_prefix (str): variant prefix to be set.\n        \"\"\"\n        self.__variant_prefix = variant_prefix\n        self.set_run()\n\n    def set_run(self, run: str = \"\"):\n        \"\"\"\n\n        **Example 1**: Using set_run() without arguments will generate a random run name.\n        ``` py\n        import featureform as ff\n        ff.set_run()\n\n        postgres.register_table(\n            name=\"transactions\",\n            table=\"transactions_table\",\n        )\n\n        # Applying will register the source as name=transactions, variant=&lt;randomly-generated&gt;\n\n        ```\n\n        **Example 2**: Using set_run() with arguments will set the variant to the provided name.\n        ``` py\n        import featureform as ff\n        ff.set_run(\"last_30_days\")\n\n        postgres.register_table(\n            name=\"transactions\",\n            table=\"transactions_table\",\n        )\n\n        # Applying will register the source as name=transactions, variant=last_30_days\n        ```\n\n        **Example 3**: Generated and set variant names can be used together\n        ``` py\n        import featureform as ff\n        ff.set_run()\n\n        file = spark.register_file(\n            name=\"transactions\",\n            path=\"my/transactions.parquet\",\n            variant=\"last_30_days\"\n        )\n\n        @spark.df_transformation(inputs=[file]):\n        def customer_count(transactions):\n            return transactions.groupBy(\"CustomerID\").count()\n\n\n        # Applying without a variant for the dataframe transformation will result in\n        # the transactions source having a variant of last_30_days and the transformation\n        # having a randomly generated variant\n        ```\n\n        **Example 4**: This also works within SQL Transformations\n        ``` py\n        import featureform as ff\n        ff.set_run(\"last_30_days\")\n\n        @postgres.sql_transformation():\n        def my_transformation():\n            return \"SELECT CustomerID, Amount FROM {{ transactions }}\"\n\n        # The variant will be autofilled so the SQL query is returned as:\n        # \"SELECT CustomerID, Amount FROM {{ transactions.last_30_days }}\"\n        ```\n\n        Args:\n            run (str): Name of a run to be set.\n        \"\"\"\n        if run == \"\":\n            if feature_flag.is_enabled(\"FF_GET_EQUIVALENT_VARIANTS\", True):\n                self.__run = get_current_timestamp_variant(self.__variant_prefix)\n            else:\n                self.__run = get_random_name()\n        else:\n            self.__run = run\n\n    def get_run(self) -&gt; str:\n        \"\"\"\n        Get the current run name.\n\n        **Examples**:\n        ``` py\n        import featureform as ff\n\n        client = ff.Client()\n        f = client.features((\"avg_transaction_amount\", ff.get_run()), {\"user\": \"123\"})\n\n        ```\n\n        Returns:\n            run: The name of the current run\n        \"\"\"\n        return self.__run\n\n    def get_source(self, name, variant, local=False):\n        \"\"\"\n        get_source() can be used to get a reference to an already registered primary source or transformation.\n        The returned object can be used to register features and labels or be extended off of to create additional\n        transformations.\n\n        **Examples**:\n\n        Registering a transformation from an existing source.\n        ``` py\n        spark = ff.get_spark(\"prod-spark\")\n        transactions = ff.get_source(\"transactions\",\"kaggle\")\n\n        @spark.df_transformation(inputs=[transactions]):\n        def customer_count(transactions):\n            return transactions.groupBy(\"CustomerID\").count()\n        ```\n\n        Registering a feature from an existing source.\n        ``` py\n        transactions = ff.get_source(\"transactions\",\"kaggle\")\n\n        transactions.register_resources(\n            entity=user,\n            entity_column=\"customerid\",\n            labels=[\n                {\"name\": \"fraudulent\", \"variant\": \"quickstart\", \"column\": \"isfraud\", \"type\": \"bool\"},\n            ],\n        )\n        ```\n\n        Args:\n            name (str): Name of source to be retrieved\n            variant (str): Name of variant of source to be retrieved\n            local (bool): If localmode is being used\n\n        Returns:\n            source (ColumnSourceRegistrar): Source\n        \"\"\"\n        if local:\n            raise Exception(\n                \"Localmode is not supported; please try featureform &lt;= 1.12.0\"\n            )\n        else:\n            mock_definition = PrimaryData(location=SQLTable(name=\"\"))\n            mock_source = SourceVariant(\n                created=None,\n                name=name,\n                variant=variant,\n                definition=mock_definition,\n                owner=\"\",\n                provider=\"\",\n                description=\"\",\n                tags=[],\n                properties={},\n            )\n            return ColumnSourceRegistrar(self, mock_source)\n\n    def get_redis(self, name):\n        \"\"\"Get a Redis provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        redis = ff.get_redis(\"redis-quickstart\")\n\n        average_user_transaction.register_resources(\n            entity=user,\n            entity_column=\"user_id\",\n            inference_store=redis,\n            features=[\n                {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n            ],\n        )\n        ```\n\n        Args:\n            name (str): Name of Redis provider to be retrieved\n\n        Returns:\n            redis (OnlineProvider): Provider\n        \"\"\"\n        mock_config = RedisConfig(host=\"\", port=123, password=\"\", db=123)\n        mock_provider = Provider(\n            name=name, function=\"ONLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OnlineProvider(self, mock_provider)\n\n    def get_dynamodb(self, name: str):\n        \"\"\"Get a DynamoDB provider. The returned object can be used as an inference store in feature registration.\n\n        **Examples**:\n        ``` py\n        dynamodb = ff.get_dynamodb(\"dynamodb-quickstart\")\n\n        @ff.entity\n        class User:\n            avg_transactions = ff.Feature(\n                average_user_transaction[[\"user_id\", \"avg_transaction_amt\"]],\n                type=ff.Float32,\n                inference_store=dynamodb,\n            )\n        ```\n\n        Args:\n            name (str): Name of DynamoDB provider to be retrieved\n\n        Returns:\n            dynamodb (OnlineProvider): Provider\n        \"\"\"\n        mock_config = DynamodbConfig(\n            region=\"\", access_key=\"\", secret_key=\"\", should_import_from_s3=False\n        )\n        mock_provider = Provider(\n            name=name, function=\"ONLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OnlineProvider(self, mock_provider)\n\n    def get_mongodb(self, name: str):\n        \"\"\"Get a MongoDB provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        mongodb = ff.get_mongodb(\"mongodb-quickstart\")\n\n        average_user_transaction.register_resources(\n            entity=user,\n            entity_column=\"user_id\",\n            inference_store=mongodb,\n            features=[\n                {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n            ],\n        )\n        ```\n\n        Args:\n            name (str): Name of MongoDB provider to be retrieved\n\n        Returns:\n            mongodb (OnlineProvider): Provider\n        \"\"\"\n        mock_config = MongoDBConfig(\n            username=\"\", password=\"\", host=\"\", port=\"\", database=\"\", throughput=1\n        )\n        mock_provider = Provider(\n            name=name, function=\"ONLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OnlineProvider(self, mock_provider)\n\n    def get_blob_store(self, name):\n        \"\"\"Get an Azure Blob provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        azure_blob = ff.get_blob_store(\"azure-blob-quickstart\")\n\n        average_user_transaction.register_resources(\n            entity=user,\n            entity_column=\"user_id\",\n            inference_store=azure_blob,\n            features=[\n                {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n            ],\n        )\n        ```\n\n        Args:\n            name (str): Name of Azure blob provider to be retrieved\n\n        Returns:\n            azure_blob (FileStoreProvider): Provider\n        \"\"\"\n        fake_azure_config = AzureFileStoreConfig(\n            account_name=\"\", account_key=\"\", container_name=\"\", root_path=\"\"\n        )\n        fake_config = OnlineBlobConfig(\n            store_type=\"AZURE\", store_config=fake_azure_config.config()\n        )\n        mock_provider = Provider(\n            name=name, function=\"ONLINE\", description=\"\", team=\"\", config=fake_config\n        )\n        return FileStoreProvider(self, mock_provider, fake_config, \"AZURE\")\n\n    def get_postgres(self, name):\n        \"\"\"Get a Postgres provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        postgres = ff.get_postgres(\"postgres-quickstart\")\n        transactions = postgres.register_table(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            table=\"Transactions\",  # This is the table's name in Postgres\n        )\n        ```\n\n        Args:\n            name (str): Name of Postgres provider to be retrieved\n\n        Returns:\n            postgres (OfflineSQLProvider): Provider\n        \"\"\"\n        mock_config = PostgresConfig(\n            host=\"\",\n            port=\"\",\n            database=\"\",\n            user=\"\",\n            password=\"\",\n            sslmode=\"\",\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineSQLProvider(self, mock_provider)\n\n    def get_clickhouse(self, name):\n        \"\"\"Get a ClickHouse provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        clickhouse = ff.get_clickhouse(\"clickhouse-quickstart\")\n        transactions = clickhouse.register_table(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            table=\"Transactions\",  # This is the table's name in ClickHouse\n        )\n        ```\n\n        Args:\n            name (str): Name of ClickHouse provider to be retrieved\n\n        Returns:\n            clickhouse (OfflineSQLProvider): Provider\n        \"\"\"\n        mock_config = ClickHouseConfig(\n            host=\"\",\n            port=9000,\n            database=\"\",\n            user=\"\",\n            password=\"\",\n            ssl=False,\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineSQLProvider(self, mock_provider)\n\n    def get_snowflake(self, name):\n        \"\"\"Get a Snowflake provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        snowflake = ff.get_snowflake(\"snowflake-quickstart\")\n        transactions = snowflake.register_table(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            table=\"Transactions\",  # This is the table's name in Postgres\n        )\n        ```\n\n        Args:\n            name (str): Name of Snowflake provider to be retrieved\n\n        Returns:\n            snowflake (OfflineSQLProvider): Provider\n        \"\"\"\n        mock_config = SnowflakeConfig(\n            account=\"ff_fake\",\n            database=\"ff_fake\",\n            organization=\"ff_fake\",\n            username=\"ff_fake\",\n            password=\"ff_fake\",\n            schema=\"ff_fake\",\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineSQLProvider(self, mock_provider)\n\n    def get_snowflake_legacy(self, name: str):\n        \"\"\"Get a Snowflake provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        snowflake = ff.get_snowflake_legacy(\"snowflake-quickstart\")\n        transactions = snowflake.register_table(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            table=\"Transactions\",  # This is the table's name in Postgres\n        )\n        ```\n\n        Args:\n            name (str): Name of Snowflake provider to be retrieved\n\n        Returns:\n            snowflake_legacy (OfflineSQLProvider): Provider\n        \"\"\"\n        mock_config = SnowflakeConfig(\n            account_locator=\"ff_fake\",\n            database=\"ff_fake\",\n            username=\"ff_fake\",\n            password=\"ff_fake\",\n            schema=\"ff_fake\",\n            warehouse=\"ff_fake\",\n            role=\"ff_fake\",\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineSQLProvider(self, mock_provider)\n\n    def get_redshift(self, name):\n        \"\"\"Get a Redshift provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        redshift = ff.get_redshift(\"redshift-quickstart\")\n        transactions = redshift.register_table(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            table=\"Transactions\",  # This is the table's name in Postgres\n        )\n        ```\n\n        Args:\n            name (str): Name of Redshift provider to be retrieved\n\n        Returns:\n            redshift (OfflineSQLProvider): Provider\n        \"\"\"\n        mock_config = RedshiftConfig(\n            host=\"\", port=\"5439\", database=\"\", user=\"\", password=\"\", sslmode=\"\"\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineSQLProvider(self, mock_provider)\n\n    def get_bigquery(self, name):\n        \"\"\"Get a BigQuery provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        bigquery = ff.get_bigquery(\"bigquery-quickstart\")\n        transactions = bigquery.register_table(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            table=\"Transactions\",  # This is the table's name in BigQuery\n        )\n        ```\n\n        Args:\n            name (str): Name of BigQuery provider to be retrieved\n\n        Returns:\n            bigquery (OfflineSQLProvider): Provider\n        \"\"\"\n        mock_config = BigQueryConfig(\n            project_id=\"mock_project\",\n            dataset_id=\"mock_dataset\",\n            credentials=GCPCredentials(\n                project_id=\"mock_project\",\n                credentials_path=\"client/tests/test_files/bigquery_dummy_credentials.json\",\n            ),\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineSQLProvider(self, mock_provider)\n\n    def get_spark(self, name):\n        \"\"\"Get a Spark provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n        spark = ff.get_spark(\"spark-quickstart\")\n        transactions = spark.register_file(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            file_path=\"s3://bucket/path/to/file/transactions.parquet\",  # This is the path to file\n        )\n        ```\n\n        Args:\n            name (str): Name of Spark provider to be retrieved\n\n        Returns:\n            spark (OfflineSQLProvider): Provider\n        \"\"\"\n        mock_config = SparkConfig(\n            executor_type=\"\", executor_config={}, store_type=\"\", store_config={}\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineSparkProvider(self, mock_provider)\n\n    def get_kubernetes(self, name):\n        \"\"\"\n        Get a k8s provider. The returned object can be used to register additional resources.\n\n        **Examples**:\n        ``` py\n\n        k8s = ff.get_kubernetes(\"k8s-azure-quickstart\")\n        transactions = k8s.register_file(\n            name=\"transactions\",\n            variant=\"kaggle\",\n            description=\"Fraud Dataset From Kaggle\",\n            path=\"path/to/blob\",\n        )\n        ```\n\n        Args:\n            name (str): Name of k8s provider to be retrieved\n\n        Returns:\n            k8s (OfflineK8sProvider): Provider\n        \"\"\"\n        mock_config = K8sConfig(store_type=\"\", store_config={})\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineK8sProvider(self, mock_provider)\n\n    def get_s3(self, name):\n        \"\"\"\n        Get a S3 provider. The returned object can be used with other providers such as Spark and Databricks.\n\n        **Examples**:\n\n        ``` py\n\n        s3 = ff.get_s3(\"s3-quickstart\")\n        spark = ff.register_spark(\n            name=f\"spark-emr-s3\",\n            description=\"A Spark deployment we created for the Featureform quickstart\",\n            team=\"featureform-team\",\n            executor=emr,\n            filestore=s3,\n        )\n        ```\n\n        Args:\n            name (str): Name of S3 to be retrieved\n\n        Returns:\n            s3 (FileStore): Provider\n        \"\"\"\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=\"description\",\n            team=\"team\",\n            config=s3_config,\n        )\n        return FileStoreProvider(\n            registrar=self,\n            provider=provider,\n            config=s3_config,\n            store_type=s3_config.type(),\n        )\n\n    def get_gcs(self, name):\n        filePath = \"provider/connection/mock_credentials.json\"\n        fake_creds = GCPCredentials(project_id=\"id\", credentials_path=filePath)\n        mock_config = GCSFileStoreConfig(\n            bucket_name=\"\", bucket_path=\"\", credentials=fake_creds\n        )\n        mock_provider = Provider(\n            name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n        )\n        return OfflineK8sProvider(self, mock_provider)\n\n    def _create_mock_creds_file(self, filename, json_data):\n        with open(filename, \"w\") as f:\n            json.dumps(json_data, f)\n\n    def get_entity(self, name: str):\n        \"\"\"Get an entity. The returned object can be used to register additional resources.\n\n        **Examples**:\n\n        ``` py\n        entity = get_entity(\"user\")\n        transactions.register_resources(\n            entity=entity,\n            entity_column=\"customerid\",\n            labels=[\n                {\"name\": \"fraudulent\", \"variant\": \"quickstart\", \"column\": \"isfraud\", \"type\": \"bool\"},\n            ],\n        )\n        ```\n\n        Args:\n            name (str): Name of entity to be retrieved\n        Returns:\n            entity (EntityRegistrar): Entity\n        \"\"\"\n        fakeEntity = Entity(\n            name=name, description=\"\", status=\"\", tags=[], properties={}\n        )\n        return EntityRegistrar(self, fakeEntity)\n\n    def register_redis(\n        self,\n        name: str,\n        host: str,\n        port: int = 6379,\n        db: int = 0,\n        password: str = \"\",\n        description: str = \"\",\n        team: str = \"\",\n        tags: Optional[List[str]] = None,\n        properties: Optional[dict] = None,\n    ):\n        \"\"\"Register a Redis provider.\n\n        **Examples**:\n        ```\n        redis = ff.register_redis(\n            name=\"redis-quickstart\",\n            host=\"quickstart-redis\",\n            port=6379,\n            password=\"password\",\n            description=\"A Redis deployment we created for the Featureform quickstart\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Redis provider to be registered\n            host (str): (Immutable) Hostname for Redis\n            db (str): (Immutable) Redis database number\n            port (int): (Mutable) Redis port\n            password (str): (Mutable) Redis password\n            description (str): (Mutable) Description of Redis provider to be registered\n            team (str): (Mutable) Name of team\n            tags (Optional[List[str]]): (Mutable) Optional grouping mechanism for resources\n            properties (Optional[dict]): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            redis (OnlineProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = RedisConfig(host=host, port=port, password=password, db=db)\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    def register_pinecone(\n        self,\n        name: str,\n        project_id: str,\n        environment: str,\n        api_key: str,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Pinecone provider.\n\n        **Examples**:\n        ```\n        pinecone = ff.register_pinecone(\n            name=\"pinecone-quickstart\",\n            project_id=\"2g13ek7\",\n            environment=\"us-west4-gcp-free\",\n            api_key=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Pinecone provider to be registered\n            project_id (str): (Immutable) Pinecone project id\n            environment (str): (Immutable) Pinecone environment\n            api_key (str): (Mutable) Pinecone api key\n            description (str): (Mutable) Description of Pinecone provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            pinecone (OnlineProvider): Provider\n        \"\"\"\n\n        tags, properties = set_tags_properties(tags, properties)\n        config = PineconeConfig(\n            project_id=project_id, environment=environment, api_key=api_key\n        )\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    def register_weaviate(\n        self,\n        name: str,\n        url: str,\n        api_key: str,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Weaviate provider.\n\n        **Examples**:\n        ```\n        weaviate = ff.register_weaviate(\n            name=\"weaviate-quickstart\",\n            url=\"https://&lt;CLUSTER NAME&gt;.weaviate.network\",\n            api_key=\"&lt;API KEY&gt;\"\n            description=\"A Weaviate project for using embeddings in Featureform\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Weaviate provider to be registered\n            url (str): (Immutable) Endpoint of Weaviate cluster, either in the cloud or via another deployment operation\n            api_key (str): (Mutable) Weaviate api key\n            description (str): (Mutable) Description of Weaviate provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            weaviate (OnlineProvider): Provider\n        \"\"\"\n        config = WeaviateConfig(url=url, api_key=api_key)\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    def register_qdrant(\n        self,\n        name: str,\n        grpc_host: str,\n        api_key: str = \"\",\n        use_tls: bool = False,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Qdrant provider.\n\n        **Examples**:\n        ```\n        qdrant = ff.register_qdrant(\n            name=\"qdrant-quickstart\",\n            grpc_host=\"xyz-example.eu-central.aws.cloud.qdrant.io:6334\",\n            api_key=\"&lt;API KEY&gt;\",\n            use_tls=True,\n            description=\"A Qdrant project for using embeddings in Featureform\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Qdrant provider to be registered\n            url (str): (Immutable) gRPC host of the Qdrant cluster, either in the cloud or via local deployment.\n            api_key (str): (Mutable) Qdrant API key.\n            use_tls (bool): (Immutable) Whether to use TLS for the connection.\n            description (str): (Mutable) Description of Qdrant provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            qdrant (OnlineProvider): Provider\n        \"\"\"\n        config = QdrantConfig(grpc_host=grpc_host, api_key=api_key, use_tls=use_tls)\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    def register_blob_store(\n        self,\n        name: str,\n        account_name: str,\n        account_key: str,\n        container_name: str,\n        root_path: str,\n        description: str = \"\",\n        team: str = \"\",\n        tags=None,\n        properties=None,\n    ):\n        \"\"\"Register an Azure Blob Store provider.\n\n        Azure Blob Storage can be used as the storage component for Spark or the Featureform Pandas Runner.\n\n        **Examples**:\n        ```\n        blob = ff.register_blob_store(\n            name=\"azure-quickstart\",\n            container_name=\"my_company_container\"\n            root_path=\"custom/path/in/container\"\n            account_name=&lt;azure_account_name&gt;\n            account_key=&lt;azure_account_key&gt;\n            description=\"An azure blob store provider to store offline and inference data\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Azure blob store to be registered\n            container_name (str): (Immutable) Azure container name\n            root_path (str): (Immutable) A custom path in container to store data\n            account_name (str): (Immutable) Azure account name\n            account_key (str):  (Mutable) Secret azure account key\n            description (str): (Mutable) Description of Azure Blob provider to be registered\n            team (str): (Mutable) The name of the team registering the filestore\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            blob (StorageProvider): Provider\n                has all the functionality of OnlineProvider\n        \"\"\"\n\n        tags, properties = set_tags_properties(tags, properties)\n\n        container_name = container_name.replace(\"abfss://\", \"\")\n        if \"/\" in container_name:\n            raise ValueError(\n                \"container_name cannot contain '/'. container_name should be the name of the Azure Blobstore container only.\"\n            )\n\n        azure_config = AzureFileStoreConfig(\n            account_name=account_name,\n            account_key=account_key,\n            container_name=container_name,\n            root_path=root_path,\n        )\n        config = OnlineBlobConfig(\n            store_type=\"AZURE\", store_config=azure_config.config()\n        )\n\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return FileStoreProvider(self, provider, azure_config, \"AZURE\")\n\n    def register_s3(\n        self,\n        name: str,\n        credentials: AWSCredentials,\n        bucket_region: str,\n        bucket_name: str,\n        path: str = \"\",\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a S3 store provider.\n\n        This has the functionality of an offline store and can be used as a parameter\n        to a k8s or spark provider\n\n        **Examples**:\n        ```\n        s3 = ff.register_s3(\n            name=\"s3-quickstart\",\n            credentials=aws_creds,\n            bucket_name=\"bucket_name\",\n            bucket_region=&lt;bucket_region&gt;,\n            path=\"path/to/store/featureform_files/in/\",\n            description=\"An s3 store provider to store offline\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of S3 store to be registered\n            bucket_name (str): (Immutable) AWS Bucket Name\n            bucket_region (str): (Immutable) AWS region the bucket is located in\n            path (str): (Immutable) The path used to store featureform files in\n            credentials (AWSCredentials): (Mutable) AWS credentials to access the bucket\n            description (str): (Mutable) Description of S3 provider to be registered\n            team (str): (Mutable) The name of the team registering the filestore\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            s3 (FileStoreProvider): Provider\n                has all the functionality of OfflineProvider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n\n        if bucket_name == \"\":\n            raise ValueError(\"bucket_name is required and cannot be empty string\")\n\n        # TODO: add verification into S3StoreConfig\n        bucket_name = bucket_name.replace(\"s3://\", \"\").replace(\"s3a://\", \"\")\n\n        if \"/\" in bucket_name:\n            raise ValueError(\n                \"bucket_name cannot contain '/'. bucket_name should be the name of the AWS S3 bucket only.\"\n            )\n\n        s3_config = S3StoreConfig(\n            bucket_path=bucket_name,\n            bucket_region=bucket_region,\n            credentials=credentials,\n            path=path,\n        )\n\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=s3_config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return FileStoreProvider(self, provider, s3_config, s3_config.type())\n\n    def register_gcs(\n        self,\n        name: str,\n        bucket_name: str,\n        root_path: str,\n        credentials: GCPCredentials,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a GCS store provider.\n\n        **Examples**:\n        ```\n        gcs = ff.register_gcs(\n            name=\"gcs-quickstart\",\n            credentials=ff.GCPCredentials(...),\n            bucket_name=\"bucket_name\",\n            root_path=\"featureform/path/\",\n            description=\"An gcs store provider to store offline\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of GCS store to be registered\n            bucket_name (str): (Immutable) The bucket name\n            root_path (str): (Immutable) Custom path to be used by featureform\n            credentials (GCPCredentials): (Mutable) GCP credentials to access the bucket\n            description (str): (Mutable) Description of GCS provider to be registered\n            team (str): (Mutable) The name of the team registering the filestore\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            gcs (FileStoreProvider): Provider\n                has all the functionality of OfflineProvider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n\n        if bucket_name == \"\":\n            raise ValueError(\"bucket_name is required and cannot be empty string\")\n\n        bucket_name = bucket_name.replace(\"gs://\", \"\")\n        if \"/\" in bucket_name:\n            raise ValueError(\n                \"bucket_name cannot contain '/'. bucket_name should be the name of the GCS bucket only.\"\n            )\n\n        gcs_config = GCSFileStoreConfig(\n            bucket_name=bucket_name, bucket_path=root_path, credentials=credentials\n        )\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=gcs_config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return FileStoreProvider(self, provider, gcs_config, gcs_config.type())\n\n    def register_hdfs(\n        self,\n        name: str,\n        host: str,\n        port: str,\n        username: str = \"\",\n        path: str = \"\",\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a HDFS store provider.\n\n        This has the functionality of an offline store and can be used as a parameter\n        to a k8s or spark provider\n\n        **Examples**:\n        ```\n        hdfs = ff.register_hdfs(\n            name=\"hdfs-quickstart\",\n            host=\"&lt;host&gt;\",\n            port=\"&lt;port&gt;\",\n            path=\"&lt;path&gt;\",\n            username=\"&lt;username&gt;\",\n            description=\"An hdfs store provider to store offline\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of HDFS store to be registered\n            host (str): (Immutable) The hostname for HDFS\n            path (str): (Immutable) A storage path within HDFS\n            port (str): (Mutable) The IPC port for the Namenode for HDFS. (Typically 8020 or 9000)\n            username (str): (Mutable) A Username for HDFS\n            description (str): (Mutable) Description of HDFS provider to be registered\n            team (str): (Mutable) The name of the team registering HDFS\n\n        Returns:\n            hdfs (FileStoreProvider): Provider\n        \"\"\"\n\n        hdfs_config = HDFSConfig(host=host, port=port, path=path, username=username)\n\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=hdfs_config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return FileStoreProvider(self, provider, hdfs_config, hdfs_config.type())\n\n    # TODO: Set Deprecation Warning For Credentials Path\n    def register_firestore(\n        self,\n        name: str,\n        collection: str,\n        project_id: str,\n        credentials: GCPCredentials,\n        credentials_path: str = \"\",\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Firestore provider.\n\n        **Examples**:\n        ```\n        firestore = ff.register_firestore(\n            name=\"firestore-quickstart\",\n            description=\"A Firestore deployment we created for the Featureform quickstart\",\n            project_id=\"quickstart-project\",\n            collection=\"quickstart-collection\",\n            credentials=ff.GCPCredentials(...)\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Firestore provider to be registered\n            project_id (str): (Immutable) The Project name in GCP\n            collection (str): (Immutable) The Collection name in Firestore under the given project ID\n            credentials (GCPCredentials): (Mutable) GCP credentials to access Firestore\n            description (str): (Mutable) Description of Firestore provider to be registered\n            team (str): (Mutable) The name of the team registering the filestore\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            firestore (OfflineSQLProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = FirestoreConfig(\n            collection=collection,\n            project_id=project_id,\n            credentials=credentials,\n        )\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    # TODO: Check these fields\n    def register_cassandra(\n        self,\n        name: str,\n        host: str,\n        port: int,\n        username: str,\n        password: str,\n        keyspace: str,\n        consistency: str = \"THREE\",\n        replication: int = 3,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Cassandra provider.\n\n        **Examples**:\n        ```\n        cassandra = ff.register_cassandra(\n                name = \"cassandra\",\n                description = \"Example inference store\",\n                team = \"Featureform\",\n                host = \"0.0.0.0\",\n                port = 9042,\n                username = \"cassandra\",\n                password = \"cassandra\",\n                consistency = \"THREE\",\n                replication = 3\n            )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Cassandra provider to be registered\n            host (str): (Immutable) DNS name of Cassandra\n            port (str): (Mutable) Port\n            username (str): (Mutable) Username\n            password (str): (Mutable) Password\n            consistency (str): (Mutable) Consistency\n            replication (int): (Mutable) Replication\n            description (str): (Mutable) Description of Cassandra provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            cassandra (OnlineProvider): Provider\n        \"\"\"\n        config = CassandraConfig(\n            host=host,\n            port=port,\n            username=username,\n            password=password,\n            keyspace=keyspace,\n            consistency=consistency,\n            replication=replication,\n        )\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    def register_dynamodb(\n        self,\n        name: str,\n        credentials: AWSCredentials,\n        region: str,\n        should_import_from_s3: bool = False,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a DynamoDB provider.\n\n        **Examples**:\n        ```\n        dynamodb = ff.register_dynamodb(\n            name=\"dynamodb-quickstart\",\n            description=\"A Dynamodb deployment we created for the Featureform quickstart\",\n            credentials=aws_creds,\n            region=\"us-east-1\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of DynamoDB provider to be registered\n            region (str): (Immutable) Region to create dynamo tables\n            credentials (AWSCredentials): (Mutable) AWS credentials with permissions to create DynamoDB tables\n            should_import_from_s3 (bool): (Mutable) Determines whether feature materialization will occur via a direct import of data from S3 to new table (see [docs](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/S3DataImport.HowItWorks.html) for details)\n            description (str): (Mutable) Description of DynamoDB provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            dynamodb (OnlineProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = DynamodbConfig(\n            access_key=credentials.access_key,\n            secret_key=credentials.secret_key,\n            region=region,\n            should_import_from_s3=should_import_from_s3,\n        )\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    def register_mongodb(\n        self,\n        name: str,\n        username: str,\n        password: str,\n        database: str,\n        host: str,\n        port: str,\n        throughput: int = 1000,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a MongoDB provider.\n\n        **Examples**:\n        ```\n        mongodb = ff.register_mongodb(\n            name=\"mongodb-quickstart\",\n            description=\"A MongoDB deployment\",\n            username=\"my_username\",\n            password=\"myPassword\",\n            database=\"featureform_database\"\n            host=\"my-mongodb.host.com\",\n            port=\"10225\",\n            throughput=10000\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of MongoDB provider to be registered\n            database (str): (Immutable) MongoDB database\n            host (str): (Immutable) MongoDB hostname\n            port (str): (Immutable) MongoDB port\n            username (str): (Mutable) MongoDB username\n            password (str): (Mutable) MongoDB password\n            throughput (int): (Mutable) The maximum RU limit for autoscaling in CosmosDB\n            description (str): (Mutable) Description of MongoDB provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            mongodb (OnlineProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = MongoDBConfig(\n            username=username,\n            password=password,\n            host=host,\n            port=port,\n            database=database,\n            throughput=throughput,\n        )\n        provider = Provider(\n            name=name,\n            function=\"ONLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OnlineProvider(self, provider)\n\n    def register_snowflake_legacy(\n        self,\n        name: str,\n        username: str,\n        password: str,\n        account_locator: str,\n        database: str,\n        schema: str = \"PUBLIC\",\n        description: str = \"\",\n        team: str = \"\",\n        warehouse: str = \"\",\n        role: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Snowflake provider using legacy credentials.\n\n        **Examples**:\n        ```\n        snowflake = ff.register_snowflake_legacy(\n            name=\"snowflake-quickstart\",\n            username=\"snowflake\",\n            password=\"password\",\n            account_locator=\"account-locator\",\n            database=\"snowflake\",\n            schema=\"PUBLIC\",\n            description=\"A Snowflake deployment we created for the Featureform quickstart\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Snowflake provider to be registered\n            account_locator (str): (Immutable) Account Locator\n            schema (str): (Immutable) Schema\n            database (str): (Immutable) Database\n            username (str): (Mutable) Username\n            password (str): (Mutable) Password\n            warehouse (str): (Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.\n            role (str): (Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session\n            description (str): (Mutable) Description of Snowflake provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            snowflake (OfflineSQLProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = SnowflakeConfig(\n            account_locator=account_locator,\n            database=database,\n            username=username,\n            password=password,\n            schema=schema,\n            warehouse=warehouse,\n            role=role,\n        )\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OfflineSQLProvider(self, provider)\n\n    # TODO: Recheck mutable fields\n    def register_snowflake(\n        self,\n        name: str,\n        username: str,\n        password: str,\n        account: str,\n        organization: str,\n        database: str,\n        schema: str = \"PUBLIC\",\n        description: str = \"\",\n        team: str = \"\",\n        warehouse: str = \"\",\n        role: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Snowflake provider.\n\n        **Examples**:\n        ```\n        snowflake = ff.register_snowflake(\n            name=\"snowflake-quickstart\",\n            username=\"snowflake\",\n            password=\"password\", #pragma: allowlist secret\n            account=\"account\",\n            organization=\"organization\",\n            database=\"snowflake\",\n            schema=\"PUBLIC\",\n            description=\"A Snowflake deployment we created for the Featureform quickstart\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Snowflake provider to be registered\n            account (str): (Immutable) Account\n            organization (str): (Immutable) Organization\n            database (str): (Immutable) Database\n            schema (str): (Immutable) Schema\n            username (str): (Mutable) Username\n            password (str): (Mutable) Password\n            warehouse (str): (Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.\n            role (str): (Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session\n            description (str): (Mutable) Description of Snowflake provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            snowflake (OfflineSQLProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = SnowflakeConfig(\n            account=account,\n            database=database,\n            organization=organization,\n            username=username,\n            password=password,\n            schema=schema,\n            warehouse=warehouse,\n            role=role,\n        )\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OfflineSQLProvider(self, provider)\n\n    def register_postgres(\n        self,\n        name: str,\n        host: str,\n        user: str,\n        password: str,\n        database: str,\n        port: str = \"5432\",\n        description: str = \"\",\n        team: str = \"\",\n        sslmode: str = \"disable\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Postgres provider.\n\n        **Examples**:\n        ```\n        postgres = ff.register_postgres(\n            name=\"postgres-quickstart\",\n            description=\"A Postgres deployment we created for the Featureform quickstart\",\n            host=\"quickstart-postgres\",  # The internal dns name for postgres\n            port=\"5432\",\n            user=\"postgres\",\n            password=\"password\", #pragma: allowlist secret\n            database=\"postgres\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Postgres provider to be registered\n            host (str): (Immutable) Hostname for Postgres\n            database (str): (Immutable) Database\n            port (str): (Mutable) Port\n            user (str): (Mutable) User\n            password (str): (Mutable) Password\n            sslmode (str): (Mutable) SSL mode\n            description (str): (Mutable) Description of Postgres provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            postgres (OfflineSQLProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = PostgresConfig(\n            host=host,\n            port=port,\n            database=database,\n            user=user,\n            password=password,\n            sslmode=sslmode,\n        )\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags or [],\n            properties=properties or {},\n        )\n\n        self.__resources.append(provider)\n        return OfflineSQLProvider(self, provider)\n\n    def register_clickhouse(\n        self,\n        name: str,\n        host: str,\n        user: str,\n        password: str,\n        database: str,\n        port: int = 9000,\n        description: str = \"\",\n        team: str = \"\",\n        ssl: bool = False,\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a ClickHouse provider.\n\n        **Examples**:\n        ```\n        clickhouse = ff.register_clickhouse(\n            name=\"clickhouse-quickstart\",\n            description=\"A ClickHouse deployment we created for the Featureform quickstart\",\n            host=\"quickstart-clickhouse\",  # The internal dns name for clickhouse\n            port=9000,\n            user=\"default\",\n            password=\"\", #pragma: allowlist secret\n            database=\"default\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of ClickHouse provider to be registered\n            host (str): (Immutable) Hostname for ClickHouse\n            database (str): (Immutable) ClickHouse database\n            port (int): (Mutable) Port\n            ssl (bool): (Mutable) Enable SSL\n            user (str): (Mutable) User\n            password (str): (Mutable) ClickHouse password\n            description (str): (Mutable) Description of ClickHouse provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            clickhouse (OfflineSQLProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = ClickHouseConfig(\n            host=host,\n            port=port,\n            database=database,\n            user=user,\n            password=password,\n            ssl=ssl,\n        )\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OfflineSQLProvider(self, provider)\n\n    def register_redshift(\n        self,\n        name: str,\n        host: str,\n        port: str,\n        user: str,\n        password: str,\n        database: str,\n        description: str = \"\",\n        team: str = \"\",\n        sslmode: str = \"disable\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Redshift provider.\n\n        **Examples**:\n        ```\n        redshift = ff.register_redshift(\n            name=\"redshift-quickstart\",\n            description=\"A Redshift deployment we created for the Featureform quickstart\",\n            host=\"quickstart-redshift\",  # The internal dns name for redshift\n            port=\"5432\",\n            user=\"redshift\",\n            password=\"password\", #pragma: allowlist secret\n            database=\"dev\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Redshift provider to be registered\n            host (str): (Immutable) Hostname for Redshift\n            database (str): (Immutable) Redshift database\n            port (str): (Mutable) Port\n            user (str): (Mutable) User\n            password (str): (Mutable) Redshift password\n            sslmode (str): (Mutable) SSL mode\n            description (str): (Mutable) Description of Redshift provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            redshift (OfflineSQLProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = RedshiftConfig(\n            host=host,\n            port=port,\n            database=database,\n            user=user,\n            password=password,\n            sslmode=sslmode,\n        )\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OfflineSQLProvider(self, provider)\n\n    # TODO: Add deprecated warning for credentials_path\n    def register_bigquery(\n        self,\n        name: str,\n        project_id: str,\n        dataset_id: str,\n        credentials: GCPCredentials,\n        credentials_path: str = \"\",\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a BigQuery provider.\n\n        **Examples**:\n        ```\n        bigquery = ff.register_bigquery(\n            name=\"bigquery-quickstart\",\n            description=\"A BigQuery deployment we created for the Featureform quickstart\",\n            project_id=\"quickstart-project\",\n            dataset_id=\"quickstart-dataset\",\n            credentials=GCPCredentials(...)\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of BigQuery provider to be registered\n            project_id (str): (Immutable) The Project name in GCP\n            dataset_id (str): (Immutable) The Dataset name in GCP under the Project Id\n            credentials (GCPCredentials): (Mutable) GCP credentials to access BigQuery\n            description (str): (Mutable) Description of BigQuery provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            bigquery (OfflineSQLProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n\n        config = BigQueryConfig(\n            project_id=project_id,\n            dataset_id=dataset_id,\n            credentials=credentials,\n        )\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OfflineSQLProvider(self, provider)\n\n    def register_spark(\n        self,\n        name: str,\n        executor: ExecutorCredentials,\n        filestore: FileStoreProvider,\n        description: str = \"\",\n        team: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Spark on Executor provider.\n\n        **Examples**:\n        ```\n        spark = ff.register_spark(\n            name=\"spark-quickstart\",\n            description=\"A Spark deployment we created for the Featureform quickstart\",\n            team=\"featureform-team\",\n            executor=databricks,\n            filestore=azure_blob_store\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of Spark provider to be registered\n            executor (ExecutorCredentials): (Mutable) An Executor Provider used for the compute power\n            filestore (FileStoreProvider): (Mutable) A FileStoreProvider used for storage of data\n            description (str): (Mutable) Description of Spark provider to be registered\n            team (str): (Mutable) Name of team\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n\n        Returns:\n            spark (OfflineSparkProvider): Provider\n        \"\"\"\n        tags, properties = set_tags_properties(tags, properties)\n        config = SparkConfig(\n            executor_type=executor.type(),\n            executor_config=executor.config(),\n            store_type=filestore.store_type(),\n            store_config=filestore.config(),\n        )\n\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OfflineSparkProvider(self, provider)\n\n    # TODO: Change things to either filestore or store\n    def register_k8s(\n        self,\n        name: str,\n        store: FileStoreProvider,\n        description: str = \"\",\n        team: str = \"\",\n        docker_image: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"\n        Register an offline store provider to run on Featureform's own k8s deployment.\n        **Examples**:\n        ```\n        spark = ff.register_k8s(\n            name=\"k8s\",\n            store=AzureBlobStore(),\n            docker_image=\"my-repo/image:version\"\n        )\n        ```\n\n        Args:\n            name (str): (Immutable) Name of provider\n            store (FileStoreProvider): (Mutable) Reference to registered file store provider\n            docker_image (str): (Mutable) A custom docker image using the base image featureformcom/k8s_runner\n            description (str): (Mutable) Description of primary data to be registered\n            team (str): (Mutable) A string parameter describing the team that owns the provider\n            tags (List[str]): (Mutable) Optional grouping mechanism for resources\n            properties (dict): (Mutable) Optional grouping mechanism for resources\n        \"\"\"\n\n        tags, properties = set_tags_properties(tags, properties)\n        config = K8sConfig(\n            store_type=store.store_type(),\n            store_config=store.config(),\n            docker_image=docker_image,\n        )\n\n        provider = Provider(\n            name=name,\n            function=\"OFFLINE\",\n            description=description,\n            team=team,\n            config=config,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(provider)\n        return OfflineK8sProvider(self, provider)\n\n    def register_primary_data(\n        self,\n        name: str,\n        location: Location,\n        provider: Union[str, OfflineProvider],\n        tags: List[str],\n        properties: dict,\n        variant: str = \"\",\n        owner: Union[str, UserRegistrar] = \"\",\n        description: str = \"\",\n    ):\n        \"\"\"Register a primary data source.\n\n        Args:\n            name (str): Name of source\n            variant (str): Name of variant\n            location (Location): Location of primary data\n            provider (Union[str, OfflineProvider]): Provider\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of primary data to be registered\n\n        Returns:\n            source (ColumnSourceRegistrar): Source\n        \"\"\"\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        if variant == \"\":\n            variant = self.__run\n        if not isinstance(provider, str):\n            provider = provider.name()\n        source = SourceVariant(\n            created=None,\n            name=name,\n            variant=variant,\n            definition=PrimaryData(location=location),\n            owner=owner,\n            provider=provider,\n            description=description,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(source)\n        column_source_registrar = ColumnSourceRegistrar(self, source)\n        self.map_client_object_to_resource(column_source_registrar, source)\n        return column_source_registrar\n\n    def register_sql_transformation(\n        self,\n        name: str,\n        query: str,\n        provider: Union[str, OfflineProvider],\n        variant: str = \"\",\n        owner: Union[str, UserRegistrar] = \"\",\n        description: str = \"\",\n        schedule: str = \"\",\n        args: K8sArgs = None,\n        inputs: Union[List[NameVariant], List[str], List[ColumnSourceRegistrar]] = None,\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a SQL transformation source.\n\n        Args:\n            name (str): Name of source\n            variant (str): Name of variant\n            query (str): SQL query\n            provider (Union[str, OfflineProvider]): Provider\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of primary data to be registered\n            schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n            args (K8sArgs): Additional transformation arguments\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            source (ColumnSourceRegistrar): Source\n        \"\"\"\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        if variant == \"\":\n            variant = self.__run\n        if not isinstance(provider, str):\n            provider = provider.name()\n        source = SourceVariant(\n            created=None,\n            name=name,\n            variant=variant,\n            definition=SQLTransformation(query, args),\n            owner=owner,\n            schedule=schedule,\n            provider=provider,\n            description=description,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(source)\n        return ColumnSourceRegistrar(self, source)\n\n    def sql_transformation(\n        self,\n        provider: Union[str, OfflineProvider],\n        variant: str = \"\",\n        name: str = \"\",\n        schedule: str = \"\",\n        owner: Union[str, UserRegistrar] = \"\",\n        inputs: Union[List[NameVariant], List[str], List[ColumnSourceRegistrar]] = None,\n        description: str = \"\",\n        args: K8sArgs = None,\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"SQL transformation decorator.\n\n        Args:\n            variant (str): Name of variant\n            provider (Union[str, OfflineProvider]): Provider\n            name (str): Name of source\n            schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n            owner (Union[str, UserRegistrar]): Owner\n            inputs (list): Inputs to transformation\n            description (str): Description of SQL transformation\n            args (K8sArgs): Additional transformation arguments\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            decorator (SQLTransformationDecorator): decorator\n        \"\"\"\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        if variant == \"\":\n            variant = self.__run\n        if not isinstance(provider, str):\n            provider = provider.name()\n        decorator = SQLTransformationDecorator(\n            registrar=self,\n            name=name,\n            run=self.__run,\n            variant=variant,\n            provider=provider,\n            schedule=schedule,\n            owner=owner,\n            description=description,\n            inputs=inputs,\n            args=args,\n            tags=tags,\n            properties=properties,\n        )\n        return decorator\n\n    def register_df_transformation(\n        self,\n        name: str,\n        query: str,\n        provider: Union[str, OfflineProvider],\n        variant: str = \"\",\n        owner: Union[str, UserRegistrar] = \"\",\n        description: str = \"\",\n        inputs: list = [],\n        schedule: str = \"\",\n        args: K8sArgs = None,\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a Dataframe transformation source.\n\n        Args:\n            name (str): Name of source\n            variant (str): Name of variant\n            query (str): SQL query\n            provider (Union[str, OfflineProvider]): Provider\n            name (str): Name of source\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of SQL transformation\n            inputs (list): Inputs to transformation\n            schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n            args (K8sArgs): Additional transformation arguments\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            source (ColumnSourceRegistrar): Source\n        \"\"\"\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        if variant == \"\":\n            variant = self.__run\n        if not isinstance(provider, str):\n            provider = provider.name()\n        source = SourceVariant(\n            created=None,\n            name=name,\n            variant=variant,\n            definition=DFTransformation(query, inputs, args),\n            owner=owner,\n            schedule=schedule,\n            provider=provider,\n            description=description,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(source)\n        return ColumnSourceRegistrar(self, source)\n\n    def df_transformation(\n        self,\n        provider: Union[str, OfflineProvider],\n        tags: List[str],\n        properties: dict,\n        variant: str = \"\",\n        name: str = \"\",\n        owner: Union[str, UserRegistrar] = \"\",\n        description: str = \"\",\n        inputs: Union[List[NameVariant], List[str], List[ColumnSourceRegistrar]] = [],\n        args: K8sArgs = None,\n    ):\n        \"\"\"Dataframe transformation decorator.\n\n        Args:\n            variant (str): Name of variant\n            provider (Union[str, OfflineProvider]): Provider\n            name (str): Name of source\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of SQL transformation\n            inputs (list): Inputs to transformation\n            args (K8sArgs): Additional transformation arguments\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            decorator (DFTransformationDecorator): decorator\n        \"\"\"\n\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        if variant == \"\":\n            variant = self.__run\n        if not isinstance(provider, str):\n            provider = provider.name()\n        if not isinstance(inputs, list):\n            raise ValueError(\"Dataframe transformation inputs must be a list\")\n        for i, nv in enumerate(inputs):\n            if isinstance(nv, str):  # TODO remove this functionality\n                inputs[i] = (nv, self.__run)\n            elif isinstance(nv, tuple):\n                try:\n                    self._verify_tuple(nv)\n                except TypeError as e:\n                    transformation_message = f\"'{name}:{variant}'\"\n                    if name == \"\":\n                        transformation_message = f\"with '{variant}' variant\"\n\n                    raise TypeError(\n                        f\"DF transformation {transformation_message} requires correct inputs \"\n                        f\" '{nv}' is not a valid tuple: {e}\"\n                    )\n                if inputs[i][1] == \"\":\n                    inputs[i] = (inputs[i][0], self.__run)\n\n        decorator = DFTransformationDecorator(\n            registrar=self,\n            name=name,\n            variant=variant,\n            provider=provider,\n            owner=owner,\n            description=description,\n            inputs=inputs,\n            args=args,\n            tags=tags,\n            properties=properties,\n        )\n        return decorator\n\n    def _verify_tuple(self, nv_tuple):\n        if not isinstance(nv_tuple, tuple):\n            raise TypeError(f\"not a tuple; received: '{type(nv_tuple).__name__}' type\")\n\n        if len(nv_tuple) != 2:\n            raise TypeError(\n                \"Tuple must be of length 2, got length {}\".format(len(nv_tuple))\n            )\n        if len(nv_tuple) == 2:\n            not_string_tuples = not (\n                isinstance(nv_tuple[0], str) and isinstance(nv_tuple[1], str)\n            )\n            if not_string_tuples:\n                first_position_type = type(nv_tuple[0]).__name__\n                second_position_type = type(nv_tuple[1]).__name__\n                raise TypeError(\n                    f\"Tuple must be of type (str, str); got ({first_position_type}, {second_position_type})\"\n                )\n\n    def ondemand_feature(\n        self,\n        fn=None,\n        *,\n        tags: List[str] = [],\n        properties: dict = {},\n        variant: str = \"\",\n        name: str = \"\",\n        owner: Union[str, UserRegistrar] = \"\",\n        description: str = \"\",\n    ):\n        \"\"\"On Demand Feature decorator.\n\n        **Examples**\n        ```python\n        import featureform as ff\n\n        @ff.ondemand_feature()\n        def avg_user_transactions(client, params, entities):\n            pass\n        ```\n\n        Args:\n            variant (str): Name of variant\n            name (str): Name of source\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of on demand feature\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            decorator (OnDemandFeature): decorator\n\n        \"\"\"\n\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        if variant == \"\":\n            variant = self.__run\n        decorator = OnDemandFeatureVariant(\n            name=name,\n            variant=variant,\n            owner=owner,\n            description=description,\n            tags=tags or [],\n            properties=properties or {},\n        )\n\n        self.__resources.append(decorator)\n\n        if fn is None:\n            return decorator\n        else:\n            return decorator(fn)\n\n    def state(self):\n        for resource in self.__resources:\n            try:\n                self.__state.add(resource)\n\n            except ResourceRedefinedError:\n                raise\n            except Exception as e:\n                resource_variant = (\n                    f\" ({resource.variant})\" if hasattr(resource, \"variant\") else \"\"\n                )\n                raise Exception(\n                    f\"Could not add apply {resource.name}{resource_variant}: {e}\"\n                )\n        self.__resources = []\n        return self.__state\n\n    def clear_state(self):\n        self.__state = ResourceState()\n        self.__client_obj_to_resource_map = {}\n        self.__resources = []\n\n    def get_state(self):\n        \"\"\"\n        Get the state of the resources to be registered.\n\n        Returns:\n            resources (List[str]): List of resources to be registered ex. \"{type} - {name} ({variant})\"\n        \"\"\"\n        if len(self.__resources) == 0:\n            return \"No resources to be registered\"\n\n        resources = [[\"Type\", \"Name\", \"Variant\"]]\n        for resource in self.__resources:\n            if hasattr(resource, \"variant\"):\n                resources.append(\n                    [resource.__class__.__name__, resource.name, resource.variant]\n                )\n            else:\n                resources.append([resource.__class__.__name__, resource.name, \"\"])\n\n        print(\"Resources to be registered:\")\n        self.__print_state(resources)\n\n    def __print_state(self, data):\n        # Calculate the maximum width for each column\n        max_widths = [max(len(str(item)) for item in col) for col in zip(*data)]\n\n        # Format the table headers\n        headers = \" | \".join(\n            f\"{header:{width}}\" for header, width in zip(data[0], max_widths)\n        )\n\n        # Generate the separator line\n        separator = \"-\" * len(headers)\n\n        # Format the table rows\n        rows = [\n            f\" | \".join(f\"{data[i][j]:{max_widths[j]}}\" for j in range(len(data[i])))\n            for i in range(1, len(data))\n        ]\n\n        # Combine the headers, separator, and rows\n        table = headers + \"\\n\" + separator + \"\\n\" + \"\\n\".join(rows)\n\n        print(table)\n\n    def register_entity(\n        self,\n        name: str,\n        description: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register an entity.\n\n        **Examples**:\n        ``` py\n            user = ff.register_entity(\"user\")\n        ```\n\n        Args:\n            name (str): Name of entity to be registered\n            description (str): Description of entity to be registered\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            entity (EntityRegistrar): Entity\n        \"\"\"\n        entity = Entity(\n            name=name,\n            description=description,\n            status=\"\",\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(entity)\n        return EntityRegistrar(self, entity)\n\n    def register_column_resources(\n        self,\n        source: Union[\n            NameVariant,\n            SourceRegistrar,\n            SQLTransformationDecorator,\n            DFTransformationDecorator,\n        ],\n        entity: Union[str, EntityRegistrar],\n        entity_column: str,\n        owner: Union[str, UserRegistrar] = \"\",\n        inference_store: Union[str, OnlineProvider, FileStoreProvider] = \"\",\n        features: List[ColumnMapping] = None,\n        labels: List[ColumnMapping] = None,\n        timestamp_column: str = \"\",\n        description: str = \"\",\n        schedule: str = \"\",\n        client_object=None,\n    ):\n        \"\"\"Create features and labels from a source. Used in the register_resources function.\n\n        Args:\n            source (Union[NameVariant, SourceRegistrar, SQLTransformationDecorator]): Source of features, labels, entity\n            entity (Union[str, EntityRegistrar]): Entity\n            entity_column (str): Column of entity in source\n            owner (Union[str, UserRegistrar]): Owner\n            inference_store (Union[str, OnlineProvider]): Online provider\n            features (List[ColumnMapping]): List of ColumnMapping objects (dictionaries containing the keys: name, variant, column, resource_type)\n            labels (List[ColumnMapping]): List of ColumnMapping objects (dictionaries containing the keys: name, variant, column, resource_type)\n            description (str): Description\n            schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n\n        Returns:\n            resource (ResourceRegistrar): resource\n        \"\"\"\n\n        if (\n            type(inference_store) == FileStoreProvider\n            and inference_store.store_type() in NON_INFERENCE_STORES\n        ):\n            raise Exception(\n                f\"cannot use '{inference_store.store_type()}' as an inference store.\"\n            )\n\n        if features is None:\n            features = []\n        if labels is None:\n            labels = []\n        if len(features) == 0 and len(labels) == 0:\n            raise ValueError(\"No features or labels set\")\n        if isinstance(source, tuple) and source[1] == \"\":\n            source = source[0], self.__run\n        if not isinstance(entity, str):\n            entity = entity.name()\n        if not isinstance(inference_store, str):\n            inference_store = inference_store.name()\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        feature_resources = []\n        label_resources = []\n        for feature in features:\n            variant = feature.get(\"variant\", \"\")\n            if variant == \"\":\n                variant = self.__run\n            if not ScalarType.has_value(feature[\"type\"]) and not isinstance(\n                feature[\"type\"], ScalarType\n            ):\n                raise ValueError(\n                    f\"Invalid type for feature {feature['name']} ({variant}). Must be a ScalarType or one of {ScalarType.get_values()}\"\n                )\n            if isinstance(feature[\"type\"], ScalarType):\n                feature[\"type\"] = feature[\"type\"].value\n            desc = feature.get(\"description\", \"\")\n            feature_tags = feature.get(\"tags\", [])\n            feature_properties = feature.get(\"properties\", {})\n            additional_Parameters = self._get_additional_parameters(ondemand_feature)\n            is_embedding = feature.get(\"is_embedding\", False)\n            dims = feature.get(\"dims\", 0)\n            value_type = ScalarType(feature[\"type\"])\n            if dims &gt; 0:\n                value_type = VectorType(value_type, dims, is_embedding)\n            resource = FeatureVariant(\n                created=None,\n                name=feature[\"name\"],\n                variant=variant,\n                source=source,\n                value_type=value_type,\n                entity=entity,\n                owner=owner,\n                provider=inference_store,\n                description=desc,\n                schedule=schedule,\n                location=ResourceColumnMapping(\n                    entity=entity_column,\n                    value=feature[\"column\"],\n                    timestamp=timestamp_column,\n                ),\n                tags=feature_tags,\n                properties=feature_properties,\n                additional_parameters=additional_Parameters,\n            )\n            self.__resources.append(resource)\n            self.map_client_object_to_resource(client_object, resource)\n            feature_resources.append(resource)\n\n        for label in labels:\n            variant = label.get(\"variant\", \"\")\n            if variant == \"\":\n                variant = self.__run\n            if not ScalarType.has_value(label[\"type\"]) and not isinstance(\n                label[\"type\"], ScalarType\n            ):\n                raise ValueError(\n                    f\"Invalid type for label {label['name']} ({variant}). Must be a ScalarType or one of {ScalarType.get_values()}\"\n                )\n            if isinstance(label[\"type\"], ScalarType):\n                label[\"type\"] = label[\"type\"].value\n            desc = label.get(\"description\", \"\")\n            label_tags = label.get(\"tags\", [])\n            label_properties = label.get(\"properties\", {})\n            resource = LabelVariant(\n                name=label[\"name\"],\n                variant=variant,\n                source=source,\n                value_type=label[\"type\"],\n                entity=entity,\n                owner=owner,\n                provider=inference_store,\n                description=desc,\n                location=ResourceColumnMapping(\n                    entity=entity_column,\n                    value=label[\"column\"],\n                    timestamp=timestamp_column,\n                ),\n                tags=label_tags,\n                properties=label_properties,\n            )\n            self.__resources.append(resource)\n            self.map_client_object_to_resource(client_object, resource)\n            label_resources.append(resource)\n        return ResourceRegistrar(self, features, labels)\n\n    def _get_additional_parameters(self, feature):\n        return OndemandFeatureParameters(definition=\"() =&gt; REGISTER\")\n\n    def __get_feature_nv(self, features, run):\n        feature_nv_list = []\n        feature_lags = []\n        for feature in features:\n            if isinstance(feature, str):\n                feature_nv_list.append((feature, run))\n            elif isinstance(feature, dict):\n                lag = feature.get(\"lag\")\n                if \"variant\" not in feature:\n                    feature[\"variant\"] = run\n                if lag:\n                    required_lag_keys = set([\"lag\", \"feature\", \"variant\"])\n                    received_lag_keys = set(feature.keys())\n                    if (\n                        required_lag_keys.intersection(received_lag_keys)\n                        != required_lag_keys\n                    ):\n                        raise ValueError(\n                            f\"feature lags require 'lag', 'feature', 'variant' fields. Received: {feature.keys()}\"\n                        )\n\n                    if not isinstance(lag, timedelta):\n                        raise ValueError(\n                            f\"the lag, '{lag}', needs to be of type 'datetime.timedelta'. Received: {type(lag)}.\"\n                        )\n\n                    feature_name_variant = (feature[\"feature\"], feature[\"variant\"])\n                    if feature_name_variant not in feature_nv_list:\n                        feature_nv_list.append(feature_name_variant)\n\n                    lag_name = f\"{feature['feature']}_{feature['variant']}_lag_{lag}\"\n                    sanitized_lag_name = (\n                        lag_name.replace(\" \", \"\").replace(\",\", \"_\").replace(\":\", \"_\")\n                    )\n                    feature[\"name\"] = feature.get(\"name\", sanitized_lag_name)\n\n                    feature_lags.append(feature)\n                else:\n                    feature_nv = (feature[\"name\"], feature[\"variant\"])\n                    feature_nv_list.append(feature_nv)\n            elif isinstance(feature, list):\n                feature_nv, feature_lags_list = self.__get_feature_nv(feature, run)\n                if len(feature_nv) != 0:\n                    feature_nv_list.extend(feature_nv)\n\n                if len(feature_lags_list) != 0:\n                    feature_lags.extend(feature_lags_list)\n            else:\n                feature_nv_list.append(feature)\n\n        return feature_nv_list, feature_lags\n\n    def register_training_set(\n        self,\n        name: str,\n        variant: str = \"\",\n        features: Union[\n            list, List[FeatureColumnResource], MultiFeatureColumnResource\n        ] = [],\n        label: Union[NameVariant, LabelColumnResource] = (\"\", \"\"),\n        resources: list = [],\n        owner: Union[str, UserRegistrar] = \"\",\n        description: str = \"\",\n        schedule: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a training set.\n\n        **Example**:\n        ```\n        ff.register_training_set(\n            name=\"my_training_set\",\n            label=(\"label\", \"v1\"),\n            features=[(\"feature1\", \"v1\"), (\"feature2\", \"v1\")],\n        )\n        ```\n\n        Args:\n            name (str): Name of training set to be registered\n            variant (str): Name of variant to be registered\n            label (NameVariant): Label of training set\n            features (List[NameVariant]): Features of training set\n            resources (List[Resource]): A list of previously registered resources\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of training set to be registered\n            schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            resource (ResourceRegistrar): resource\n        \"\"\"\n        if not isinstance(owner, str):\n            owner = owner.name()\n        if owner == \"\":\n            owner = self.must_get_default_owner()\n        if variant == \"\":\n            variant = self.__run\n\n        if not isinstance(features, (list, MultiFeatureColumnResource)):\n            raise ValueError(\n                f\"Invalid features type: {type(features)} \"\n                \"Features must be entered as a list of name-variant tuples (e.g. [('feature1', 'quickstart'), ('feature2', 'quickstart')]) or a list of FeatureColumnResource instances.\"\n            )\n        if not isinstance(label, (tuple, str, LabelColumnResource)):\n            raise ValueError(\n                f\"Invalid label type: {type(label)} \"\n                \"Label must be entered as a name-variant tuple (e.g. ('fraudulent', 'quickstart')), a resource name, or an instance of LabelColumnResource.\"\n            )\n\n        for resource in resources:\n            features += resource.features()\n            resource_label = resource.label()\n            # label == () if it is NOT manually entered\n            if label == (\"\", \"\"):\n                label = resource_label\n            # Elif: If label was updated to store resource_label it will not check the following elif\n            elif resource_label != ():\n                raise ValueError(\"A training set can only have one label\")\n\n        features, feature_lags = self.__get_feature_nv(features, self.__run)\n        if label == ():\n            raise ValueError(\"Label must be set\")\n        if features == []:\n            raise ValueError(\"A training-set must have atleast one feature\")\n        if isinstance(label, str):\n            label = (label, self.__run)\n        if not isinstance(label, LabelColumnResource) and label[1] == \"\":\n            label = (label[0], self.__run)\n\n        processed_features = []\n        for feature in features:\n            if isinstance(feature, tuple) and feature[1] == \"\":\n                feature = (feature[0], self.__run)\n            processed_features.append(feature)\n        resource = TrainingSetVariant(\n            created=None,\n            name=name,\n            variant=variant,\n            description=description,\n            owner=owner,\n            schedule=schedule,\n            label=label,\n            features=processed_features,\n            feature_lags=feature_lags,\n            tags=tags,\n            properties=properties,\n        )\n        self.__resources.append(resource)\n        return resource\n\n    def register_model(\n        self, name: str, tags: List[str] = [], properties: dict = {}\n    ) -&gt; Model:\n        \"\"\"Register a model.\n\n        Args:\n            name (str): Model to be registered\n            tags (List[str]): Optional grouping mechanism for resources\n            properties (dict): Optional grouping mechanism for resources\n\n        Returns:\n            ModelRegistrar: Model\n        \"\"\"\n        model = Model(name, description=\"\", tags=tags, properties=properties)\n        self.__resources.append(model)\n        return model\n</code></pre>"},{"location":"register/#featureform.register.Registrar.df_transformation","title":"<code>df_transformation(provider, tags, properties, variant='', name='', owner='', description='', inputs=[], args=None)</code>","text":"<p>Dataframe transformation decorator.</p> <p>Parameters:</p> Name Type Description Default <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>provider</code> <code>Union[str, OfflineProvider]</code> <p>Provider</p> required <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of SQL transformation</p> <code>''</code> <code>inputs</code> <code>list</code> <p>Inputs to transformation</p> <code>[]</code> <code>args</code> <code>K8sArgs</code> <p>Additional transformation arguments</p> <code>None</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> required <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> required <p>Returns:</p> Name Type Description <code>decorator</code> <code>DFTransformationDecorator</code> <p>decorator</p> Source code in <code>src/featureform/register.py</code> <pre><code>def df_transformation(\n    self,\n    provider: Union[str, OfflineProvider],\n    tags: List[str],\n    properties: dict,\n    variant: str = \"\",\n    name: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n    inputs: Union[List[NameVariant], List[str], List[ColumnSourceRegistrar]] = [],\n    args: K8sArgs = None,\n):\n    \"\"\"Dataframe transformation decorator.\n\n    Args:\n        variant (str): Name of variant\n        provider (Union[str, OfflineProvider]): Provider\n        name (str): Name of source\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of SQL transformation\n        inputs (list): Inputs to transformation\n        args (K8sArgs): Additional transformation arguments\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        decorator (DFTransformationDecorator): decorator\n    \"\"\"\n\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    if variant == \"\":\n        variant = self.__run\n    if not isinstance(provider, str):\n        provider = provider.name()\n    if not isinstance(inputs, list):\n        raise ValueError(\"Dataframe transformation inputs must be a list\")\n    for i, nv in enumerate(inputs):\n        if isinstance(nv, str):  # TODO remove this functionality\n            inputs[i] = (nv, self.__run)\n        elif isinstance(nv, tuple):\n            try:\n                self._verify_tuple(nv)\n            except TypeError as e:\n                transformation_message = f\"'{name}:{variant}'\"\n                if name == \"\":\n                    transformation_message = f\"with '{variant}' variant\"\n\n                raise TypeError(\n                    f\"DF transformation {transformation_message} requires correct inputs \"\n                    f\" '{nv}' is not a valid tuple: {e}\"\n                )\n            if inputs[i][1] == \"\":\n                inputs[i] = (inputs[i][0], self.__run)\n\n    decorator = DFTransformationDecorator(\n        registrar=self,\n        name=name,\n        variant=variant,\n        provider=provider,\n        owner=owner,\n        description=description,\n        inputs=inputs,\n        args=args,\n        tags=tags,\n        properties=properties,\n    )\n    return decorator\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_bigquery","title":"<code>get_bigquery(name)</code>","text":"<p>Get a BigQuery provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>bigquery = ff.get_bigquery(\"bigquery-quickstart\")\ntransactions = bigquery.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in BigQuery\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of BigQuery provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>bigquery</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_bigquery(self, name):\n    \"\"\"Get a BigQuery provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    bigquery = ff.get_bigquery(\"bigquery-quickstart\")\n    transactions = bigquery.register_table(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        table=\"Transactions\",  # This is the table's name in BigQuery\n    )\n    ```\n\n    Args:\n        name (str): Name of BigQuery provider to be retrieved\n\n    Returns:\n        bigquery (OfflineSQLProvider): Provider\n    \"\"\"\n    mock_config = BigQueryConfig(\n        project_id=\"mock_project\",\n        dataset_id=\"mock_dataset\",\n        credentials=GCPCredentials(\n            project_id=\"mock_project\",\n            credentials_path=\"client/tests/test_files/bigquery_dummy_credentials.json\",\n        ),\n    )\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineSQLProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_blob_store","title":"<code>get_blob_store(name)</code>","text":"<p>Get an Azure Blob provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>azure_blob = ff.get_blob_store(\"azure-blob-quickstart\")\n\naverage_user_transaction.register_resources(\n    entity=user,\n    entity_column=\"user_id\",\n    inference_store=azure_blob,\n    features=[\n        {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Azure blob provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>azure_blob</code> <code>FileStoreProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_blob_store(self, name):\n    \"\"\"Get an Azure Blob provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    azure_blob = ff.get_blob_store(\"azure-blob-quickstart\")\n\n    average_user_transaction.register_resources(\n        entity=user,\n        entity_column=\"user_id\",\n        inference_store=azure_blob,\n        features=[\n            {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n        ],\n    )\n    ```\n\n    Args:\n        name (str): Name of Azure blob provider to be retrieved\n\n    Returns:\n        azure_blob (FileStoreProvider): Provider\n    \"\"\"\n    fake_azure_config = AzureFileStoreConfig(\n        account_name=\"\", account_key=\"\", container_name=\"\", root_path=\"\"\n    )\n    fake_config = OnlineBlobConfig(\n        store_type=\"AZURE\", store_config=fake_azure_config.config()\n    )\n    mock_provider = Provider(\n        name=name, function=\"ONLINE\", description=\"\", team=\"\", config=fake_config\n    )\n    return FileStoreProvider(self, mock_provider, fake_config, \"AZURE\")\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_clickhouse","title":"<code>get_clickhouse(name)</code>","text":"<p>Get a ClickHouse provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>clickhouse = ff.get_clickhouse(\"clickhouse-quickstart\")\ntransactions = clickhouse.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in ClickHouse\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of ClickHouse provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>clickhouse</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_clickhouse(self, name):\n    \"\"\"Get a ClickHouse provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    clickhouse = ff.get_clickhouse(\"clickhouse-quickstart\")\n    transactions = clickhouse.register_table(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        table=\"Transactions\",  # This is the table's name in ClickHouse\n    )\n    ```\n\n    Args:\n        name (str): Name of ClickHouse provider to be retrieved\n\n    Returns:\n        clickhouse (OfflineSQLProvider): Provider\n    \"\"\"\n    mock_config = ClickHouseConfig(\n        host=\"\",\n        port=9000,\n        database=\"\",\n        user=\"\",\n        password=\"\",\n        ssl=False,\n    )\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineSQLProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_dynamodb","title":"<code>get_dynamodb(name)</code>","text":"<p>Get a DynamoDB provider. The returned object can be used as an inference store in feature registration.</p> <p>Examples: <pre><code>dynamodb = ff.get_dynamodb(\"dynamodb-quickstart\")\n\n@ff.entity\nclass User:\n    avg_transactions = ff.Feature(\n        average_user_transaction[[\"user_id\", \"avg_transaction_amt\"]],\n        type=ff.Float32,\n        inference_store=dynamodb,\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of DynamoDB provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>dynamodb</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_dynamodb(self, name: str):\n    \"\"\"Get a DynamoDB provider. The returned object can be used as an inference store in feature registration.\n\n    **Examples**:\n    ``` py\n    dynamodb = ff.get_dynamodb(\"dynamodb-quickstart\")\n\n    @ff.entity\n    class User:\n        avg_transactions = ff.Feature(\n            average_user_transaction[[\"user_id\", \"avg_transaction_amt\"]],\n            type=ff.Float32,\n            inference_store=dynamodb,\n        )\n    ```\n\n    Args:\n        name (str): Name of DynamoDB provider to be retrieved\n\n    Returns:\n        dynamodb (OnlineProvider): Provider\n    \"\"\"\n    mock_config = DynamodbConfig(\n        region=\"\", access_key=\"\", secret_key=\"\", should_import_from_s3=False\n    )\n    mock_provider = Provider(\n        name=name, function=\"ONLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OnlineProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_entity","title":"<code>get_entity(name)</code>","text":"<p>Get an entity. The returned object can be used to register additional resources.</p> <p>Examples:</p> <pre><code>entity = get_entity(\"user\")\ntransactions.register_resources(\n    entity=entity,\n    entity_column=\"customerid\",\n    labels=[\n        {\"name\": \"fraudulent\", \"variant\": \"quickstart\", \"column\": \"isfraud\", \"type\": \"bool\"},\n    ],\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of entity to be retrieved</p> required <p>Returns:     entity (EntityRegistrar): Entity</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_entity(self, name: str):\n    \"\"\"Get an entity. The returned object can be used to register additional resources.\n\n    **Examples**:\n\n    ``` py\n    entity = get_entity(\"user\")\n    transactions.register_resources(\n        entity=entity,\n        entity_column=\"customerid\",\n        labels=[\n            {\"name\": \"fraudulent\", \"variant\": \"quickstart\", \"column\": \"isfraud\", \"type\": \"bool\"},\n        ],\n    )\n    ```\n\n    Args:\n        name (str): Name of entity to be retrieved\n    Returns:\n        entity (EntityRegistrar): Entity\n    \"\"\"\n    fakeEntity = Entity(\n        name=name, description=\"\", status=\"\", tags=[], properties={}\n    )\n    return EntityRegistrar(self, fakeEntity)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_kubernetes","title":"<code>get_kubernetes(name)</code>","text":"<p>Get a k8s provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>k8s = ff.get_kubernetes(\"k8s-azure-quickstart\")\ntransactions = k8s.register_file(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    path=\"path/to/blob\",\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of k8s provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>k8s</code> <code>OfflineK8sProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_kubernetes(self, name):\n    \"\"\"\n    Get a k8s provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n\n    k8s = ff.get_kubernetes(\"k8s-azure-quickstart\")\n    transactions = k8s.register_file(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        path=\"path/to/blob\",\n    )\n    ```\n\n    Args:\n        name (str): Name of k8s provider to be retrieved\n\n    Returns:\n        k8s (OfflineK8sProvider): Provider\n    \"\"\"\n    mock_config = K8sConfig(store_type=\"\", store_config={})\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineK8sProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_mongodb","title":"<code>get_mongodb(name)</code>","text":"<p>Get a MongoDB provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>mongodb = ff.get_mongodb(\"mongodb-quickstart\")\n\naverage_user_transaction.register_resources(\n    entity=user,\n    entity_column=\"user_id\",\n    inference_store=mongodb,\n    features=[\n        {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of MongoDB provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>mongodb</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_mongodb(self, name: str):\n    \"\"\"Get a MongoDB provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    mongodb = ff.get_mongodb(\"mongodb-quickstart\")\n\n    average_user_transaction.register_resources(\n        entity=user,\n        entity_column=\"user_id\",\n        inference_store=mongodb,\n        features=[\n            {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n        ],\n    )\n    ```\n\n    Args:\n        name (str): Name of MongoDB provider to be retrieved\n\n    Returns:\n        mongodb (OnlineProvider): Provider\n    \"\"\"\n    mock_config = MongoDBConfig(\n        username=\"\", password=\"\", host=\"\", port=\"\", database=\"\", throughput=1\n    )\n    mock_provider = Provider(\n        name=name, function=\"ONLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OnlineProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_postgres","title":"<code>get_postgres(name)</code>","text":"<p>Get a Postgres provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>postgres = ff.get_postgres(\"postgres-quickstart\")\ntransactions = postgres.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in Postgres\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Postgres provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>postgres</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_postgres(self, name):\n    \"\"\"Get a Postgres provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    postgres = ff.get_postgres(\"postgres-quickstart\")\n    transactions = postgres.register_table(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        table=\"Transactions\",  # This is the table's name in Postgres\n    )\n    ```\n\n    Args:\n        name (str): Name of Postgres provider to be retrieved\n\n    Returns:\n        postgres (OfflineSQLProvider): Provider\n    \"\"\"\n    mock_config = PostgresConfig(\n        host=\"\",\n        port=\"\",\n        database=\"\",\n        user=\"\",\n        password=\"\",\n        sslmode=\"\",\n    )\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineSQLProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_redis","title":"<code>get_redis(name)</code>","text":"<p>Get a Redis provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>redis = ff.get_redis(\"redis-quickstart\")\n\naverage_user_transaction.register_resources(\n    entity=user,\n    entity_column=\"user_id\",\n    inference_store=redis,\n    features=[\n        {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Redis provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>redis</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_redis(self, name):\n    \"\"\"Get a Redis provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    redis = ff.get_redis(\"redis-quickstart\")\n\n    average_user_transaction.register_resources(\n        entity=user,\n        entity_column=\"user_id\",\n        inference_store=redis,\n        features=[\n            {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"avg_transaction_amt\", \"type\": \"float32\"},\n        ],\n    )\n    ```\n\n    Args:\n        name (str): Name of Redis provider to be retrieved\n\n    Returns:\n        redis (OnlineProvider): Provider\n    \"\"\"\n    mock_config = RedisConfig(host=\"\", port=123, password=\"\", db=123)\n    mock_provider = Provider(\n        name=name, function=\"ONLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OnlineProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_redshift","title":"<code>get_redshift(name)</code>","text":"<p>Get a Redshift provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>redshift = ff.get_redshift(\"redshift-quickstart\")\ntransactions = redshift.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in Postgres\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Redshift provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>redshift</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_redshift(self, name):\n    \"\"\"Get a Redshift provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    redshift = ff.get_redshift(\"redshift-quickstart\")\n    transactions = redshift.register_table(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        table=\"Transactions\",  # This is the table's name in Postgres\n    )\n    ```\n\n    Args:\n        name (str): Name of Redshift provider to be retrieved\n\n    Returns:\n        redshift (OfflineSQLProvider): Provider\n    \"\"\"\n    mock_config = RedshiftConfig(\n        host=\"\", port=\"5439\", database=\"\", user=\"\", password=\"\", sslmode=\"\"\n    )\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineSQLProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_run","title":"<code>get_run()</code>","text":"<p>Get the current run name.</p> <p>Examples: <pre><code>import featureform as ff\n\nclient = ff.Client()\nf = client.features((\"avg_transaction_amount\", ff.get_run()), {\"user\": \"123\"})\n</code></pre></p> <p>Returns:</p> Name Type Description <code>run</code> <code>str</code> <p>The name of the current run</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_run(self) -&gt; str:\n    \"\"\"\n    Get the current run name.\n\n    **Examples**:\n    ``` py\n    import featureform as ff\n\n    client = ff.Client()\n    f = client.features((\"avg_transaction_amount\", ff.get_run()), {\"user\": \"123\"})\n\n    ```\n\n    Returns:\n        run: The name of the current run\n    \"\"\"\n    return self.__run\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_s3","title":"<code>get_s3(name)</code>","text":"<p>Get a S3 provider. The returned object can be used with other providers such as Spark and Databricks.</p> <p>Examples:</p> <pre><code>s3 = ff.get_s3(\"s3-quickstart\")\nspark = ff.register_spark(\n    name=f\"spark-emr-s3\",\n    description=\"A Spark deployment we created for the Featureform quickstart\",\n    team=\"featureform-team\",\n    executor=emr,\n    filestore=s3,\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of S3 to be retrieved</p> required <p>Returns:</p> Name Type Description <code>s3</code> <code>FileStore</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_s3(self, name):\n    \"\"\"\n    Get a S3 provider. The returned object can be used with other providers such as Spark and Databricks.\n\n    **Examples**:\n\n    ``` py\n\n    s3 = ff.get_s3(\"s3-quickstart\")\n    spark = ff.register_spark(\n        name=f\"spark-emr-s3\",\n        description=\"A Spark deployment we created for the Featureform quickstart\",\n        team=\"featureform-team\",\n        executor=emr,\n        filestore=s3,\n    )\n    ```\n\n    Args:\n        name (str): Name of S3 to be retrieved\n\n    Returns:\n        s3 (FileStore): Provider\n    \"\"\"\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=\"description\",\n        team=\"team\",\n        config=s3_config,\n    )\n    return FileStoreProvider(\n        registrar=self,\n        provider=provider,\n        config=s3_config,\n        store_type=s3_config.type(),\n    )\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_snowflake","title":"<code>get_snowflake(name)</code>","text":"<p>Get a Snowflake provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>snowflake = ff.get_snowflake(\"snowflake-quickstart\")\ntransactions = snowflake.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in Postgres\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Snowflake provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_snowflake(self, name):\n    \"\"\"Get a Snowflake provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    snowflake = ff.get_snowflake(\"snowflake-quickstart\")\n    transactions = snowflake.register_table(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        table=\"Transactions\",  # This is the table's name in Postgres\n    )\n    ```\n\n    Args:\n        name (str): Name of Snowflake provider to be retrieved\n\n    Returns:\n        snowflake (OfflineSQLProvider): Provider\n    \"\"\"\n    mock_config = SnowflakeConfig(\n        account=\"ff_fake\",\n        database=\"ff_fake\",\n        organization=\"ff_fake\",\n        username=\"ff_fake\",\n        password=\"ff_fake\",\n        schema=\"ff_fake\",\n    )\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineSQLProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_snowflake_legacy","title":"<code>get_snowflake_legacy(name)</code>","text":"<p>Get a Snowflake provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>snowflake = ff.get_snowflake_legacy(\"snowflake-quickstart\")\ntransactions = snowflake.register_table(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    table=\"Transactions\",  # This is the table's name in Postgres\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Snowflake provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>snowflake_legacy</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_snowflake_legacy(self, name: str):\n    \"\"\"Get a Snowflake provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    snowflake = ff.get_snowflake_legacy(\"snowflake-quickstart\")\n    transactions = snowflake.register_table(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        table=\"Transactions\",  # This is the table's name in Postgres\n    )\n    ```\n\n    Args:\n        name (str): Name of Snowflake provider to be retrieved\n\n    Returns:\n        snowflake_legacy (OfflineSQLProvider): Provider\n    \"\"\"\n    mock_config = SnowflakeConfig(\n        account_locator=\"ff_fake\",\n        database=\"ff_fake\",\n        username=\"ff_fake\",\n        password=\"ff_fake\",\n        schema=\"ff_fake\",\n        warehouse=\"ff_fake\",\n        role=\"ff_fake\",\n    )\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineSQLProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_source","title":"<code>get_source(name, variant, local=False)</code>","text":"<p>get_source() can be used to get a reference to an already registered primary source or transformation. The returned object can be used to register features and labels or be extended off of to create additional transformations.</p> <p>Examples:</p> <p>Registering a transformation from an existing source. <pre><code>spark = ff.get_spark(\"prod-spark\")\ntransactions = ff.get_source(\"transactions\",\"kaggle\")\n\n@spark.df_transformation(inputs=[transactions]):\ndef customer_count(transactions):\n    return transactions.groupBy(\"CustomerID\").count()\n</code></pre></p> <p>Registering a feature from an existing source. <pre><code>transactions = ff.get_source(\"transactions\",\"kaggle\")\n\ntransactions.register_resources(\n    entity=user,\n    entity_column=\"customerid\",\n    labels=[\n        {\"name\": \"fraudulent\", \"variant\": \"quickstart\", \"column\": \"isfraud\", \"type\": \"bool\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source to be retrieved</p> required <code>variant</code> <code>str</code> <p>Name of variant of source to be retrieved</p> required <code>local</code> <code>bool</code> <p>If localmode is being used</p> <code>False</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_source(self, name, variant, local=False):\n    \"\"\"\n    get_source() can be used to get a reference to an already registered primary source or transformation.\n    The returned object can be used to register features and labels or be extended off of to create additional\n    transformations.\n\n    **Examples**:\n\n    Registering a transformation from an existing source.\n    ``` py\n    spark = ff.get_spark(\"prod-spark\")\n    transactions = ff.get_source(\"transactions\",\"kaggle\")\n\n    @spark.df_transformation(inputs=[transactions]):\n    def customer_count(transactions):\n        return transactions.groupBy(\"CustomerID\").count()\n    ```\n\n    Registering a feature from an existing source.\n    ``` py\n    transactions = ff.get_source(\"transactions\",\"kaggle\")\n\n    transactions.register_resources(\n        entity=user,\n        entity_column=\"customerid\",\n        labels=[\n            {\"name\": \"fraudulent\", \"variant\": \"quickstart\", \"column\": \"isfraud\", \"type\": \"bool\"},\n        ],\n    )\n    ```\n\n    Args:\n        name (str): Name of source to be retrieved\n        variant (str): Name of variant of source to be retrieved\n        local (bool): If localmode is being used\n\n    Returns:\n        source (ColumnSourceRegistrar): Source\n    \"\"\"\n    if local:\n        raise Exception(\n            \"Localmode is not supported; please try featureform &lt;= 1.12.0\"\n        )\n    else:\n        mock_definition = PrimaryData(location=SQLTable(name=\"\"))\n        mock_source = SourceVariant(\n            created=None,\n            name=name,\n            variant=variant,\n            definition=mock_definition,\n            owner=\"\",\n            provider=\"\",\n            description=\"\",\n            tags=[],\n            properties={},\n        )\n        return ColumnSourceRegistrar(self, mock_source)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_spark","title":"<code>get_spark(name)</code>","text":"<p>Get a Spark provider. The returned object can be used to register additional resources.</p> <p>Examples: <pre><code>spark = ff.get_spark(\"spark-quickstart\")\ntransactions = spark.register_file(\n    name=\"transactions\",\n    variant=\"kaggle\",\n    description=\"Fraud Dataset From Kaggle\",\n    file_path=\"s3://bucket/path/to/file/transactions.parquet\",  # This is the path to file\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of Spark provider to be retrieved</p> required <p>Returns:</p> Name Type Description <code>spark</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_spark(self, name):\n    \"\"\"Get a Spark provider. The returned object can be used to register additional resources.\n\n    **Examples**:\n    ``` py\n    spark = ff.get_spark(\"spark-quickstart\")\n    transactions = spark.register_file(\n        name=\"transactions\",\n        variant=\"kaggle\",\n        description=\"Fraud Dataset From Kaggle\",\n        file_path=\"s3://bucket/path/to/file/transactions.parquet\",  # This is the path to file\n    )\n    ```\n\n    Args:\n        name (str): Name of Spark provider to be retrieved\n\n    Returns:\n        spark (OfflineSQLProvider): Provider\n    \"\"\"\n    mock_config = SparkConfig(\n        executor_type=\"\", executor_config={}, store_type=\"\", store_config={}\n    )\n    mock_provider = Provider(\n        name=name, function=\"OFFLINE\", description=\"\", team=\"\", config=mock_config\n    )\n    return OfflineSparkProvider(self, mock_provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.get_state","title":"<code>get_state()</code>","text":"<p>Get the state of the resources to be registered.</p> <p>Returns:</p> Name Type Description <code>resources</code> <code>List[str]</code> <p>List of resources to be registered ex. \"{type} - {name} ({variant})\"</p> Source code in <code>src/featureform/register.py</code> <pre><code>def get_state(self):\n    \"\"\"\n    Get the state of the resources to be registered.\n\n    Returns:\n        resources (List[str]): List of resources to be registered ex. \"{type} - {name} ({variant})\"\n    \"\"\"\n    if len(self.__resources) == 0:\n        return \"No resources to be registered\"\n\n    resources = [[\"Type\", \"Name\", \"Variant\"]]\n    for resource in self.__resources:\n        if hasattr(resource, \"variant\"):\n            resources.append(\n                [resource.__class__.__name__, resource.name, resource.variant]\n            )\n        else:\n            resources.append([resource.__class__.__name__, resource.name, \"\"])\n\n    print(\"Resources to be registered:\")\n    self.__print_state(resources)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.ondemand_feature","title":"<code>ondemand_feature(fn=None, *, tags=[], properties={}, variant='', name='', owner='', description='')</code>","text":"<p>On Demand Feature decorator.</p> <p>Examples <pre><code>import featureform as ff\n\n@ff.ondemand_feature()\ndef avg_user_transactions(client, params, entities):\n    pass\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of on demand feature</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>decorator</code> <code>OnDemandFeature</code> <p>decorator</p> Source code in <code>src/featureform/register.py</code> <pre><code>def ondemand_feature(\n    self,\n    fn=None,\n    *,\n    tags: List[str] = [],\n    properties: dict = {},\n    variant: str = \"\",\n    name: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n):\n    \"\"\"On Demand Feature decorator.\n\n    **Examples**\n    ```python\n    import featureform as ff\n\n    @ff.ondemand_feature()\n    def avg_user_transactions(client, params, entities):\n        pass\n    ```\n\n    Args:\n        variant (str): Name of variant\n        name (str): Name of source\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of on demand feature\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        decorator (OnDemandFeature): decorator\n\n    \"\"\"\n\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    if variant == \"\":\n        variant = self.__run\n    decorator = OnDemandFeatureVariant(\n        name=name,\n        variant=variant,\n        owner=owner,\n        description=description,\n        tags=tags or [],\n        properties=properties or {},\n    )\n\n    self.__resources.append(decorator)\n\n    if fn is None:\n        return decorator\n    else:\n        return decorator(fn)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_bigquery","title":"<code>register_bigquery(name, project_id, dataset_id, credentials, credentials_path='', description='', team='', tags=[], properties={})</code>","text":"<p>Register a BigQuery provider.</p> <p>Examples: <pre><code>bigquery = ff.register_bigquery(\n    name=\"bigquery-quickstart\",\n    description=\"A BigQuery deployment we created for the Featureform quickstart\",\n    project_id=\"quickstart-project\",\n    dataset_id=\"quickstart-dataset\",\n    credentials=GCPCredentials(...)\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of BigQuery provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) The Project name in GCP</p> required <code>dataset_id</code> <code>str</code> <p>(Immutable) The Dataset name in GCP under the Project Id</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access BigQuery</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of BigQuery provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bigquery</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_bigquery(\n    self,\n    name: str,\n    project_id: str,\n    dataset_id: str,\n    credentials: GCPCredentials,\n    credentials_path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a BigQuery provider.\n\n    **Examples**:\n    ```\n    bigquery = ff.register_bigquery(\n        name=\"bigquery-quickstart\",\n        description=\"A BigQuery deployment we created for the Featureform quickstart\",\n        project_id=\"quickstart-project\",\n        dataset_id=\"quickstart-dataset\",\n        credentials=GCPCredentials(...)\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of BigQuery provider to be registered\n        project_id (str): (Immutable) The Project name in GCP\n        dataset_id (str): (Immutable) The Dataset name in GCP under the Project Id\n        credentials (GCPCredentials): (Mutable) GCP credentials to access BigQuery\n        description (str): (Mutable) Description of BigQuery provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        bigquery (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n\n    config = BigQueryConfig(\n        project_id=project_id,\n        dataset_id=dataset_id,\n        credentials=credentials,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_blob_store","title":"<code>register_blob_store(name, account_name, account_key, container_name, root_path, description='', team='', tags=None, properties=None)</code>","text":"<p>Register an Azure Blob Store provider.</p> <p>Azure Blob Storage can be used as the storage component for Spark or the Featureform Pandas Runner.</p> <p>Examples: <pre><code>blob = ff.register_blob_store(\n    name=\"azure-quickstart\",\n    container_name=\"my_company_container\"\n    root_path=\"custom/path/in/container\"\n    account_name=&lt;azure_account_name&gt;\n    account_key=&lt;azure_account_key&gt;\n    description=\"An azure blob store provider to store offline and inference data\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Azure blob store to be registered</p> required <code>container_name</code> <code>str</code> <p>(Immutable) Azure container name</p> required <code>root_path</code> <code>str</code> <p>(Immutable) A custom path in container to store data</p> required <code>account_name</code> <code>str</code> <p>(Immutable) Azure account name</p> required <code>account_key</code> <code>str</code> <p>(Mutable) Secret azure account key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Azure Blob provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <p>Returns:</p> Name Type Description <code>blob</code> <code>StorageProvider</code> <p>Provider has all the functionality of OnlineProvider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_blob_store(\n    self,\n    name: str,\n    account_name: str,\n    account_key: str,\n    container_name: str,\n    root_path: str,\n    description: str = \"\",\n    team: str = \"\",\n    tags=None,\n    properties=None,\n):\n    \"\"\"Register an Azure Blob Store provider.\n\n    Azure Blob Storage can be used as the storage component for Spark or the Featureform Pandas Runner.\n\n    **Examples**:\n    ```\n    blob = ff.register_blob_store(\n        name=\"azure-quickstart\",\n        container_name=\"my_company_container\"\n        root_path=\"custom/path/in/container\"\n        account_name=&lt;azure_account_name&gt;\n        account_key=&lt;azure_account_key&gt;\n        description=\"An azure blob store provider to store offline and inference data\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Azure blob store to be registered\n        container_name (str): (Immutable) Azure container name\n        root_path (str): (Immutable) A custom path in container to store data\n        account_name (str): (Immutable) Azure account name\n        account_key (str):  (Mutable) Secret azure account key\n        description (str): (Mutable) Description of Azure Blob provider to be registered\n        team (str): (Mutable) The name of the team registering the filestore\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        blob (StorageProvider): Provider\n            has all the functionality of OnlineProvider\n    \"\"\"\n\n    tags, properties = set_tags_properties(tags, properties)\n\n    container_name = container_name.replace(\"abfss://\", \"\")\n    if \"/\" in container_name:\n        raise ValueError(\n            \"container_name cannot contain '/'. container_name should be the name of the Azure Blobstore container only.\"\n        )\n\n    azure_config = AzureFileStoreConfig(\n        account_name=account_name,\n        account_key=account_key,\n        container_name=container_name,\n        root_path=root_path,\n    )\n    config = OnlineBlobConfig(\n        store_type=\"AZURE\", store_config=azure_config.config()\n    )\n\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return FileStoreProvider(self, provider, azure_config, \"AZURE\")\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_cassandra","title":"<code>register_cassandra(name, host, port, username, password, keyspace, consistency='THREE', replication=3, description='', team='', tags=[], properties={})</code>","text":"<p>Register a Cassandra provider.</p> <p>Examples: <pre><code>cassandra = ff.register_cassandra(\n        name = \"cassandra\",\n        description = \"Example inference store\",\n        team = \"Featureform\",\n        host = \"0.0.0.0\",\n        port = 9042,\n        username = \"cassandra\",\n        password = \"cassandra\",\n        consistency = \"THREE\",\n        replication = 3\n    )\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Cassandra provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) DNS name of Cassandra</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> required <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>consistency</code> <code>str</code> <p>(Mutable) Consistency</p> <code>'THREE'</code> <code>replication</code> <code>int</code> <p>(Mutable) Replication</p> <code>3</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Cassandra provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>cassandra</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_cassandra(\n    self,\n    name: str,\n    host: str,\n    port: int,\n    username: str,\n    password: str,\n    keyspace: str,\n    consistency: str = \"THREE\",\n    replication: int = 3,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Cassandra provider.\n\n    **Examples**:\n    ```\n    cassandra = ff.register_cassandra(\n            name = \"cassandra\",\n            description = \"Example inference store\",\n            team = \"Featureform\",\n            host = \"0.0.0.0\",\n            port = 9042,\n            username = \"cassandra\",\n            password = \"cassandra\",\n            consistency = \"THREE\",\n            replication = 3\n        )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Cassandra provider to be registered\n        host (str): (Immutable) DNS name of Cassandra\n        port (str): (Mutable) Port\n        username (str): (Mutable) Username\n        password (str): (Mutable) Password\n        consistency (str): (Mutable) Consistency\n        replication (int): (Mutable) Replication\n        description (str): (Mutable) Description of Cassandra provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        cassandra (OnlineProvider): Provider\n    \"\"\"\n    config = CassandraConfig(\n        host=host,\n        port=port,\n        username=username,\n        password=password,\n        keyspace=keyspace,\n        consistency=consistency,\n        replication=replication,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_clickhouse","title":"<code>register_clickhouse(name, host, user, password, database, port=9000, description='', team='', ssl=False, tags=[], properties={})</code>","text":"<p>Register a ClickHouse provider.</p> <p>Examples: <pre><code>clickhouse = ff.register_clickhouse(\n    name=\"clickhouse-quickstart\",\n    description=\"A ClickHouse deployment we created for the Featureform quickstart\",\n    host=\"quickstart-clickhouse\",  # The internal dns name for clickhouse\n    port=9000,\n    user=\"default\",\n    password=\"\", #pragma: allowlist secret\n    database=\"default\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of ClickHouse provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for ClickHouse</p> required <code>database</code> <code>str</code> <p>(Immutable) ClickHouse database</p> required <code>port</code> <code>int</code> <p>(Mutable) Port</p> <code>9000</code> <code>ssl</code> <code>bool</code> <p>(Mutable) Enable SSL</p> <code>False</code> <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) ClickHouse password</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of ClickHouse provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>clickhouse</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_clickhouse(\n    self,\n    name: str,\n    host: str,\n    user: str,\n    password: str,\n    database: str,\n    port: int = 9000,\n    description: str = \"\",\n    team: str = \"\",\n    ssl: bool = False,\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a ClickHouse provider.\n\n    **Examples**:\n    ```\n    clickhouse = ff.register_clickhouse(\n        name=\"clickhouse-quickstart\",\n        description=\"A ClickHouse deployment we created for the Featureform quickstart\",\n        host=\"quickstart-clickhouse\",  # The internal dns name for clickhouse\n        port=9000,\n        user=\"default\",\n        password=\"\", #pragma: allowlist secret\n        database=\"default\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of ClickHouse provider to be registered\n        host (str): (Immutable) Hostname for ClickHouse\n        database (str): (Immutable) ClickHouse database\n        port (int): (Mutable) Port\n        ssl (bool): (Mutable) Enable SSL\n        user (str): (Mutable) User\n        password (str): (Mutable) ClickHouse password\n        description (str): (Mutable) Description of ClickHouse provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        clickhouse (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = ClickHouseConfig(\n        host=host,\n        port=port,\n        database=database,\n        user=user,\n        password=password,\n        ssl=ssl,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_column_resources","title":"<code>register_column_resources(source, entity, entity_column, owner='', inference_store='', features=None, labels=None, timestamp_column='', description='', schedule='', client_object=None)</code>","text":"<p>Create features and labels from a source. Used in the register_resources function.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[NameVariant, SourceRegistrar, SQLTransformationDecorator]</code> <p>Source of features, labels, entity</p> required <code>entity</code> <code>Union[str, EntityRegistrar]</code> <p>Entity</p> required <code>entity_column</code> <code>str</code> <p>Column of entity in source</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>inference_store</code> <code>Union[str, OnlineProvider]</code> <p>Online provider</p> <code>''</code> <code>features</code> <code>List[ColumnMapping]</code> <p>List of ColumnMapping objects (dictionaries containing the keys: name, variant, column, resource_type)</p> <code>None</code> <code>labels</code> <code>List[ColumnMapping]</code> <p>List of ColumnMapping objects (dictionaries containing the keys: name, variant, column, resource_type)</p> <code>None</code> <code>description</code> <code>str</code> <p>Description</p> <code>''</code> <code>schedule</code> <code>str</code> <p>Kubernetes CronJob schedule string (\" * * * \")</p> <code>''</code> <p>Returns:</p> Name Type Description <code>resource</code> <code>ResourceRegistrar</code> <p>resource</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_column_resources(\n    self,\n    source: Union[\n        NameVariant,\n        SourceRegistrar,\n        SQLTransformationDecorator,\n        DFTransformationDecorator,\n    ],\n    entity: Union[str, EntityRegistrar],\n    entity_column: str,\n    owner: Union[str, UserRegistrar] = \"\",\n    inference_store: Union[str, OnlineProvider, FileStoreProvider] = \"\",\n    features: List[ColumnMapping] = None,\n    labels: List[ColumnMapping] = None,\n    timestamp_column: str = \"\",\n    description: str = \"\",\n    schedule: str = \"\",\n    client_object=None,\n):\n    \"\"\"Create features and labels from a source. Used in the register_resources function.\n\n    Args:\n        source (Union[NameVariant, SourceRegistrar, SQLTransformationDecorator]): Source of features, labels, entity\n        entity (Union[str, EntityRegistrar]): Entity\n        entity_column (str): Column of entity in source\n        owner (Union[str, UserRegistrar]): Owner\n        inference_store (Union[str, OnlineProvider]): Online provider\n        features (List[ColumnMapping]): List of ColumnMapping objects (dictionaries containing the keys: name, variant, column, resource_type)\n        labels (List[ColumnMapping]): List of ColumnMapping objects (dictionaries containing the keys: name, variant, column, resource_type)\n        description (str): Description\n        schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n\n    Returns:\n        resource (ResourceRegistrar): resource\n    \"\"\"\n\n    if (\n        type(inference_store) == FileStoreProvider\n        and inference_store.store_type() in NON_INFERENCE_STORES\n    ):\n        raise Exception(\n            f\"cannot use '{inference_store.store_type()}' as an inference store.\"\n        )\n\n    if features is None:\n        features = []\n    if labels is None:\n        labels = []\n    if len(features) == 0 and len(labels) == 0:\n        raise ValueError(\"No features or labels set\")\n    if isinstance(source, tuple) and source[1] == \"\":\n        source = source[0], self.__run\n    if not isinstance(entity, str):\n        entity = entity.name()\n    if not isinstance(inference_store, str):\n        inference_store = inference_store.name()\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    feature_resources = []\n    label_resources = []\n    for feature in features:\n        variant = feature.get(\"variant\", \"\")\n        if variant == \"\":\n            variant = self.__run\n        if not ScalarType.has_value(feature[\"type\"]) and not isinstance(\n            feature[\"type\"], ScalarType\n        ):\n            raise ValueError(\n                f\"Invalid type for feature {feature['name']} ({variant}). Must be a ScalarType or one of {ScalarType.get_values()}\"\n            )\n        if isinstance(feature[\"type\"], ScalarType):\n            feature[\"type\"] = feature[\"type\"].value\n        desc = feature.get(\"description\", \"\")\n        feature_tags = feature.get(\"tags\", [])\n        feature_properties = feature.get(\"properties\", {})\n        additional_Parameters = self._get_additional_parameters(ondemand_feature)\n        is_embedding = feature.get(\"is_embedding\", False)\n        dims = feature.get(\"dims\", 0)\n        value_type = ScalarType(feature[\"type\"])\n        if dims &gt; 0:\n            value_type = VectorType(value_type, dims, is_embedding)\n        resource = FeatureVariant(\n            created=None,\n            name=feature[\"name\"],\n            variant=variant,\n            source=source,\n            value_type=value_type,\n            entity=entity,\n            owner=owner,\n            provider=inference_store,\n            description=desc,\n            schedule=schedule,\n            location=ResourceColumnMapping(\n                entity=entity_column,\n                value=feature[\"column\"],\n                timestamp=timestamp_column,\n            ),\n            tags=feature_tags,\n            properties=feature_properties,\n            additional_parameters=additional_Parameters,\n        )\n        self.__resources.append(resource)\n        self.map_client_object_to_resource(client_object, resource)\n        feature_resources.append(resource)\n\n    for label in labels:\n        variant = label.get(\"variant\", \"\")\n        if variant == \"\":\n            variant = self.__run\n        if not ScalarType.has_value(label[\"type\"]) and not isinstance(\n            label[\"type\"], ScalarType\n        ):\n            raise ValueError(\n                f\"Invalid type for label {label['name']} ({variant}). Must be a ScalarType or one of {ScalarType.get_values()}\"\n            )\n        if isinstance(label[\"type\"], ScalarType):\n            label[\"type\"] = label[\"type\"].value\n        desc = label.get(\"description\", \"\")\n        label_tags = label.get(\"tags\", [])\n        label_properties = label.get(\"properties\", {})\n        resource = LabelVariant(\n            name=label[\"name\"],\n            variant=variant,\n            source=source,\n            value_type=label[\"type\"],\n            entity=entity,\n            owner=owner,\n            provider=inference_store,\n            description=desc,\n            location=ResourceColumnMapping(\n                entity=entity_column,\n                value=label[\"column\"],\n                timestamp=timestamp_column,\n            ),\n            tags=label_tags,\n            properties=label_properties,\n        )\n        self.__resources.append(resource)\n        self.map_client_object_to_resource(client_object, resource)\n        label_resources.append(resource)\n    return ResourceRegistrar(self, features, labels)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_df_transformation","title":"<code>register_df_transformation(name, query, provider, variant='', owner='', description='', inputs=[], schedule='', args=None, tags=[], properties={})</code>","text":"<p>Register a Dataframe transformation source.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> required <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>query</code> <code>str</code> <p>SQL query</p> required <code>provider</code> <code>Union[str, OfflineProvider]</code> <p>Provider</p> required <code>name</code> <code>str</code> <p>Name of source</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of SQL transformation</p> <code>''</code> <code>inputs</code> <code>list</code> <p>Inputs to transformation</p> <code>[]</code> <code>schedule</code> <code>str</code> <p>Kubernetes CronJob schedule string (\" * * * \")</p> <code>''</code> <code>args</code> <code>K8sArgs</code> <p>Additional transformation arguments</p> <code>None</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_df_transformation(\n    self,\n    name: str,\n    query: str,\n    provider: Union[str, OfflineProvider],\n    variant: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n    inputs: list = [],\n    schedule: str = \"\",\n    args: K8sArgs = None,\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Dataframe transformation source.\n\n    Args:\n        name (str): Name of source\n        variant (str): Name of variant\n        query (str): SQL query\n        provider (Union[str, OfflineProvider]): Provider\n        name (str): Name of source\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of SQL transformation\n        inputs (list): Inputs to transformation\n        schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n        args (K8sArgs): Additional transformation arguments\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        source (ColumnSourceRegistrar): Source\n    \"\"\"\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    if variant == \"\":\n        variant = self.__run\n    if not isinstance(provider, str):\n        provider = provider.name()\n    source = SourceVariant(\n        created=None,\n        name=name,\n        variant=variant,\n        definition=DFTransformation(query, inputs, args),\n        owner=owner,\n        schedule=schedule,\n        provider=provider,\n        description=description,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(source)\n    return ColumnSourceRegistrar(self, source)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_dynamodb","title":"<code>register_dynamodb(name, credentials, region, should_import_from_s3=False, description='', team='', tags=[], properties={})</code>","text":"<p>Register a DynamoDB provider.</p> <p>Examples: <pre><code>dynamodb = ff.register_dynamodb(\n    name=\"dynamodb-quickstart\",\n    description=\"A Dynamodb deployment we created for the Featureform quickstart\",\n    credentials=aws_creds,\n    region=\"us-east-1\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of DynamoDB provider to be registered</p> required <code>region</code> <code>str</code> <p>(Immutable) Region to create dynamo tables</p> required <code>credentials</code> <code>AWSCredentials</code> <p>(Mutable) AWS credentials with permissions to create DynamoDB tables</p> required <code>should_import_from_s3</code> <code>bool</code> <p>(Mutable) Determines whether feature materialization will occur via a direct import of data from S3 to new table (see docs for details)</p> <code>False</code> <code>description</code> <code>str</code> <p>(Mutable) Description of DynamoDB provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dynamodb</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_dynamodb(\n    self,\n    name: str,\n    credentials: AWSCredentials,\n    region: str,\n    should_import_from_s3: bool = False,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a DynamoDB provider.\n\n    **Examples**:\n    ```\n    dynamodb = ff.register_dynamodb(\n        name=\"dynamodb-quickstart\",\n        description=\"A Dynamodb deployment we created for the Featureform quickstart\",\n        credentials=aws_creds,\n        region=\"us-east-1\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of DynamoDB provider to be registered\n        region (str): (Immutable) Region to create dynamo tables\n        credentials (AWSCredentials): (Mutable) AWS credentials with permissions to create DynamoDB tables\n        should_import_from_s3 (bool): (Mutable) Determines whether feature materialization will occur via a direct import of data from S3 to new table (see [docs](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/S3DataImport.HowItWorks.html) for details)\n        description (str): (Mutable) Description of DynamoDB provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        dynamodb (OnlineProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = DynamodbConfig(\n        access_key=credentials.access_key,\n        secret_key=credentials.secret_key,\n        region=region,\n        should_import_from_s3=should_import_from_s3,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_entity","title":"<code>register_entity(name, description='', tags=[], properties={})</code>","text":"<p>Register an entity.</p> <p>Examples: <pre><code>    user = ff.register_entity(\"user\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of entity to be registered</p> required <code>description</code> <code>str</code> <p>Description of entity to be registered</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>entity</code> <code>EntityRegistrar</code> <p>Entity</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_entity(\n    self,\n    name: str,\n    description: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register an entity.\n\n    **Examples**:\n    ``` py\n        user = ff.register_entity(\"user\")\n    ```\n\n    Args:\n        name (str): Name of entity to be registered\n        description (str): Description of entity to be registered\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        entity (EntityRegistrar): Entity\n    \"\"\"\n    entity = Entity(\n        name=name,\n        description=description,\n        status=\"\",\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(entity)\n    return EntityRegistrar(self, entity)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_firestore","title":"<code>register_firestore(name, collection, project_id, credentials, credentials_path='', description='', team='', tags=[], properties={})</code>","text":"<p>Register a Firestore provider.</p> <p>Examples: <pre><code>firestore = ff.register_firestore(\n    name=\"firestore-quickstart\",\n    description=\"A Firestore deployment we created for the Featureform quickstart\",\n    project_id=\"quickstart-project\",\n    collection=\"quickstart-collection\",\n    credentials=ff.GCPCredentials(...)\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Firestore provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) The Project name in GCP</p> required <code>collection</code> <code>str</code> <p>(Immutable) The Collection name in Firestore under the given project ID</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access Firestore</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Firestore provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>firestore</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_firestore(\n    self,\n    name: str,\n    collection: str,\n    project_id: str,\n    credentials: GCPCredentials,\n    credentials_path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Firestore provider.\n\n    **Examples**:\n    ```\n    firestore = ff.register_firestore(\n        name=\"firestore-quickstart\",\n        description=\"A Firestore deployment we created for the Featureform quickstart\",\n        project_id=\"quickstart-project\",\n        collection=\"quickstart-collection\",\n        credentials=ff.GCPCredentials(...)\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Firestore provider to be registered\n        project_id (str): (Immutable) The Project name in GCP\n        collection (str): (Immutable) The Collection name in Firestore under the given project ID\n        credentials (GCPCredentials): (Mutable) GCP credentials to access Firestore\n        description (str): (Mutable) Description of Firestore provider to be registered\n        team (str): (Mutable) The name of the team registering the filestore\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        firestore (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = FirestoreConfig(\n        collection=collection,\n        project_id=project_id,\n        credentials=credentials,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_gcs","title":"<code>register_gcs(name, bucket_name, root_path, credentials, description='', team='', tags=[], properties={})</code>","text":"<p>Register a GCS store provider.</p> <p>Examples: <pre><code>gcs = ff.register_gcs(\n    name=\"gcs-quickstart\",\n    credentials=ff.GCPCredentials(...),\n    bucket_name=\"bucket_name\",\n    root_path=\"featureform/path/\",\n    description=\"An gcs store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of GCS store to be registered</p> required <code>bucket_name</code> <code>str</code> <p>(Immutable) The bucket name</p> required <code>root_path</code> <code>str</code> <p>(Immutable) Custom path to be used by featureform</p> required <code>credentials</code> <code>GCPCredentials</code> <p>(Mutable) GCP credentials to access the bucket</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of GCS provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>gcs</code> <code>FileStoreProvider</code> <p>Provider has all the functionality of OfflineProvider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_gcs(\n    self,\n    name: str,\n    bucket_name: str,\n    root_path: str,\n    credentials: GCPCredentials,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a GCS store provider.\n\n    **Examples**:\n    ```\n    gcs = ff.register_gcs(\n        name=\"gcs-quickstart\",\n        credentials=ff.GCPCredentials(...),\n        bucket_name=\"bucket_name\",\n        root_path=\"featureform/path/\",\n        description=\"An gcs store provider to store offline\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of GCS store to be registered\n        bucket_name (str): (Immutable) The bucket name\n        root_path (str): (Immutable) Custom path to be used by featureform\n        credentials (GCPCredentials): (Mutable) GCP credentials to access the bucket\n        description (str): (Mutable) Description of GCS provider to be registered\n        team (str): (Mutable) The name of the team registering the filestore\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        gcs (FileStoreProvider): Provider\n            has all the functionality of OfflineProvider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n\n    if bucket_name == \"\":\n        raise ValueError(\"bucket_name is required and cannot be empty string\")\n\n    bucket_name = bucket_name.replace(\"gs://\", \"\")\n    if \"/\" in bucket_name:\n        raise ValueError(\n            \"bucket_name cannot contain '/'. bucket_name should be the name of the GCS bucket only.\"\n        )\n\n    gcs_config = GCSFileStoreConfig(\n        bucket_name=bucket_name, bucket_path=root_path, credentials=credentials\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=gcs_config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return FileStoreProvider(self, provider, gcs_config, gcs_config.type())\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_hdfs","title":"<code>register_hdfs(name, host, port, username='', path='', description='', team='', tags=[], properties={})</code>","text":"<p>Register a HDFS store provider.</p> <p>This has the functionality of an offline store and can be used as a parameter to a k8s or spark provider</p> <p>Examples: <pre><code>hdfs = ff.register_hdfs(\n    name=\"hdfs-quickstart\",\n    host=\"&lt;host&gt;\",\n    port=\"&lt;port&gt;\",\n    path=\"&lt;path&gt;\",\n    username=\"&lt;username&gt;\",\n    description=\"An hdfs store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of HDFS store to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) The hostname for HDFS</p> required <code>path</code> <code>str</code> <p>(Immutable) A storage path within HDFS</p> <code>''</code> <code>port</code> <code>str</code> <p>(Mutable) The IPC port for the Namenode for HDFS. (Typically 8020 or 9000)</p> required <code>username</code> <code>str</code> <p>(Mutable) A Username for HDFS</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of HDFS provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering HDFS</p> <code>''</code> <p>Returns:</p> Name Type Description <code>hdfs</code> <code>FileStoreProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_hdfs(\n    self,\n    name: str,\n    host: str,\n    port: str,\n    username: str = \"\",\n    path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a HDFS store provider.\n\n    This has the functionality of an offline store and can be used as a parameter\n    to a k8s or spark provider\n\n    **Examples**:\n    ```\n    hdfs = ff.register_hdfs(\n        name=\"hdfs-quickstart\",\n        host=\"&lt;host&gt;\",\n        port=\"&lt;port&gt;\",\n        path=\"&lt;path&gt;\",\n        username=\"&lt;username&gt;\",\n        description=\"An hdfs store provider to store offline\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of HDFS store to be registered\n        host (str): (Immutable) The hostname for HDFS\n        path (str): (Immutable) A storage path within HDFS\n        port (str): (Mutable) The IPC port for the Namenode for HDFS. (Typically 8020 or 9000)\n        username (str): (Mutable) A Username for HDFS\n        description (str): (Mutable) Description of HDFS provider to be registered\n        team (str): (Mutable) The name of the team registering HDFS\n\n    Returns:\n        hdfs (FileStoreProvider): Provider\n    \"\"\"\n\n    hdfs_config = HDFSConfig(host=host, port=port, path=path, username=username)\n\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=hdfs_config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return FileStoreProvider(self, provider, hdfs_config, hdfs_config.type())\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_k8s","title":"<code>register_k8s(name, store, description='', team='', docker_image='', tags=[], properties={})</code>","text":"<p>Register an offline store provider to run on Featureform's own k8s deployment. Examples: <pre><code>spark = ff.register_k8s(\n    name=\"k8s\",\n    store=AzureBlobStore(),\n    docker_image=\"my-repo/image:version\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of provider</p> required <code>store</code> <code>FileStoreProvider</code> <p>(Mutable) Reference to registered file store provider</p> required <code>docker_image</code> <code>str</code> <p>(Mutable) A custom docker image using the base image featureformcom/k8s_runner</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of primary data to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) A string parameter describing the team that owns the provider</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> Source code in <code>src/featureform/register.py</code> <pre><code>def register_k8s(\n    self,\n    name: str,\n    store: FileStoreProvider,\n    description: str = \"\",\n    team: str = \"\",\n    docker_image: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"\n    Register an offline store provider to run on Featureform's own k8s deployment.\n    **Examples**:\n    ```\n    spark = ff.register_k8s(\n        name=\"k8s\",\n        store=AzureBlobStore(),\n        docker_image=\"my-repo/image:version\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of provider\n        store (FileStoreProvider): (Mutable) Reference to registered file store provider\n        docker_image (str): (Mutable) A custom docker image using the base image featureformcom/k8s_runner\n        description (str): (Mutable) Description of primary data to be registered\n        team (str): (Mutable) A string parameter describing the team that owns the provider\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n    \"\"\"\n\n    tags, properties = set_tags_properties(tags, properties)\n    config = K8sConfig(\n        store_type=store.store_type(),\n        store_config=store.config(),\n        docker_image=docker_image,\n    )\n\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineK8sProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_model","title":"<code>register_model(name, tags=[], properties={})</code>","text":"<p>Register a model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Model to be registered</p> required <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ModelRegistrar</code> <code>Model</code> <p>Model</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_model(\n    self, name: str, tags: List[str] = [], properties: dict = {}\n) -&gt; Model:\n    \"\"\"Register a model.\n\n    Args:\n        name (str): Model to be registered\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        ModelRegistrar: Model\n    \"\"\"\n    model = Model(name, description=\"\", tags=tags, properties=properties)\n    self.__resources.append(model)\n    return model\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_mongodb","title":"<code>register_mongodb(name, username, password, database, host, port, throughput=1000, description='', team='', tags=[], properties={})</code>","text":"<p>Register a MongoDB provider.</p> <p>Examples: <pre><code>mongodb = ff.register_mongodb(\n    name=\"mongodb-quickstart\",\n    description=\"A MongoDB deployment\",\n    username=\"my_username\",\n    password=\"myPassword\",\n    database=\"featureform_database\"\n    host=\"my-mongodb.host.com\",\n    port=\"10225\",\n    throughput=10000\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of MongoDB provider to be registered</p> required <code>database</code> <code>str</code> <p>(Immutable) MongoDB database</p> required <code>host</code> <code>str</code> <p>(Immutable) MongoDB hostname</p> required <code>port</code> <code>str</code> <p>(Immutable) MongoDB port</p> required <code>username</code> <code>str</code> <p>(Mutable) MongoDB username</p> required <code>password</code> <code>str</code> <p>(Mutable) MongoDB password</p> required <code>throughput</code> <code>int</code> <p>(Mutable) The maximum RU limit for autoscaling in CosmosDB</p> <code>1000</code> <code>description</code> <code>str</code> <p>(Mutable) Description of MongoDB provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>mongodb</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_mongodb(\n    self,\n    name: str,\n    username: str,\n    password: str,\n    database: str,\n    host: str,\n    port: str,\n    throughput: int = 1000,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a MongoDB provider.\n\n    **Examples**:\n    ```\n    mongodb = ff.register_mongodb(\n        name=\"mongodb-quickstart\",\n        description=\"A MongoDB deployment\",\n        username=\"my_username\",\n        password=\"myPassword\",\n        database=\"featureform_database\"\n        host=\"my-mongodb.host.com\",\n        port=\"10225\",\n        throughput=10000\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of MongoDB provider to be registered\n        database (str): (Immutable) MongoDB database\n        host (str): (Immutable) MongoDB hostname\n        port (str): (Immutable) MongoDB port\n        username (str): (Mutable) MongoDB username\n        password (str): (Mutable) MongoDB password\n        throughput (int): (Mutable) The maximum RU limit for autoscaling in CosmosDB\n        description (str): (Mutable) Description of MongoDB provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        mongodb (OnlineProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = MongoDBConfig(\n        username=username,\n        password=password,\n        host=host,\n        port=port,\n        database=database,\n        throughput=throughput,\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_pinecone","title":"<code>register_pinecone(name, project_id, environment, api_key, description='', team='', tags=[], properties={})</code>","text":"<p>Register a Pinecone provider.</p> <p>Examples: <pre><code>pinecone = ff.register_pinecone(\n    name=\"pinecone-quickstart\",\n    project_id=\"2g13ek7\",\n    environment=\"us-west4-gcp-free\",\n    api_key=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Pinecone provider to be registered</p> required <code>project_id</code> <code>str</code> <p>(Immutable) Pinecone project id</p> required <code>environment</code> <code>str</code> <p>(Immutable) Pinecone environment</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Pinecone api key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Pinecone provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>pinecone</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_pinecone(\n    self,\n    name: str,\n    project_id: str,\n    environment: str,\n    api_key: str,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Pinecone provider.\n\n    **Examples**:\n    ```\n    pinecone = ff.register_pinecone(\n        name=\"pinecone-quickstart\",\n        project_id=\"2g13ek7\",\n        environment=\"us-west4-gcp-free\",\n        api_key=\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Pinecone provider to be registered\n        project_id (str): (Immutable) Pinecone project id\n        environment (str): (Immutable) Pinecone environment\n        api_key (str): (Mutable) Pinecone api key\n        description (str): (Mutable) Description of Pinecone provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        pinecone (OnlineProvider): Provider\n    \"\"\"\n\n    tags, properties = set_tags_properties(tags, properties)\n    config = PineconeConfig(\n        project_id=project_id, environment=environment, api_key=api_key\n    )\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_postgres","title":"<code>register_postgres(name, host, user, password, database, port='5432', description='', team='', sslmode='disable', tags=[], properties={})</code>","text":"<p>Register a Postgres provider.</p> <p>Examples: <pre><code>postgres = ff.register_postgres(\n    name=\"postgres-quickstart\",\n    description=\"A Postgres deployment we created for the Featureform quickstart\",\n    host=\"quickstart-postgres\",  # The internal dns name for postgres\n    port=\"5432\",\n    user=\"postgres\",\n    password=\"password\", #pragma: allowlist secret\n    database=\"postgres\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Postgres provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Postgres</p> required <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> <code>'5432'</code> <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>sslmode</code> <code>str</code> <p>(Mutable) SSL mode</p> <code>'disable'</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Postgres provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>postgres</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_postgres(\n    self,\n    name: str,\n    host: str,\n    user: str,\n    password: str,\n    database: str,\n    port: str = \"5432\",\n    description: str = \"\",\n    team: str = \"\",\n    sslmode: str = \"disable\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Postgres provider.\n\n    **Examples**:\n    ```\n    postgres = ff.register_postgres(\n        name=\"postgres-quickstart\",\n        description=\"A Postgres deployment we created for the Featureform quickstart\",\n        host=\"quickstart-postgres\",  # The internal dns name for postgres\n        port=\"5432\",\n        user=\"postgres\",\n        password=\"password\", #pragma: allowlist secret\n        database=\"postgres\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Postgres provider to be registered\n        host (str): (Immutable) Hostname for Postgres\n        database (str): (Immutable) Database\n        port (str): (Mutable) Port\n        user (str): (Mutable) User\n        password (str): (Mutable) Password\n        sslmode (str): (Mutable) SSL mode\n        description (str): (Mutable) Description of Postgres provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        postgres (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = PostgresConfig(\n        host=host,\n        port=port,\n        database=database,\n        user=user,\n        password=password,\n        sslmode=sslmode,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags or [],\n        properties=properties or {},\n    )\n\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_primary_data","title":"<code>register_primary_data(name, location, provider, tags, properties, variant='', owner='', description='')</code>","text":"<p>Register a primary data source.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> required <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>location</code> <code>Location</code> <p>Location of primary data</p> required <code>provider</code> <code>Union[str, OfflineProvider]</code> <p>Provider</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_primary_data(\n    self,\n    name: str,\n    location: Location,\n    provider: Union[str, OfflineProvider],\n    tags: List[str],\n    properties: dict,\n    variant: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n):\n    \"\"\"Register a primary data source.\n\n    Args:\n        name (str): Name of source\n        variant (str): Name of variant\n        location (Location): Location of primary data\n        provider (Union[str, OfflineProvider]): Provider\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of primary data to be registered\n\n    Returns:\n        source (ColumnSourceRegistrar): Source\n    \"\"\"\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    if variant == \"\":\n        variant = self.__run\n    if not isinstance(provider, str):\n        provider = provider.name()\n    source = SourceVariant(\n        created=None,\n        name=name,\n        variant=variant,\n        definition=PrimaryData(location=location),\n        owner=owner,\n        provider=provider,\n        description=description,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(source)\n    column_source_registrar = ColumnSourceRegistrar(self, source)\n    self.map_client_object_to_resource(column_source_registrar, source)\n    return column_source_registrar\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_qdrant","title":"<code>register_qdrant(name, grpc_host, api_key='', use_tls=False, description='', team='', tags=[], properties={})</code>","text":"<p>Register a Qdrant provider.</p> <p>Examples: <pre><code>qdrant = ff.register_qdrant(\n    name=\"qdrant-quickstart\",\n    grpc_host=\"xyz-example.eu-central.aws.cloud.qdrant.io:6334\",\n    api_key=\"&lt;API KEY&gt;\",\n    use_tls=True,\n    description=\"A Qdrant project for using embeddings in Featureform\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Qdrant provider to be registered</p> required <code>url</code> <code>str</code> <p>(Immutable) gRPC host of the Qdrant cluster, either in the cloud or via local deployment.</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Qdrant API key.</p> <code>''</code> <code>use_tls</code> <code>bool</code> <p>(Immutable) Whether to use TLS for the connection.</p> <code>False</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Qdrant provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>qdrant</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_qdrant(\n    self,\n    name: str,\n    grpc_host: str,\n    api_key: str = \"\",\n    use_tls: bool = False,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Qdrant provider.\n\n    **Examples**:\n    ```\n    qdrant = ff.register_qdrant(\n        name=\"qdrant-quickstart\",\n        grpc_host=\"xyz-example.eu-central.aws.cloud.qdrant.io:6334\",\n        api_key=\"&lt;API KEY&gt;\",\n        use_tls=True,\n        description=\"A Qdrant project for using embeddings in Featureform\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Qdrant provider to be registered\n        url (str): (Immutable) gRPC host of the Qdrant cluster, either in the cloud or via local deployment.\n        api_key (str): (Mutable) Qdrant API key.\n        use_tls (bool): (Immutable) Whether to use TLS for the connection.\n        description (str): (Mutable) Description of Qdrant provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        qdrant (OnlineProvider): Provider\n    \"\"\"\n    config = QdrantConfig(grpc_host=grpc_host, api_key=api_key, use_tls=use_tls)\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_redis","title":"<code>register_redis(name, host, port=6379, db=0, password='', description='', team='', tags=None, properties=None)</code>","text":"<p>Register a Redis provider.</p> <p>Examples: <pre><code>redis = ff.register_redis(\n    name=\"redis-quickstart\",\n    host=\"quickstart-redis\",\n    port=6379,\n    password=\"password\",\n    description=\"A Redis deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Redis provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Redis</p> required <code>db</code> <code>str</code> <p>(Immutable) Redis database number</p> <code>0</code> <code>port</code> <code>int</code> <p>(Mutable) Redis port</p> <code>6379</code> <code>password</code> <code>str</code> <p>(Mutable) Redis password</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Redis provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>Optional[List[str]]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <code>properties</code> <code>Optional[dict]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>None</code> <p>Returns:</p> Name Type Description <code>redis</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_redis(\n    self,\n    name: str,\n    host: str,\n    port: int = 6379,\n    db: int = 0,\n    password: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: Optional[List[str]] = None,\n    properties: Optional[dict] = None,\n):\n    \"\"\"Register a Redis provider.\n\n    **Examples**:\n    ```\n    redis = ff.register_redis(\n        name=\"redis-quickstart\",\n        host=\"quickstart-redis\",\n        port=6379,\n        password=\"password\",\n        description=\"A Redis deployment we created for the Featureform quickstart\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Redis provider to be registered\n        host (str): (Immutable) Hostname for Redis\n        db (str): (Immutable) Redis database number\n        port (int): (Mutable) Redis port\n        password (str): (Mutable) Redis password\n        description (str): (Mutable) Description of Redis provider to be registered\n        team (str): (Mutable) Name of team\n        tags (Optional[List[str]]): (Mutable) Optional grouping mechanism for resources\n        properties (Optional[dict]): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        redis (OnlineProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = RedisConfig(host=host, port=port, password=password, db=db)\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_redshift","title":"<code>register_redshift(name, host, port, user, password, database, description='', team='', sslmode='disable', tags=[], properties={})</code>","text":"<p>Register a Redshift provider.</p> <p>Examples: <pre><code>redshift = ff.register_redshift(\n    name=\"redshift-quickstart\",\n    description=\"A Redshift deployment we created for the Featureform quickstart\",\n    host=\"quickstart-redshift\",  # The internal dns name for redshift\n    port=\"5432\",\n    user=\"redshift\",\n    password=\"password\", #pragma: allowlist secret\n    database=\"dev\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Redshift provider to be registered</p> required <code>host</code> <code>str</code> <p>(Immutable) Hostname for Redshift</p> required <code>database</code> <code>str</code> <p>(Immutable) Redshift database</p> required <code>port</code> <code>str</code> <p>(Mutable) Port</p> required <code>user</code> <code>str</code> <p>(Mutable) User</p> required <code>password</code> <code>str</code> <p>(Mutable) Redshift password</p> required <code>sslmode</code> <code>str</code> <p>(Mutable) SSL mode</p> <code>'disable'</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Redshift provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>redshift</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_redshift(\n    self,\n    name: str,\n    host: str,\n    port: str,\n    user: str,\n    password: str,\n    database: str,\n    description: str = \"\",\n    team: str = \"\",\n    sslmode: str = \"disable\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Redshift provider.\n\n    **Examples**:\n    ```\n    redshift = ff.register_redshift(\n        name=\"redshift-quickstart\",\n        description=\"A Redshift deployment we created for the Featureform quickstart\",\n        host=\"quickstart-redshift\",  # The internal dns name for redshift\n        port=\"5432\",\n        user=\"redshift\",\n        password=\"password\", #pragma: allowlist secret\n        database=\"dev\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Redshift provider to be registered\n        host (str): (Immutable) Hostname for Redshift\n        database (str): (Immutable) Redshift database\n        port (str): (Mutable) Port\n        user (str): (Mutable) User\n        password (str): (Mutable) Redshift password\n        sslmode (str): (Mutable) SSL mode\n        description (str): (Mutable) Description of Redshift provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        redshift (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = RedshiftConfig(\n        host=host,\n        port=port,\n        database=database,\n        user=user,\n        password=password,\n        sslmode=sslmode,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_s3","title":"<code>register_s3(name, credentials, bucket_region, bucket_name, path='', description='', team='', tags=[], properties={})</code>","text":"<p>Register a S3 store provider.</p> <p>This has the functionality of an offline store and can be used as a parameter to a k8s or spark provider</p> <p>Examples: <pre><code>s3 = ff.register_s3(\n    name=\"s3-quickstart\",\n    credentials=aws_creds,\n    bucket_name=\"bucket_name\",\n    bucket_region=&lt;bucket_region&gt;,\n    path=\"path/to/store/featureform_files/in/\",\n    description=\"An s3 store provider to store offline\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of S3 store to be registered</p> required <code>bucket_name</code> <code>str</code> <p>(Immutable) AWS Bucket Name</p> required <code>bucket_region</code> <code>str</code> <p>(Immutable) AWS region the bucket is located in</p> required <code>path</code> <code>str</code> <p>(Immutable) The path used to store featureform files in</p> <code>''</code> <code>credentials</code> <code>AWSCredentials</code> <p>(Mutable) AWS credentials to access the bucket</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of S3 provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) The name of the team registering the filestore</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>s3</code> <code>FileStoreProvider</code> <p>Provider has all the functionality of OfflineProvider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_s3(\n    self,\n    name: str,\n    credentials: AWSCredentials,\n    bucket_region: str,\n    bucket_name: str,\n    path: str = \"\",\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a S3 store provider.\n\n    This has the functionality of an offline store and can be used as a parameter\n    to a k8s or spark provider\n\n    **Examples**:\n    ```\n    s3 = ff.register_s3(\n        name=\"s3-quickstart\",\n        credentials=aws_creds,\n        bucket_name=\"bucket_name\",\n        bucket_region=&lt;bucket_region&gt;,\n        path=\"path/to/store/featureform_files/in/\",\n        description=\"An s3 store provider to store offline\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of S3 store to be registered\n        bucket_name (str): (Immutable) AWS Bucket Name\n        bucket_region (str): (Immutable) AWS region the bucket is located in\n        path (str): (Immutable) The path used to store featureform files in\n        credentials (AWSCredentials): (Mutable) AWS credentials to access the bucket\n        description (str): (Mutable) Description of S3 provider to be registered\n        team (str): (Mutable) The name of the team registering the filestore\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        s3 (FileStoreProvider): Provider\n            has all the functionality of OfflineProvider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n\n    if bucket_name == \"\":\n        raise ValueError(\"bucket_name is required and cannot be empty string\")\n\n    # TODO: add verification into S3StoreConfig\n    bucket_name = bucket_name.replace(\"s3://\", \"\").replace(\"s3a://\", \"\")\n\n    if \"/\" in bucket_name:\n        raise ValueError(\n            \"bucket_name cannot contain '/'. bucket_name should be the name of the AWS S3 bucket only.\"\n        )\n\n    s3_config = S3StoreConfig(\n        bucket_path=bucket_name,\n        bucket_region=bucket_region,\n        credentials=credentials,\n        path=path,\n    )\n\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=s3_config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return FileStoreProvider(self, provider, s3_config, s3_config.type())\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_snowflake","title":"<code>register_snowflake(name, username, password, account, organization, database, schema='PUBLIC', description='', team='', warehouse='', role='', tags=[], properties={})</code>","text":"<p>Register a Snowflake provider.</p> <p>Examples: <pre><code>snowflake = ff.register_snowflake(\n    name=\"snowflake-quickstart\",\n    username=\"snowflake\",\n    password=\"password\", #pragma: allowlist secret\n    account=\"account\",\n    organization=\"organization\",\n    database=\"snowflake\",\n    schema=\"PUBLIC\",\n    description=\"A Snowflake deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Snowflake provider to be registered</p> required <code>account</code> <code>str</code> <p>(Immutable) Account</p> required <code>organization</code> <code>str</code> <p>(Immutable) Organization</p> required <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>schema</code> <code>str</code> <p>(Immutable) Schema</p> <code>'PUBLIC'</code> <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>warehouse</code> <code>str</code> <p>(Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.</p> <code>''</code> <code>role</code> <code>str</code> <p>(Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Snowflake provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_snowflake(\n    self,\n    name: str,\n    username: str,\n    password: str,\n    account: str,\n    organization: str,\n    database: str,\n    schema: str = \"PUBLIC\",\n    description: str = \"\",\n    team: str = \"\",\n    warehouse: str = \"\",\n    role: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Snowflake provider.\n\n    **Examples**:\n    ```\n    snowflake = ff.register_snowflake(\n        name=\"snowflake-quickstart\",\n        username=\"snowflake\",\n        password=\"password\", #pragma: allowlist secret\n        account=\"account\",\n        organization=\"organization\",\n        database=\"snowflake\",\n        schema=\"PUBLIC\",\n        description=\"A Snowflake deployment we created for the Featureform quickstart\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Snowflake provider to be registered\n        account (str): (Immutable) Account\n        organization (str): (Immutable) Organization\n        database (str): (Immutable) Database\n        schema (str): (Immutable) Schema\n        username (str): (Mutable) Username\n        password (str): (Mutable) Password\n        warehouse (str): (Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.\n        role (str): (Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session\n        description (str): (Mutable) Description of Snowflake provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        snowflake (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = SnowflakeConfig(\n        account=account,\n        database=database,\n        organization=organization,\n        username=username,\n        password=password,\n        schema=schema,\n        warehouse=warehouse,\n        role=role,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_snowflake_legacy","title":"<code>register_snowflake_legacy(name, username, password, account_locator, database, schema='PUBLIC', description='', team='', warehouse='', role='', tags=[], properties={})</code>","text":"<p>Register a Snowflake provider using legacy credentials.</p> <p>Examples: <pre><code>snowflake = ff.register_snowflake_legacy(\n    name=\"snowflake-quickstart\",\n    username=\"snowflake\",\n    password=\"password\",\n    account_locator=\"account-locator\",\n    database=\"snowflake\",\n    schema=\"PUBLIC\",\n    description=\"A Snowflake deployment we created for the Featureform quickstart\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Snowflake provider to be registered</p> required <code>account_locator</code> <code>str</code> <p>(Immutable) Account Locator</p> required <code>schema</code> <code>str</code> <p>(Immutable) Schema</p> <code>'PUBLIC'</code> <code>database</code> <code>str</code> <p>(Immutable) Database</p> required <code>username</code> <code>str</code> <p>(Mutable) Username</p> required <code>password</code> <code>str</code> <p>(Mutable) Password</p> required <code>warehouse</code> <code>str</code> <p>(Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.</p> <code>''</code> <code>role</code> <code>str</code> <p>(Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session</p> <code>''</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Snowflake provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>snowflake</code> <code>OfflineSQLProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_snowflake_legacy(\n    self,\n    name: str,\n    username: str,\n    password: str,\n    account_locator: str,\n    database: str,\n    schema: str = \"PUBLIC\",\n    description: str = \"\",\n    team: str = \"\",\n    warehouse: str = \"\",\n    role: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Snowflake provider using legacy credentials.\n\n    **Examples**:\n    ```\n    snowflake = ff.register_snowflake_legacy(\n        name=\"snowflake-quickstart\",\n        username=\"snowflake\",\n        password=\"password\",\n        account_locator=\"account-locator\",\n        database=\"snowflake\",\n        schema=\"PUBLIC\",\n        description=\"A Snowflake deployment we created for the Featureform quickstart\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Snowflake provider to be registered\n        account_locator (str): (Immutable) Account Locator\n        schema (str): (Immutable) Schema\n        database (str): (Immutable) Database\n        username (str): (Mutable) Username\n        password (str): (Mutable) Password\n        warehouse (str): (Mutable) Specifies the virtual warehouse to use by default for queries, loading, etc.\n        role (str): (Mutable) Specifies the role to use by default for accessing Snowflake objects in the client session\n        description (str): (Mutable) Description of Snowflake provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        snowflake (OfflineSQLProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = SnowflakeConfig(\n        account_locator=account_locator,\n        database=database,\n        username=username,\n        password=password,\n        schema=schema,\n        warehouse=warehouse,\n        role=role,\n    )\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSQLProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_spark","title":"<code>register_spark(name, executor, filestore, description='', team='', tags=[], properties={})</code>","text":"<p>Register a Spark on Executor provider.</p> <p>Examples: <pre><code>spark = ff.register_spark(\n    name=\"spark-quickstart\",\n    description=\"A Spark deployment we created for the Featureform quickstart\",\n    team=\"featureform-team\",\n    executor=databricks,\n    filestore=azure_blob_store\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Spark provider to be registered</p> required <code>executor</code> <code>ExecutorCredentials</code> <p>(Mutable) An Executor Provider used for the compute power</p> required <code>filestore</code> <code>FileStoreProvider</code> <p>(Mutable) A FileStoreProvider used for storage of data</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Spark provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>spark</code> <code>OfflineSparkProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_spark(\n    self,\n    name: str,\n    executor: ExecutorCredentials,\n    filestore: FileStoreProvider,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Spark on Executor provider.\n\n    **Examples**:\n    ```\n    spark = ff.register_spark(\n        name=\"spark-quickstart\",\n        description=\"A Spark deployment we created for the Featureform quickstart\",\n        team=\"featureform-team\",\n        executor=databricks,\n        filestore=azure_blob_store\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Spark provider to be registered\n        executor (ExecutorCredentials): (Mutable) An Executor Provider used for the compute power\n        filestore (FileStoreProvider): (Mutable) A FileStoreProvider used for storage of data\n        description (str): (Mutable) Description of Spark provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        spark (OfflineSparkProvider): Provider\n    \"\"\"\n    tags, properties = set_tags_properties(tags, properties)\n    config = SparkConfig(\n        executor_type=executor.type(),\n        executor_config=executor.config(),\n        store_type=filestore.store_type(),\n        store_config=filestore.config(),\n    )\n\n    provider = Provider(\n        name=name,\n        function=\"OFFLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OfflineSparkProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_sql_transformation","title":"<code>register_sql_transformation(name, query, provider, variant='', owner='', description='', schedule='', args=None, inputs=None, tags=[], properties={})</code>","text":"<p>Register a SQL transformation source.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> required <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>query</code> <code>str</code> <p>SQL query</p> required <code>provider</code> <code>Union[str, OfflineProvider]</code> <p>Provider</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <code>schedule</code> <code>str</code> <p>Kubernetes CronJob schedule string (\" * * * \")</p> <code>''</code> <code>args</code> <code>K8sArgs</code> <p>Additional transformation arguments</p> <code>None</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_sql_transformation(\n    self,\n    name: str,\n    query: str,\n    provider: Union[str, OfflineProvider],\n    variant: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n    schedule: str = \"\",\n    args: K8sArgs = None,\n    inputs: Union[List[NameVariant], List[str], List[ColumnSourceRegistrar]] = None,\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a SQL transformation source.\n\n    Args:\n        name (str): Name of source\n        variant (str): Name of variant\n        query (str): SQL query\n        provider (Union[str, OfflineProvider]): Provider\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of primary data to be registered\n        schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n        args (K8sArgs): Additional transformation arguments\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        source (ColumnSourceRegistrar): Source\n    \"\"\"\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    if variant == \"\":\n        variant = self.__run\n    if not isinstance(provider, str):\n        provider = provider.name()\n    source = SourceVariant(\n        created=None,\n        name=name,\n        variant=variant,\n        definition=SQLTransformation(query, args),\n        owner=owner,\n        schedule=schedule,\n        provider=provider,\n        description=description,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(source)\n    return ColumnSourceRegistrar(self, source)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_training_set","title":"<code>register_training_set(name, variant='', features=[], label=('', ''), resources=[], owner='', description='', schedule='', tags=[], properties={})</code>","text":"<p>Register a training set.</p> <p>Example: <pre><code>ff.register_training_set(\n    name=\"my_training_set\",\n    label=(\"label\", \"v1\"),\n    features=[(\"feature1\", \"v1\"), (\"feature2\", \"v1\")],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of training set to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>label</code> <code>NameVariant</code> <p>Label of training set</p> <code>('', '')</code> <code>features</code> <code>List[NameVariant]</code> <p>Features of training set</p> <code>[]</code> <code>resources</code> <code>List[Resource]</code> <p>A list of previously registered resources</p> <code>[]</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of training set to be registered</p> <code>''</code> <code>schedule</code> <code>str</code> <p>Kubernetes CronJob schedule string (\" * * * \")</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>resource</code> <code>ResourceRegistrar</code> <p>resource</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_training_set(\n    self,\n    name: str,\n    variant: str = \"\",\n    features: Union[\n        list, List[FeatureColumnResource], MultiFeatureColumnResource\n    ] = [],\n    label: Union[NameVariant, LabelColumnResource] = (\"\", \"\"),\n    resources: list = [],\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n    schedule: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a training set.\n\n    **Example**:\n    ```\n    ff.register_training_set(\n        name=\"my_training_set\",\n        label=(\"label\", \"v1\"),\n        features=[(\"feature1\", \"v1\"), (\"feature2\", \"v1\")],\n    )\n    ```\n\n    Args:\n        name (str): Name of training set to be registered\n        variant (str): Name of variant to be registered\n        label (NameVariant): Label of training set\n        features (List[NameVariant]): Features of training set\n        resources (List[Resource]): A list of previously registered resources\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of training set to be registered\n        schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        resource (ResourceRegistrar): resource\n    \"\"\"\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    if variant == \"\":\n        variant = self.__run\n\n    if not isinstance(features, (list, MultiFeatureColumnResource)):\n        raise ValueError(\n            f\"Invalid features type: {type(features)} \"\n            \"Features must be entered as a list of name-variant tuples (e.g. [('feature1', 'quickstart'), ('feature2', 'quickstart')]) or a list of FeatureColumnResource instances.\"\n        )\n    if not isinstance(label, (tuple, str, LabelColumnResource)):\n        raise ValueError(\n            f\"Invalid label type: {type(label)} \"\n            \"Label must be entered as a name-variant tuple (e.g. ('fraudulent', 'quickstart')), a resource name, or an instance of LabelColumnResource.\"\n        )\n\n    for resource in resources:\n        features += resource.features()\n        resource_label = resource.label()\n        # label == () if it is NOT manually entered\n        if label == (\"\", \"\"):\n            label = resource_label\n        # Elif: If label was updated to store resource_label it will not check the following elif\n        elif resource_label != ():\n            raise ValueError(\"A training set can only have one label\")\n\n    features, feature_lags = self.__get_feature_nv(features, self.__run)\n    if label == ():\n        raise ValueError(\"Label must be set\")\n    if features == []:\n        raise ValueError(\"A training-set must have atleast one feature\")\n    if isinstance(label, str):\n        label = (label, self.__run)\n    if not isinstance(label, LabelColumnResource) and label[1] == \"\":\n        label = (label[0], self.__run)\n\n    processed_features = []\n    for feature in features:\n        if isinstance(feature, tuple) and feature[1] == \"\":\n            feature = (feature[0], self.__run)\n        processed_features.append(feature)\n    resource = TrainingSetVariant(\n        created=None,\n        name=name,\n        variant=variant,\n        description=description,\n        owner=owner,\n        schedule=schedule,\n        label=label,\n        features=processed_features,\n        feature_lags=feature_lags,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(resource)\n    return resource\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_user","title":"<code>register_user(name, tags=[], properties={})</code>","text":"<p>Register a user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>User to be registered.</p> required <p>Returns:</p> Name Type Description <code>UserRegistrar</code> <code>UserRegistrar</code> <p>User</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_user(\n    self, name: str, tags: List[str] = [], properties: dict = {}\n) -&gt; UserRegistrar:\n    \"\"\"Register a user.\n\n    Args:\n        name (str): User to be registered.\n\n    Returns:\n        UserRegistrar: User\n    \"\"\"\n    user = User(name=name, tags=tags, properties=properties)\n    self.__resources.append(user)\n    return UserRegistrar(self, user)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.register_weaviate","title":"<code>register_weaviate(name, url, api_key, description='', team='', tags=[], properties={})</code>","text":"<p>Register a Weaviate provider.</p> <p>Examples: <pre><code>weaviate = ff.register_weaviate(\n    name=\"weaviate-quickstart\",\n    url=\"https://&lt;CLUSTER NAME&gt;.weaviate.network\",\n    api_key=\"&lt;API KEY&gt;\"\n    description=\"A Weaviate project for using embeddings in Featureform\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Weaviate provider to be registered</p> required <code>url</code> <code>str</code> <p>(Immutable) Endpoint of Weaviate cluster, either in the cloud or via another deployment operation</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Weaviate api key</p> required <code>description</code> <code>str</code> <p>(Mutable) Description of Weaviate provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>weaviate</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_weaviate(\n    self,\n    name: str,\n    url: str,\n    api_key: str,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Weaviate provider.\n\n    **Examples**:\n    ```\n    weaviate = ff.register_weaviate(\n        name=\"weaviate-quickstart\",\n        url=\"https://&lt;CLUSTER NAME&gt;.weaviate.network\",\n        api_key=\"&lt;API KEY&gt;\"\n        description=\"A Weaviate project for using embeddings in Featureform\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Weaviate provider to be registered\n        url (str): (Immutable) Endpoint of Weaviate cluster, either in the cloud or via another deployment operation\n        api_key (str): (Mutable) Weaviate api key\n        description (str): (Mutable) Description of Weaviate provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        weaviate (OnlineProvider): Provider\n    \"\"\"\n    config = WeaviateConfig(url=url, api_key=api_key)\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"register/#featureform.register.Registrar.set_default_owner","title":"<code>set_default_owner(user)</code>","text":"<p>Set default owner.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>User to be set as default owner of resources.</p> required Source code in <code>src/featureform/register.py</code> <pre><code>def set_default_owner(self, user: str):\n    \"\"\"Set default owner.\n\n    Args:\n        user (str): User to be set as default owner of resources.\n    \"\"\"\n    self.__default_owner = user\n</code></pre>"},{"location":"register/#featureform.register.Registrar.set_run","title":"<code>set_run(run='')</code>","text":"<p>Example 1: Using set_run() without arguments will generate a random run name. <pre><code>import featureform as ff\nff.set_run()\n\npostgres.register_table(\n    name=\"transactions\",\n    table=\"transactions_table\",\n)\n\n# Applying will register the source as name=transactions, variant=&lt;randomly-generated&gt;\n</code></pre></p> <p>Example 2: Using set_run() with arguments will set the variant to the provided name. <pre><code>import featureform as ff\nff.set_run(\"last_30_days\")\n\npostgres.register_table(\n    name=\"transactions\",\n    table=\"transactions_table\",\n)\n\n# Applying will register the source as name=transactions, variant=last_30_days\n</code></pre></p> <p>Example 3: Generated and set variant names can be used together <pre><code>import featureform as ff\nff.set_run()\n\nfile = spark.register_file(\n    name=\"transactions\",\n    path=\"my/transactions.parquet\",\n    variant=\"last_30_days\"\n)\n\n@spark.df_transformation(inputs=[file]):\ndef customer_count(transactions):\n    return transactions.groupBy(\"CustomerID\").count()\n\n\n# Applying without a variant for the dataframe transformation will result in\n# the transactions source having a variant of last_30_days and the transformation\n# having a randomly generated variant\n</code></pre></p> <p>Example 4: This also works within SQL Transformations <pre><code>import featureform as ff\nff.set_run(\"last_30_days\")\n\n@postgres.sql_transformation():\ndef my_transformation():\n    return \"SELECT CustomerID, Amount FROM {{ transactions }}\"\n\n# The variant will be autofilled so the SQL query is returned as:\n# \"SELECT CustomerID, Amount FROM {{ transactions.last_30_days }}\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>run</code> <code>str</code> <p>Name of a run to be set.</p> <code>''</code> Source code in <code>src/featureform/register.py</code> <pre><code>def set_run(self, run: str = \"\"):\n    \"\"\"\n\n    **Example 1**: Using set_run() without arguments will generate a random run name.\n    ``` py\n    import featureform as ff\n    ff.set_run()\n\n    postgres.register_table(\n        name=\"transactions\",\n        table=\"transactions_table\",\n    )\n\n    # Applying will register the source as name=transactions, variant=&lt;randomly-generated&gt;\n\n    ```\n\n    **Example 2**: Using set_run() with arguments will set the variant to the provided name.\n    ``` py\n    import featureform as ff\n    ff.set_run(\"last_30_days\")\n\n    postgres.register_table(\n        name=\"transactions\",\n        table=\"transactions_table\",\n    )\n\n    # Applying will register the source as name=transactions, variant=last_30_days\n    ```\n\n    **Example 3**: Generated and set variant names can be used together\n    ``` py\n    import featureform as ff\n    ff.set_run()\n\n    file = spark.register_file(\n        name=\"transactions\",\n        path=\"my/transactions.parquet\",\n        variant=\"last_30_days\"\n    )\n\n    @spark.df_transformation(inputs=[file]):\n    def customer_count(transactions):\n        return transactions.groupBy(\"CustomerID\").count()\n\n\n    # Applying without a variant for the dataframe transformation will result in\n    # the transactions source having a variant of last_30_days and the transformation\n    # having a randomly generated variant\n    ```\n\n    **Example 4**: This also works within SQL Transformations\n    ``` py\n    import featureform as ff\n    ff.set_run(\"last_30_days\")\n\n    @postgres.sql_transformation():\n    def my_transformation():\n        return \"SELECT CustomerID, Amount FROM {{ transactions }}\"\n\n    # The variant will be autofilled so the SQL query is returned as:\n    # \"SELECT CustomerID, Amount FROM {{ transactions.last_30_days }}\"\n    ```\n\n    Args:\n        run (str): Name of a run to be set.\n    \"\"\"\n    if run == \"\":\n        if feature_flag.is_enabled(\"FF_GET_EQUIVALENT_VARIANTS\", True):\n            self.__run = get_current_timestamp_variant(self.__variant_prefix)\n        else:\n            self.__run = get_random_name()\n    else:\n        self.__run = run\n</code></pre>"},{"location":"register/#featureform.register.Registrar.set_variant_prefix","title":"<code>set_variant_prefix(variant_prefix='')</code>","text":"<p>Set variant prefix.</p> <p>Parameters:</p> Name Type Description Default <code>variant_prefix</code> <code>str</code> <p>variant prefix to be set.</p> <code>''</code> Source code in <code>src/featureform/register.py</code> <pre><code>def set_variant_prefix(self, variant_prefix: str = \"\"):\n    \"\"\"Set variant prefix.\n\n    Args:\n        variant_prefix (str): variant prefix to be set.\n    \"\"\"\n    self.__variant_prefix = variant_prefix\n    self.set_run()\n</code></pre>"},{"location":"register/#featureform.register.Registrar.sql_transformation","title":"<code>sql_transformation(provider, variant='', name='', schedule='', owner='', inputs=None, description='', args=None, tags=[], properties={})</code>","text":"<p>SQL transformation decorator.</p> <p>Parameters:</p> Name Type Description Default <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>provider</code> <code>Union[str, OfflineProvider]</code> <p>Provider</p> required <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>schedule</code> <code>str</code> <p>Kubernetes CronJob schedule string (\" * * * \")</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>inputs</code> <code>list</code> <p>Inputs to transformation</p> <code>None</code> <code>description</code> <code>str</code> <p>Description of SQL transformation</p> <code>''</code> <code>args</code> <code>K8sArgs</code> <p>Additional transformation arguments</p> <code>None</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>decorator</code> <code>SQLTransformationDecorator</code> <p>decorator</p> Source code in <code>src/featureform/register.py</code> <pre><code>def sql_transformation(\n    self,\n    provider: Union[str, OfflineProvider],\n    variant: str = \"\",\n    name: str = \"\",\n    schedule: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    inputs: Union[List[NameVariant], List[str], List[ColumnSourceRegistrar]] = None,\n    description: str = \"\",\n    args: K8sArgs = None,\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"SQL transformation decorator.\n\n    Args:\n        variant (str): Name of variant\n        provider (Union[str, OfflineProvider]): Provider\n        name (str): Name of source\n        schedule (str): Kubernetes CronJob schedule string (\"* * * * *\")\n        owner (Union[str, UserRegistrar]): Owner\n        inputs (list): Inputs to transformation\n        description (str): Description of SQL transformation\n        args (K8sArgs): Additional transformation arguments\n        tags (List[str]): Optional grouping mechanism for resources\n        properties (dict): Optional grouping mechanism for resources\n\n    Returns:\n        decorator (SQLTransformationDecorator): decorator\n    \"\"\"\n    if not isinstance(owner, str):\n        owner = owner.name()\n    if owner == \"\":\n        owner = self.must_get_default_owner()\n    if variant == \"\":\n        variant = self.__run\n    if not isinstance(provider, str):\n        provider = provider.name()\n    decorator = SQLTransformationDecorator(\n        registrar=self,\n        name=name,\n        run=self.__run,\n        variant=variant,\n        provider=provider,\n        schedule=schedule,\n        owner=owner,\n        description=description,\n        inputs=inputs,\n        args=args,\n        tags=tags,\n        properties=properties,\n    )\n    return decorator\n</code></pre>"},{"location":"register/#featureform.register.OfflineSQLProvider","title":"<code>featureform.register.OfflineSQLProvider</code>","text":"<p>               Bases: <code>OfflineProvider</code></p> Source code in <code>src/featureform/register.py</code> <pre><code>class OfflineSQLProvider(OfflineProvider):\n    def __init__(self, registrar, provider):\n        super().__init__(registrar, provider)\n        self.__registrar = registrar\n        self.__provider = provider\n\n    def register_table(\n        self,\n        name: str,\n        table: str,\n        variant: str = \"\",\n        owner: Union[str, UserRegistrar] = \"\",\n        description: str = \"\",\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"Register a SQL table as a primary data source.\n\n        **Example**\n\n        ```\n        postgres = client.get_provider(\"my_postgres\")\n        table =  postgres.register_table(\n            name=\"transactions\",\n            variant=\"july_2023\",\n            table=\"transactions_table\",\n        ):\n        ```\n\n        Args:\n            name (str): Name of table to be registered\n            variant (str): Name of variant to be registered\n            table (str): Name of SQL table\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of table to be registered\n\n        Returns:\n            source (ColumnSourceRegistrar): source\n        \"\"\"\n        return self.__registrar.register_primary_data(\n            name=name,\n            variant=variant,\n            location=SQLTable(table),\n            owner=owner,\n            provider=self.name(),\n            description=description,\n            tags=tags,\n            properties=properties,\n        )\n\n    def sql_transformation(\n        self,\n        owner: Union[str, UserRegistrar] = \"\",\n        variant: str = \"\",\n        name: str = \"\",\n        schedule: str = \"\",\n        description: str = \"\",\n        inputs: list = None,\n        tags: List[str] = [],\n        properties: dict = {},\n    ):\n        \"\"\"\n        Register a SQL transformation source.\n\n        The name of the function is the name of the resulting source.\n\n        Sources for the transformation can be specified by adding the Name and Variant in brackets '{{ name.variant }}'.\n        The correct source is substituted when the query is run.\n\n        **Examples**:\n\n        ``` py\n        postgres = client.get_provider(\"my_postgres\")\n        @postgres.sql_transformation(variant=\"quickstart\")\n        def average_user_transaction():\n            return \"SELECT CustomerID as user_id, avg(TransactionAmount) as avg_transaction_amt from {{transactions.v1}} GROUP BY user_id\"\n        ```\n\n        Args:\n            name (str): Name of source\n            variant (str): Name of variant\n            schedule (str): The frequency at which the transformation is run as a cron expression\n            owner (Union[str, UserRegistrar]): Owner\n            description (str): Description of primary data to be registered\n            inputs (list): A list of Source NameVariant Tuples to input into the transformation\n\n\n        Returns:\n            source (ColumnSourceRegistrar): Source\n        \"\"\"\n        return self.__registrar.sql_transformation(\n            name=name,\n            variant=variant,\n            owner=owner,\n            schedule=schedule,\n            provider=self.name(),\n            description=description,\n            inputs=inputs,\n            tags=tags,\n            properties=properties,\n        )\n</code></pre>"},{"location":"register/#featureform.register.OfflineSQLProvider.register_table","title":"<code>register_table(name, table, variant='', owner='', description='', tags=[], properties={})</code>","text":"<p>Register a SQL table as a primary data source.</p> <p>Example</p> <pre><code>postgres = client.get_provider(\"my_postgres\")\ntable =  postgres.register_table(\n    name=\"transactions\",\n    variant=\"july_2023\",\n    table=\"transactions_table\",\n):\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of table to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>table</code> <code>str</code> <p>Name of SQL table</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of table to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>source</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_table(\n    self,\n    name: str,\n    table: str,\n    variant: str = \"\",\n    owner: Union[str, UserRegistrar] = \"\",\n    description: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a SQL table as a primary data source.\n\n    **Example**\n\n    ```\n    postgres = client.get_provider(\"my_postgres\")\n    table =  postgres.register_table(\n        name=\"transactions\",\n        variant=\"july_2023\",\n        table=\"transactions_table\",\n    ):\n    ```\n\n    Args:\n        name (str): Name of table to be registered\n        variant (str): Name of variant to be registered\n        table (str): Name of SQL table\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of table to be registered\n\n    Returns:\n        source (ColumnSourceRegistrar): source\n    \"\"\"\n    return self.__registrar.register_primary_data(\n        name=name,\n        variant=variant,\n        location=SQLTable(table),\n        owner=owner,\n        provider=self.name(),\n        description=description,\n        tags=tags,\n        properties=properties,\n    )\n</code></pre>"},{"location":"register/#featureform.register.OfflineSQLProvider.sql_transformation","title":"<code>sql_transformation(owner='', variant='', name='', schedule='', description='', inputs=None, tags=[], properties={})</code>","text":"<p>Register a SQL transformation source.</p> <p>The name of the function is the name of the resulting source.</p> <p>Sources for the transformation can be specified by adding the Name and Variant in brackets '{{ name.variant }}'. The correct source is substituted when the query is run.</p> <p>Examples:</p> <pre><code>postgres = client.get_provider(\"my_postgres\")\n@postgres.sql_transformation(variant=\"quickstart\")\ndef average_user_transaction():\n    return \"SELECT CustomerID as user_id, avg(TransactionAmount) as avg_transaction_amt from {{transactions.v1}} GROUP BY user_id\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>schedule</code> <code>str</code> <p>The frequency at which the transformation is run as a cron expression</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <code>inputs</code> <code>list</code> <p>A list of Source NameVariant Tuples to input into the transformation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p> Source code in <code>src/featureform/register.py</code> <pre><code>def sql_transformation(\n    self,\n    owner: Union[str, UserRegistrar] = \"\",\n    variant: str = \"\",\n    name: str = \"\",\n    schedule: str = \"\",\n    description: str = \"\",\n    inputs: list = None,\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"\n    Register a SQL transformation source.\n\n    The name of the function is the name of the resulting source.\n\n    Sources for the transformation can be specified by adding the Name and Variant in brackets '{{ name.variant }}'.\n    The correct source is substituted when the query is run.\n\n    **Examples**:\n\n    ``` py\n    postgres = client.get_provider(\"my_postgres\")\n    @postgres.sql_transformation(variant=\"quickstart\")\n    def average_user_transaction():\n        return \"SELECT CustomerID as user_id, avg(TransactionAmount) as avg_transaction_amt from {{transactions.v1}} GROUP BY user_id\"\n    ```\n\n    Args:\n        name (str): Name of source\n        variant (str): Name of variant\n        schedule (str): The frequency at which the transformation is run as a cron expression\n        owner (Union[str, UserRegistrar]): Owner\n        description (str): Description of primary data to be registered\n        inputs (list): A list of Source NameVariant Tuples to input into the transformation\n\n\n    Returns:\n        source (ColumnSourceRegistrar): Source\n    \"\"\"\n    return self.__registrar.sql_transformation(\n        name=name,\n        variant=variant,\n        owner=owner,\n        schedule=schedule,\n        provider=self.name(),\n        description=description,\n        inputs=inputs,\n        tags=tags,\n        properties=properties,\n    )\n</code></pre>"},{"location":"register/#featureform.register.ColumnSourceRegistrar","title":"<code>featureform.register.ColumnSourceRegistrar</code>","text":"<p>               Bases: <code>SourceRegistrar</code></p> Source code in <code>src/featureform/register.py</code> <pre><code>class ColumnSourceRegistrar(SourceRegistrar):\n    def __getitem__(self, columns: List[str]):\n        col_len = len(columns)\n        if col_len &lt; 2:\n            raise Exception(\n                f\"Expected 2 columns, but found {col_len}. Missing entity and/or source columns\"\n            )\n        elif col_len &gt; 3:\n            raise Exception(\n                f\"Found unrecognized columns {', '.join(columns[3:])}. Expected 2 required columns and an optional 3rd timestamp column\"\n            )\n        return (self.registrar(), self, columns)\n\n    def register_resources(\n        self,\n        entity: Union[str, EntityRegistrar],\n        entity_column: str,\n        owner: Union[str, UserRegistrar] = \"\",\n        inference_store: Union[str, OnlineProvider, FileStoreProvider] = \"\",\n        features: List[ColumnMapping] = None,\n        labels: List[ColumnMapping] = None,\n        timestamp_column: str = \"\",\n        description: str = \"\",\n        schedule: str = \"\",\n    ):\n        \"\"\"\n        Registers a features and/or labels that can be used in training sets or served.\n\n        **Examples**:\n        ``` py\n        average_user_transaction.register_resources(\n            entity=user,\n            entity_column=\"CustomerID\",\n            inference_store=local,\n            features=[\n                {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"TransactionAmount\", \"type\": \"float32\"},\n            ],\n        )\n        ```\n\n        Args:\n            entity (Union[str, EntityRegistrar]): The name to reference the entity by when serving features\n            entity_column (str): The name of the column in the source to be used as the entity\n            owner (Union[str, UserRegistrar]): The owner of the resource(s)\n            inference_store (Union[str, OnlineProvider, FileStoreProvider]): Where to store the materialized feature for serving. (Use the local provider in Localmode)\n            features (List[ColumnMapping]): A list of column mappings to define the features\n            labels (List[ColumnMapping]): A list of column mappings to define the labels\n            timestamp_column: (str): The name of an optional timestamp column in the dataset. Will be used to match the features and labels with point-in-time correctness\n\n        Returns:\n            registrar (ResourceRegister): Registrar\n        \"\"\"\n        return self.registrar().register_column_resources(\n            source=self,\n            entity=entity,\n            entity_column=entity_column,\n            owner=owner,\n            inference_store=inference_store,\n            features=features,\n            labels=labels,\n            timestamp_column=timestamp_column,\n            description=description,\n            schedule=schedule,\n            client_object=self,\n        )\n</code></pre>"},{"location":"register/#featureform.register.ColumnSourceRegistrar.register_resources","title":"<code>register_resources(entity, entity_column, owner='', inference_store='', features=None, labels=None, timestamp_column='', description='', schedule='')</code>","text":"<p>Registers a features and/or labels that can be used in training sets or served.</p> <p>Examples: <pre><code>average_user_transaction.register_resources(\n    entity=user,\n    entity_column=\"CustomerID\",\n    inference_store=local,\n    features=[\n        {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"TransactionAmount\", \"type\": \"float32\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>Union[str, EntityRegistrar]</code> <p>The name to reference the entity by when serving features</p> required <code>entity_column</code> <code>str</code> <p>The name of the column in the source to be used as the entity</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>The owner of the resource(s)</p> <code>''</code> <code>inference_store</code> <code>Union[str, OnlineProvider, FileStoreProvider]</code> <p>Where to store the materialized feature for serving. (Use the local provider in Localmode)</p> <code>''</code> <code>features</code> <code>List[ColumnMapping]</code> <p>A list of column mappings to define the features</p> <code>None</code> <code>labels</code> <code>List[ColumnMapping]</code> <p>A list of column mappings to define the labels</p> <code>None</code> <code>timestamp_column</code> <code>str</code> <p>(str): The name of an optional timestamp column in the dataset. Will be used to match the features and labels with point-in-time correctness</p> <code>''</code> <p>Returns:</p> Name Type Description <code>registrar</code> <code>ResourceRegister</code> <p>Registrar</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_resources(\n    self,\n    entity: Union[str, EntityRegistrar],\n    entity_column: str,\n    owner: Union[str, UserRegistrar] = \"\",\n    inference_store: Union[str, OnlineProvider, FileStoreProvider] = \"\",\n    features: List[ColumnMapping] = None,\n    labels: List[ColumnMapping] = None,\n    timestamp_column: str = \"\",\n    description: str = \"\",\n    schedule: str = \"\",\n):\n    \"\"\"\n    Registers a features and/or labels that can be used in training sets or served.\n\n    **Examples**:\n    ``` py\n    average_user_transaction.register_resources(\n        entity=user,\n        entity_column=\"CustomerID\",\n        inference_store=local,\n        features=[\n            {\"name\": \"avg_transactions\", \"variant\": \"quickstart\", \"column\": \"TransactionAmount\", \"type\": \"float32\"},\n        ],\n    )\n    ```\n\n    Args:\n        entity (Union[str, EntityRegistrar]): The name to reference the entity by when serving features\n        entity_column (str): The name of the column in the source to be used as the entity\n        owner (Union[str, UserRegistrar]): The owner of the resource(s)\n        inference_store (Union[str, OnlineProvider, FileStoreProvider]): Where to store the materialized feature for serving. (Use the local provider in Localmode)\n        features (List[ColumnMapping]): A list of column mappings to define the features\n        labels (List[ColumnMapping]): A list of column mappings to define the labels\n        timestamp_column: (str): The name of an optional timestamp column in the dataset. Will be used to match the features and labels with point-in-time correctness\n\n    Returns:\n        registrar (ResourceRegister): Registrar\n    \"\"\"\n    return self.registrar().register_column_resources(\n        source=self,\n        entity=entity,\n        entity_column=entity_column,\n        owner=owner,\n        inference_store=inference_store,\n        features=features,\n        labels=labels,\n        timestamp_column=timestamp_column,\n        description=description,\n        schedule=schedule,\n        client_object=self,\n    )\n</code></pre>"},{"location":"register/#qdrant","title":"Qdrant","text":"<p>Register a Qdrant provider.</p> <p>Examples: <pre><code>qdrant = ff.register_qdrant(\n    name=\"qdrant-quickstart\",\n    grpc_host=\"xyz-example.eu-central.aws.cloud.qdrant.io:6334\",\n    api_key=\"&lt;API KEY&gt;\",\n    use_tls=True,\n    description=\"A Qdrant project for using embeddings in Featureform\"\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>(Immutable) Name of Qdrant provider to be registered</p> required <code>url</code> <code>str</code> <p>(Immutable) gRPC host of the Qdrant cluster, either in the cloud or via local deployment.</p> required <code>api_key</code> <code>str</code> <p>(Mutable) Qdrant API key.</p> <code>''</code> <code>use_tls</code> <code>bool</code> <p>(Immutable) Whether to use TLS for the connection.</p> <code>False</code> <code>description</code> <code>str</code> <p>(Mutable) Description of Qdrant provider to be registered</p> <code>''</code> <code>team</code> <code>str</code> <p>(Mutable) Name of team</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>(Mutable) Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>qdrant</code> <code>OnlineProvider</code> <p>Provider</p> Source code in <code>src/featureform/register.py</code> <pre><code>def register_qdrant(\n    self,\n    name: str,\n    grpc_host: str,\n    api_key: str = \"\",\n    use_tls: bool = False,\n    description: str = \"\",\n    team: str = \"\",\n    tags: List[str] = [],\n    properties: dict = {},\n):\n    \"\"\"Register a Qdrant provider.\n\n    **Examples**:\n    ```\n    qdrant = ff.register_qdrant(\n        name=\"qdrant-quickstart\",\n        grpc_host=\"xyz-example.eu-central.aws.cloud.qdrant.io:6334\",\n        api_key=\"&lt;API KEY&gt;\",\n        use_tls=True,\n        description=\"A Qdrant project for using embeddings in Featureform\"\n    )\n    ```\n\n    Args:\n        name (str): (Immutable) Name of Qdrant provider to be registered\n        url (str): (Immutable) gRPC host of the Qdrant cluster, either in the cloud or via local deployment.\n        api_key (str): (Mutable) Qdrant API key.\n        use_tls (bool): (Immutable) Whether to use TLS for the connection.\n        description (str): (Mutable) Description of Qdrant provider to be registered\n        team (str): (Mutable) Name of team\n        tags (List[str]): (Mutable) Optional grouping mechanism for resources\n        properties (dict): (Mutable) Optional grouping mechanism for resources\n\n    Returns:\n        qdrant (OnlineProvider): Provider\n    \"\"\"\n    config = QdrantConfig(grpc_host=grpc_host, api_key=api_key, use_tls=use_tls)\n    provider = Provider(\n        name=name,\n        function=\"ONLINE\",\n        description=description,\n        team=team,\n        config=config,\n        tags=tags,\n        properties=properties,\n    )\n    self.__resources.append(provider)\n    return OnlineProvider(self, provider)\n</code></pre>"},{"location":"serve/","title":"Serving","text":""},{"location":"serve/#features","title":"Features","text":"<p>Returns the feature values for the specified entities.</p> <p>Examples: <pre><code>    client = ff.Client()\n    fpf = client.features([(\"avg_transactions\", \"quickstart\")], {\"user\": \"C1410926\"})\n    # Run features through model\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>features</code> <code>(list[str, str], list[str])</code> <p>List of Name Variant Tuples</p> required <code>entities</code> <code>dict</code> <p>Dictionary of entity name/value pairs</p> required <p>Returns:</p> Name Type Description <code>features</code> <code>Array</code> <p>An Numpy array of feature values in the order given by the inputs</p>"},{"location":"serve/#training-sets","title":"Training Sets","text":"<p>Return an iterator that iterates through the specified training set.</p> <p>Examples: <pre><code>    client = ff.Client()\n    dataset = client.training_set(\"fraud_training\", \"quickstart\")\n    training_dataset = dataset.repeat(10).shuffle(1000).batch(8)\n    for feature_batch in training_dataset:\n        # Train model\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of training set to be retrieved</p> required <code>variant</code> <code>str</code> <p>Variant of training set to be retrieved</p> <code>''</code> <p>Returns:</p> Name Type Description <code>training_set</code> <code>Dataset</code> <p>A training set iterator</p>"},{"location":"serve/#traintest-split-beta","title":"Train/Test Split (Beta)","text":"<p>(This functionality is currently only available for Clickhouse).</p> <p>Splits an existing training set into training and testing iterators. The split is processed on the underlying provider and calculated at serving time.</p> <p>Examples:</p> <pre><code>import featureform as ff\nclient = ff.Client()\ntrain, test = client\n    .training_set(\"fraud_training\", \"v1\")\n    .train_test_split(\n        test_size=0.7,\n        train_size=0.3,\n        shuffle=True,\n        random_state=None,\n        batch_size=5\n    )\n\nfor features, label in train:\n    print(features)\n    print(label)\n    clf.partial_fit(features, label)\n\nfor features, label in test:\n    print(features)\n    print(label)\n    clf.score(features, label)\n\n\n# TRAIN OUTPUT\n# np.array([\n#   [1, 1, 3],\n#   [5, 1, 2],\n#   [7, 6, 5],\n#   [8, 3, 3],\n#   [5, 2, 2],\n# ])\n# np.array([2, 4, 2, 3, 4])\n# np.array([\n#   [3, 1, 2],\n#   [5, 4, 5],\n# ])\n# np.array([6, 7])\n\n# TEST OUTPUT\n# np.array([\n#   [5, 1, 3],\n#   [4, 3, 1],\n#   [6, 6, 7],\n# ])\n# np.array([4, 6, 7])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>test_size</code> <code>float</code> <p>The ratio of test set size to train set size. Must be a value between 0 and 1. If excluded it will be the complement to the train_size. One of test_size or train_size must be specified.</p> <code>0</code> <code>train_size</code> <code>float</code> <p>The ratio of train set size to train set size. Must be a value between 0 and 1. If excluded it will be the complement to the test_size. One of test_size or train_size must be specified.</p> <code>0</code> <code>shuffle</code> <code>bool</code> <p>Whether to shuffle the dataset before splitting.</p> <code>True</code> <code>random_state</code> <code>Optional[int]</code> <p>A random state to shuffle the dataset. If None, the dataset will be shuffled randomly on every call. If &gt;0, the value will be used a seed to create random shuffle that can be repeated if subsequent calls use the same seed.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>The size of the batch to return from the iterator. Must be greater than 0.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>train</code> <code>Iterator</code> <p>An iterator for training values.</p> <code>test</code> <code>Iterator</code> <p>An iterator for testing values.</p>"},{"location":"serve/#sources","title":"Sources","text":"<p>Return a dataframe from a registered source or transformation</p> <p>Example: definitions.py<pre><code>transactions_df = client.dataframe(\"transactions\", \"quickstart\")\n\navg_user_transaction_df = transactions_df.groupby(\"CustomerID\")[\"TransactionAmount\"].mean()\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[SourceRegistrar, SubscriptableTransformation, str]</code> <p>The source or transformation to compute the dataframe from</p> required <code>variant</code> <code>str</code> <p>The source variant; can't be None if source is a string</p> <code>None</code> <code>limit</code> <code>int</code> <p>The maximum number of records to return; defaults to NO_RECORD_LIMIT</p> <code>NO_RECORD_LIMIT</code> <code>asynchronous</code> <code>bool</code> <p>Flag to determine whether the client should wait for resources to be in either a READY or FAILED state before returning. Defaults to False to ensure that newly registered resources are in a READY state prior to serving them as dataframes.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>The dataframe computed from the source or transformation</p>"},{"location":"serve/#nearest-neighbors","title":"Nearest Neighbors","text":"<p>Query the K nearest neighbors of a provider vector in the index of a registered feature variant</p> <p>Example:</p> definitions.py<pre><code># Get the 5 nearest neighbors of the vector [0.1, 0.2, 0.3] in the index of the feature \"my_feature\" with variant \"my_variant\"\nnearest_neighbors = client.nearest(\"my_feature\", \"my_variant\", [0.1, 0.2, 0.3], 5)\nprint(nearest_neighbors) # prints a list of entities (e.g. [\"entity1\", \"entity2\", \"entity3\", \"entity4\", \"entity5\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>feature</code> <code>Union[FeatureColumnResource, tuple(str, str)]</code> <p>Feature object or tuple of Feature name and variant</p> required <code>vector</code> <code>List[float]</code> <p>Query vector</p> required <code>k</code> <code>int</code> <p>Number of nearest neighbors to return</p> required"},{"location":"serve/#resource-location","title":"Resource Location","text":"<p>Returns the location of a registered resource. For SQL resources, it will return the table name and for file resources, it will return the file path.</p> <p>Example: definitions.py<pre><code>transaction_location = client.location(\"transactions\", \"quickstart\", ff.SOURCE)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[SourceRegistrar, SubscriptableTransformation, str]</code> <p>The source or transformation to compute the dataframe from</p> required <code>variant</code> <code>str</code> <p>The source variant; can't be None if source is a string</p> <code>None</code> <code>resource_type</code> <code>ResourceType</code> <p>The type of resource; can be one of ff.SOURCE, ff.FEATURE, ff.LABEL, or ff.TRAINING_SET</p> <code>None</code>"},{"location":"source_reuse/","title":"Reusing Sources","text":"<p>get_source() can be used to get a reference to an already registered primary source or transformation. The returned object can be used to register features and labels or be extended off of to create additional transformations.</p> <p>Examples:</p> <p>Registering a transformation from an existing source. <pre><code>spark = ff.get_spark(\"prod-spark\")\ntransactions = ff.get_source(\"transactions\",\"kaggle\")\n\n@spark.df_transformation(inputs=[transactions]):\ndef customer_count(transactions):\n    return transactions.groupBy(\"CustomerID\").count()\n</code></pre></p> <p>Registering a feature from an existing source. <pre><code>transactions = ff.get_source(\"transactions\",\"kaggle\")\n\ntransactions.register_resources(\n    entity=user,\n    entity_column=\"customerid\",\n    labels=[\n        {\"name\": \"fraudulent\", \"variant\": \"quickstart\", \"column\": \"isfraud\", \"type\": \"bool\"},\n    ],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source to be retrieved</p> required <code>variant</code> <code>str</code> <p>Name of variant of source to be retrieved</p> required <code>local</code> <code>bool</code> <p>If localmode is being used</p> <code>False</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"sources/","title":"Sources","text":""},{"location":"sources/#primary-sources","title":"Primary Sources","text":""},{"location":"sources/#tables","title":"Tables","text":"<p>Register a SQL table as a primary data source.</p> <p>Example</p> <pre><code>postgres = client.get_provider(\"my_postgres\")\ntable =  postgres.register_table(\n    name=\"transactions\",\n    variant=\"july_2023\",\n    table=\"transactions_table\",\n):\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of table to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>table</code> <code>str</code> <p>Name of SQL table</p> required <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of table to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>source</p>"},{"location":"sources/#transformations","title":"Transformations","text":""},{"location":"sources/#sql","title":"SQL","text":"<p>Register a SQL transformation source. The spark.sql_transformation decorator takes the returned string in the following function and executes it as a SQL Query.</p> <p>The name of the function is the name of the resulting source.</p> <p>Sources for the transformation can be specified by adding the Name and Variant in brackets '{{ name.variant }}'. The correct source is substituted when the query is run.</p> <p>Examples: <pre><code>@spark.sql_transformation(variant=\"quickstart\")\ndef average_user_transaction():\n    return \"SELECT CustomerID as user_id, avg(TransactionAmount) as avg_transaction_amt from {{transactions.v1}} GROUP BY user_id\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"sources/#dataframe","title":"Dataframe","text":"<p>Register a Dataframe transformation source. The spark.df_transformation decorator takes the contents of the following function and executes the code it contains at serving time.</p> <p>The name of the function is used as the name of the source when being registered.</p> <p>The specified inputs are loaded into dataframes that can be accessed using the function parameters.</p> <p>Examples: <pre><code>@spark.df_transformation(inputs=[(\"source\", \"one\")])        # Sources are added as inputs\ndef average_user_transaction(df):                           # Sources can be manipulated by adding them as params\n    return df\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <code>inputs</code> <code>list[Tuple(str, str)]</code> <p>A list of Source NameVariant Tuples to input into the transformation</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"training_sets/","title":"Training Sets","text":"<p>Register a training set.</p> <p>Example: <pre><code>ff.register_training_set(\n    name=\"my_training_set\",\n    label=(\"label\", \"v1\"),\n    features=[(\"feature1\", \"v1\"), (\"feature2\", \"v1\")],\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of training set to be registered</p> required <code>variant</code> <code>str</code> <p>Name of variant to be registered</p> <code>''</code> <code>label</code> <code>NameVariant</code> <p>Label of training set</p> <code>('', '')</code> <code>features</code> <code>List[NameVariant]</code> <p>Features of training set</p> <code>[]</code> <code>resources</code> <code>List[Resource]</code> <p>A list of previously registered resources</p> <code>[]</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of training set to be registered</p> <code>''</code> <code>schedule</code> <code>str</code> <p>Kubernetes CronJob schedule string (\" * * * \")</p> <code>''</code> <code>tags</code> <code>List[str]</code> <p>Optional grouping mechanism for resources</p> <code>[]</code> <code>properties</code> <code>dict</code> <p>Optional grouping mechanism for resources</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>resource</code> <code>ResourceRegistrar</code> <p>resource</p>"},{"location":"transformations/","title":"Transformations","text":""},{"location":"transformations/#sql-providers","title":"SQL Providers","text":"<p>Register a SQL transformation source.</p> <p>The name of the function is the name of the resulting source.</p> <p>Sources for the transformation can be specified by adding the Name and Variant in brackets '{{ name.variant }}'. The correct source is substituted when the query is run.</p> <p>Examples:</p> <pre><code>postgres = client.get_provider(\"my_postgres\")\n@postgres.sql_transformation(variant=\"quickstart\")\ndef average_user_transaction():\n    return \"SELECT CustomerID as user_id, avg(TransactionAmount) as avg_transaction_amt from {{transactions.v1}} GROUP BY user_id\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>schedule</code> <code>str</code> <p>The frequency at which the transformation is run as a cron expression</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <code>inputs</code> <code>list</code> <p>A list of Source NameVariant Tuples to input into the transformation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"transformations/#spark","title":"Spark","text":""},{"location":"transformations/#sql-transformation","title":"SQL Transformation","text":"<p>Register a SQL transformation source. The spark.sql_transformation decorator takes the returned string in the following function and executes it as a SQL Query.</p> <p>The name of the function is the name of the resulting source.</p> <p>Sources for the transformation can be specified by adding the Name and Variant in brackets '{{ name.variant }}'. The correct source is substituted when the query is run.</p> <p>Examples: <pre><code>@spark.sql_transformation(variant=\"quickstart\")\ndef average_user_transaction():\n    return \"SELECT CustomerID as user_id, avg(TransactionAmount) as avg_transaction_amt from {{transactions.v1}} GROUP BY user_id\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"transformations/#dataframe-transformation","title":"Dataframe Transformation","text":"<p>Register a Dataframe transformation source. The spark.df_transformation decorator takes the contents of the following function and executes the code it contains at serving time.</p> <p>The name of the function is used as the name of the source when being registered.</p> <p>The specified inputs are loaded into dataframes that can be accessed using the function parameters.</p> <p>Examples: <pre><code>@spark.df_transformation(inputs=[(\"source\", \"one\")])        # Sources are added as inputs\ndef average_user_transaction(df):                           # Sources can be manipulated by adding them as params\n    return df\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <code>inputs</code> <code>list[Tuple(str, str)]</code> <p>A list of Source NameVariant Tuples to input into the transformation</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"transformations/#kubernetes-pandas-runner","title":"Kubernetes Pandas Runner","text":""},{"location":"transformations/#sql-transformation_1","title":"SQL Transformation","text":"<p>Register a SQL transformation source. The k8s.sql_transformation decorator takes the returned string in the following function and executes it as a SQL Query.</p> <p>The name of the function is the name of the resulting source.</p> <p>Sources for the transformation can be specified by adding the Name and Variant in brackets '{{ name.variant }}'. The correct source is substituted when the query is run.</p> <p>Examples: <pre><code>@k8s.sql_transformation(variant=\"quickstart\")\ndef average_user_transaction():\n    return \"SELECT CustomerID as user_id, avg(TransactionAmount) as avg_transaction_amt from {{transactions.v1}} GROUP BY user_id\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>inputs</code> <code>list</code> <p>A list of Source NameVariant Tuples to input into the transformation</p> <code>None</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <code>docker_image</code> <code>str</code> <p>A custom Docker image to run the transformation</p> <code>''</code> <code>resource_specs</code> <code>K8sResourceSpecs</code> <p>Custom resource requests and limits</p> <code>None</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"transformations/#dataframe-transformation_1","title":"Dataframe Transformation","text":"<p>Register a Dataframe transformation source. The k8s.df_transformation decorator takes the contents of the following function and executes the code it contains at serving time.</p> <p>The name of the function is used as the name of the source when being registered.</p> <p>The specified inputs are loaded into dataframes that can be accessed using the function parameters.</p> <p>Examples: <pre><code>@k8s.df_transformation(inputs=[(\"source\", \"one\")])        # Sources are added as inputs\ndef average_user_transaction(df):                         # Sources can be manipulated by adding them as params\n    return df\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of source</p> <code>''</code> <code>variant</code> <code>str</code> <p>Name of variant</p> <code>''</code> <code>owner</code> <code>Union[str, UserRegistrar]</code> <p>Owner</p> <code>''</code> <code>description</code> <code>str</code> <p>Description of primary data to be registered</p> <code>''</code> <code>inputs</code> <code>list[Tuple(str, str)]</code> <p>A list of Source NameVariant Tuples to input into the transformation</p> <code>[]</code> <code>docker_image</code> <code>str</code> <p>A custom Docker image to run the transformation</p> <code>''</code> <code>resource_specs</code> <code>K8sResourceSpecs</code> <p>Custom resource requests and limits</p> <code>None</code> <p>Returns:</p> Name Type Description <code>source</code> <code>ColumnSourceRegistrar</code> <p>Source</p>"},{"location":"types/","title":"Types","text":""},{"location":"variant_names_generator/","title":"Variant names generator","text":""}]}